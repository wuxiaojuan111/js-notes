<!DOCTYPE html><html><head><title>JavaScript</title><meta charset='utf-8'><link href='https://cdn.maxiang.io/res-min/themes/marxico.css' rel='stylesheet'><style></style></head><body><div id='preview-contents' class='note-content'>
                        
                    

<div><div class="toc"><div class="toc">
<ul>
<li><a href="#javascript">JavaScript</a><ul>
<li><ul>
<li><a href="#js组成">js组成</a></li>
<li><a href="#js的使用">js的使用</a><ul>
<li><a href="#代码注释">代码注释</a></li>
<li><a href="#获取id类名标签">获取ID、类名、标签</a></li>
<li><a href="#操作属性">操作属性</a></li>
<li><a href="#变量let-var">变量(let var):</a></li>
<li><a href="#常量const">常量(const)</a></li>
<li><a href="#点的用法">点的用法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#数据类型ecmascript">数据类型:ECMAScript</a><ul>
<li><a href="#基本数据类型">基本数据类型</a><ul>
<li><ul>
<li><a href="#string-字符串">string 字符串</a></li>
</ul>
</li>
<li><a href="#number-数字">number 数字</a><ul>
<li><a href="#运算符">运算符</a></li>
<li><a href="#逻辑运算符">逻辑运算符:</a></li>
</ul>
</li>
<li><a href="#布尔类型boolean为了判断验证">布尔类型Boolean(为了判断、验证)</a></li>
<li><a href="#null和undefined">null和undefined</a></li>
<li><a href="#windowonload">window.onload:</a></li>
</ul>
</li>
<li><a href="#引用数据类型">引用数据类型</a><ul>
<li><ul>
<li><ul>
<li><a href="#引用类型复杂类型复合类型">（引用类型、复杂类型、复合类型）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#普通对象">普通对象</a><ul>
<li><a href="#typeof-检测数据类型">typeof 检测数据类型</a></li>
<li><a href="#判断数组的函数">判断数组的函数:</a></li>
</ul>
</li>
<li><a href="#循环">循环</a><ul>
<li><a href="#for循环">for循环</a></li>
<li><a href="#循环中的跳过跳出">循环中的跳过、跳出</a></li>
<li><a href="#while循环一般不知道要循环多少次才用">while循环:一般不知道要循环多少次才用</a></li>
<li><a href="#for-in对象使用for-in枚举对象的属性来达到循环目的">for in:对象使用for in枚举对象的属性来达到循环目的</a></li>
</ul>
</li>
<li><a href="#函数function">函数Function:</a></li>
<li><a href="#函数与方法的区分">函数与方法的区分</a></li>
<li><a href="#匿名函数">匿名函数()</a></li>
<li><a href="#前自增后自增">前自增后自增</a></li>
<li><a href="#判断">判断</a></li>
</ul>
</li>
<li><a href="#自定义属性">自定义属性</a><ul>
<li><a href="#属性的操作">属性的操作</a></li>
</ul>
</li>
<li><a href="#数组方法">数组方法</a><ul>
<li><a href="#1push">1、push:</a></li>
<li><a href="#2pop传参都是唬人的">2、pop(传参都是唬人的)</a></li>
<li><a href="#3unshift">3、unshift:</a></li>
<li><a href="#4shift">4、shift:</a></li>
<li><a href="#5splice">5、splice:</a></li>
<li><a href="#6foreach专门用来循环数组的">6、forEach:专门用来循环数组的。</a></li>
<li><a href="#7map">7、map:</a></li>
<li><a href="#8join">8、join():</a></li>
<li><a href="#9filter过滤条件成立的值">9、filter：过滤条件成立的值</a></li>
<li><a href="#10reverse翻转数组">10、reverse：翻转数组</a></li>
<li><a href="#11some">11、some:</a></li>
<li><a href="#12every">12、every:</a></li>
<li><a href="#13sort-排序">13、sort 排序</a></li>
<li><a href="#14concat">14、concat()</a></li>
<li><a href="#15数组截取">15、数组截取</a></li>
</ul>
</li>
<li><a href="#字符串方法">字符串方法</a><ul>
<li><a href="#1split">1、split(”):</a></li>
<li><a href="#2截取类substring00substr00">2、截取类:substring(0,0)、substr(0,0)</a></li>
<li><a href="#3indexof指定字符从哪位开始">3、indexOf(指定字符,从哪位开始)</a></li>
<li><a href="#4includes-包含字符串中是否包含指定字符包含就返回true否则false">4、includes 包含，字符串中是否包含指定字符，包含就返回true，否则false</a></li>
<li><a href="#5touppercase-把小写英文转成大写英文">5、toUpperCase  把小写英文转成大写英文</a></li>
<li><a href="#6tolowercase-把大写英文转成小写英文">6、toLowerCase  把大写英文转成小写英文</a></li>
<li><a href="#7trim-去掉前后空格">7、trim  去掉前后空格</a></li>
<li><a href="#8replace-替换">8、replace 替换</a></li>
</ul>
</li>
<li><a href="#时间对象">时间对象</a><ul>
<li><ul>
<li><a href="#获取出来的都是数字类型">获取出来的都是数字类型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#定时器">定时器</a></li>
<li><a href="#倒计时">倒计时</a><ul>
<li><ul>
<li><a href="#计算时间公式">计算时间公式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#递归函数自己调用自己">递归：函数自己调用自己</a></li>
<li><a href="#domdocument-object-model-文档对象模型">DOM：Document  Object  Model 文档对象模型</a></li>
<li><a href="#节点整个html中全是节点">节点：整个html中全是节点</a><ul>
<li><a href="#1属性nodetype-值是一个数字">1、属性：nodeType -&gt;值是一个数字</a></li>
<li><a href="#2childnodes-子节点">2、childNodes  子节点</a></li>
<li><a href="#3children-子级元素节点不是标准但是所有浏览器都支持">3、children  子级元素节点，不是标准，但是所有浏览器都支持</a></li>
<li><a href="#4nodevalue-查看节点内容">4、nodeValue  查看节点内容</a></li>
<li><a href="#5attributes-属性返回指定节点的属性集合即-namednodemap">5、attributes 属性返回指定节点的属性集合，即 NamedNodeMap。</a></li>
<li><a href="#6创建一个元素节点">6、创建一个元素节点</a></li>
<li><a href="#7添加元素">7、添加元素</a></li>
<li><a href="#8删除parentremovechild哪个元素">8、删除:parent.removeChild(哪个元素)</a></li>
<li><a href="#9clonenodetrue-克隆元素">9、cloneNode(true) 克隆元素</a></li>
</ul>
</li>
<li><a href="#math">Math</a></li>
<li><a href="#作用域">作用域</a><ul>
<li><a href="#1全局作用域">1.全局作用域</a></li>
<li><a href="#2私有作用域">2.私有作用域</a></li>
<li><a href="#3块级作用域">3.块级作用域</a></li>
<li><a href="#4作用域链">4.作用域链</a></li>
</ul>
</li>
<li><a href="#箭头函数">箭头函数</a><ul>
<li><ul>
<li><a href="#arguments-实参的集合">arguments 实参的集合</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#闭包">闭包</a></li>
</ul>
</li>
<li><a href="#git是个版本控制工具">git：是个版本控制工具</a><ul>
<li><ul>
<li><a href="#git-与-github进行关联">git 与 github进行关联</a></li>
<li><a href="#git版本控制工具新建控制项目">git:版本控制工具–新建控制项目:</a><ul>
<li><a href="#工作区到存储区">工作区到存储区:</a></li>
<li><a href="#暂存区到版本区">暂存区到版本区:</a></li>
<li><a href="#快速从工作区提交到版本区">快速从工作区提交到版本区</a></li>
<li><a href="#工作区查看暂存区">工作区查看暂存区:</a></li>
<li><a href="#暂存区查看版本区">暂存区查看版本区:</a></li>
<li><a href="#工作区查看版本区">工作区查看版本区:</a></li>
<li><a href="#查看版本">查看版本:</a></li>
<li><a href="#如果要看操作过的版本">如果要看操作过的版本:</a></li>
<li><a href="#还原版本">还原版本:</a></li>
<li><a href="#永久免密上传">永久免密上传:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#单例模式">单例模式:</a><ul>
<li><ul>
<li><a href="#单例模式功能相对单一用来描述具体一个事务">单例模式功能相对单一,用来描述具体一个事务。</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#工厂模式">工厂模式:</a></li>
<li><a href="#构造函数">构造函数:</a><ul>
<li><a href="#constructor构造函数">constructor：构造函数</a></li>
</ul>
</li>
<li><a href="#面向对象编程">面向对象编程:</a><ul>
<li><a href="#原型">原型：</a></li>
<li><a href="#原型链-proto">原型链: _proto_</a><ul>
<li><a href="#function的三种形态">function的三种形态</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#this的指向">this的指向</a></li>
<li><a href="#修改this指向的方法">修改this指向的方法</a></li>
<li><a href="#包装对象">包装对象：</a></li>
<li><a href="#自身属性">自身属性</a></li>
<li><a href="#json方法">JSON方法</a></li>
<li><a href="#继承">继承:</a><ul>
<li><a href="#class继承常用">class继承–常用</a></li>
<li><a href="#三点">三点…</a></li>
</ul>
</li>
<li><a href="#正则">正则</a></li>
<li><a href="#盒子模型">盒子模型</a><ul>
<li><a href="#计算后的样式">计算后的样式：</a></li>
<li><a href="#获取宽高尺寸">获取宽高尺寸：</a></li>
<li><a href="#可视区的宽高">可视区的宽高</a></li>
<li><a href="#绝对位置当前元素到页面顶端的位置">绝对位置：当前元素到页面顶端的位置。</a></li>
</ul>
</li>
<li><a href="#bombrowser-object-model-浏览器对象模型">BOM:Browser Object Model  浏览器对象模型</a><ul>
<li><a href="#滚动距离">滚动距离</a></li>
<li><a href="#浏览器地址信息">浏览器地址信息</a></li>
<li><a href="#延迟加载">延迟加载</a></li>
<li><a href="#替换图片">替换图片</a></li>
</ul>
</li>
<li><a href="#修改class">修改class</a></li>
<li><a href="#运动函数-tween">运动函数   Tween</a><ul>
<li><a href="#速度版运动">速度版运动</a></li>
<li><a href="#时间版运动">时间版运动</a><ul>
<li><a href="#动画帧">动画帧:</a></li>
</ul>
</li>
<li><a href="#回调函数">回调函数</a></li>
</ul>
</li>
<li><a href="#事件">事件</a><ul>
<li><a href="#事件模型">事件模型</a></li>
<li><a href="#冒泡的坏处阻止冒泡">冒泡的坏处–阻止冒泡</a></li>
<li><a href="#冒泡的好处事件委托">冒泡的好处–事件委托</a></li>
<li><a href="#没有冒泡的也可以阻止穿透">没有冒泡的，也可以阻止穿透</a></li>
<li><a href="#坐标值">坐标值</a></li>
<li><a href="#键盘事件">键盘事件</a></li>
<li><a href="#事件默认行为">事件默认行为</a></li>
<li><a href="#右键默认菜单">右键默认菜单</a></li>
<li><a href="#输入文字">输入文字</a></li>
<li><a href="#焦点事件">焦点事件</a></li>
<li><a href="#滚轮事件">滚轮事件</a></li>
<li><a href="#加载事件">加载事件</a></li>
</ul>
</li>
<li><a href="#拖拽">拖拽</a><ul>
<li><ul>
<li><a href="#1拖拽">1、拖拽</a></li>
<li><a href="#2拖拽">2、拖拽</a></li>
<li><a href="#3dom2拖拽">3、DOM2拖拽</a></li>
</ul>
</li>
<li><a href="#4在限制范围内拖拽">4、在限制范围内拖拽</a><ul>
<li><a href="#5仿windows的拖拽">5、仿windows的拖拽</a></li>
</ul>
</li>
<li><a href="#自定义滚动条">自定义滚动条</a><ul>
<li><a href="#自定义滚动条加滚轮">自定义滚动条—加滚轮</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#云思路">云思路</a><ul>
<li><a href="#面包屑">面包屑</a></li>
<li><a href="#树形菜单">树形菜单</a></li>
<li><a href="#移动到">移动到</a></li>
<li><a href="#柯里化函数名字就是大高上currying">柯里化函数：名字就是大高上（Currying）</a></li>
</ul>
</li>
<li><a href="#jquery">jquery</a><ul>
<li><ul>
<li><a href="#jquery框架">jquery框架</a></li>
<li><a href="#jquery版dom">jquery版DOM</a></li>
<li><a href="#jquery版事件">jquery版事件</a></li>
<li><a href="#jquery插件接口">jquery插件接口</a></li>
<li><a href="#jquery运动">jquery运动</a></li>
<li><a href="#订阅模式">订阅模式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#es6">ES6</a><ul>
<li><ul>
<li><a href="#解构赋值用于对象或者数组">解构赋值：用于对象或者数组</a><ul>
<li><ul>
<li><a href="#什么是变量">什么是变量:</a></li>
</ul>
</li>
<li><a href="#数组解构申明一个数组把变量放到数组中变量数组的索引就对应赋值数组的索引赋值别的数据就报错">数组解构：申明一个数组，把变量放到数组中，变量数组的索引就对应“赋值数组”的索引。赋值别的数据就报错</a></li>
<li><a href="#对象解构值为对象变量也是对象变量对象的名字默认要是对象属性的名字">对象解构：值为对象，变量也是对象，变量对象的名字默认要是对象属性的名字</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#iterator-和-forof-循环">Iterator 和 for…of 循环</a><ul>
<li><a href="#for-of进行循环">for of进行循环</a></li>
<li><a href="#set">set</a></li>
<li><a href="#map">Map</a></li>
<li><a href="#iterator-遍历器只要数据中有symboliterator就能使用for-of">Iterator ,遍历器，只要数据中有Symbol.iterator就能使用for of</a></li>
<li><a href="#promise">promise</a></li>
</ul>
</li>
<li><a href="#generator">Generator</a><ul>
<li><ul>
<li><a href="#yield做了2件事">yield做了2件事</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#html5-css3-移动端">html5 + css3 + 移动端</a><ul>
<li><ul>
<li><a href="#html5的标签公司中对h5的理解就是移动端">html5的标签（公司中对H5的理解就是移动端）</a></li>
<li><a href="#块元素行内元素行内块元素">块元素/行内元素/行内块元素</a></li>
<li><a href="#h5标签">h5标签</a></li>
<li><a href="#重绘">重绘</a></li>
<li><a href="#重排回流">重排(回流)</a></li>
<li><a href="#渐变">渐变</a></li>
<li><a href="#背景">背景</a></li>
<li><a href="#圆角-border-radius">圆角 border-radius</a></li>
<li><a href="#盒子阴影">盒子阴影</a></li>
<li><a href="#文本阴影">文本阴影</a></li>
<li><a href="#css3选择器">CSS3选择器</a></li>
</ul>
</li>
<li><a href="#css3动画">CSS3动画</a><ul>
<li><a href="#动画结束触发">动画结束触发</a></li>
<li><a href="#2d变换">2d变换</a></li>
<li><a href="#3d">3D</a></li>
<li><a href="#关键帧运动">关键帧运动</a></li>
</ul>
</li>
<li><a href="#移动端rem布局">移动端rem布局</a></li>
<li><a href="#less">LESS</a></li>
<li><a href="#手机的三大事件">手机的三大事件</a><ul>
<li><a href="#移动端点透">移动端点透</a><ul>
<li><a href="#解决">解决:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#ajax">AJAX</a><ul>
<li><ul>
<li><a href="#目的从后台拿数据">目的：从后台拿数据</a></li>
<li><a href="#难点">难点</a></li>
</ul>
</li>
<li><a href="#url">url</a><ul>
<li><a href="#输入url回车之后发生了什么事">输入url回车之后发生了什么事?</a></li>
</ul>
</li>
<li><a href="#传统的交互方式">传统的交互方式</a></li>
<li><a href="#ajax的交互模型打电话模式">ajax的交互模型(打电话模式)</a></li>
<li><a href="#fetch请求数据">fetch请求数据</a></li>
<li><a href="#get和post">get和post</a><ul>
<li><a href="#获取xml的数据">获取XML的数据</a></li>
</ul>
</li>
<li><a href="#ajax对象的常用属性和事件">ajax对象的常用属性和事件</a></li>
</ul>
</li>
<li><a href="#cookie">cookie</a><ul>
<li><ul>
<li><a href="#cookie读写">cookie读写</a></li>
<li><a href="#cookie的小特性">cookie的小特性</a><ul>
<li><a href="#能够把对象转成url格式的内置对象">能够把对象转成url格式的内置对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#localstorage本地存储-前端小型的数据库">localStorage(本地存储)-&gt; 前端小型的数据库</a><ul>
<li><a href="#读写操作">读写操作</a></li>
<li><a href="#localstorage事件">localStorage事件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#跨域">跨域</a><ul>
<li><a href="#解决跨域问题">解决跨域问题:</a></li>
</ul>
</li>
<li><a href="#node含义">NODE含义</a><ul>
<li><a href="#node安装">NODE安装</a><ul>
<li><a href="#服务器语言">服务器语言</a></li>
<li><a href="#通过node更好的去理解前端做的事情">通过node更好的去理解前端做的事情</a></li>
<li><a href="#node的优势">node的优势</a></li>
<li><a href="#npmnode-package-manager">npm(Node Package Manager)</a></li>
<li><a href="#find-数组方法返回值">find -&gt;数组方法(返回值)</a></li>
<li><a href="#findindex-数组方法返回索引">findIndex -&gt;数组方法(返回索引)</a></li>
<li><a href="#fs-filesystem-文件管理">fs - FileSystem 文件管理</a></li>
</ul>
</li>
<li><a href="#express">express</a><ul>
<li><a href="#post">post</a></li>
<li><a href="#路由路径切换寻址">路由(路径切换，寻址)</a></li>
<li><a href="#express使用路由最多还是写2级就行了">express使用路由最多还是写2级就行了</a></li>
<li><a href="#swig">swig</a></li>
<li><a href="#express-脚手架一个配好的运行环境不需要自己配置">express 脚手架(一个配好的运行环境,不需要自己配置)</a></li>
<li><a href="#webpack">webpack</a></li>
<li><a href="#自动化构建工具">自动化构建工具</a><ul>
<li><a href="#dirname-当前路径">__dirname 当前路径</a></li>
<li><a href="#new-formdata专门处理二进制数据它下面只有一个方法appendkeyvalue">new FormData专门处理二进制数据，它下面只有一个方法，append(key,value)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webpack-自动化构建工具项目构建打包处理转换让浏览器支持的语法">webpack 自动化构建工具、项目构建、打包处理、转换让浏览器支持的语法</a><ul>
<li><a href="#四个核心概念">四个核心概念</a></li>
<li><a href="#安装">安装</a></li>
<li><a href="#配置">配置</a></li>
<li><a href="#设置packagejson-文件">设置package.json 文件</a></li>
<li><a href="#mode设置">mode设置</a><ul>
<li><a href="#webpack常用的插件安装命令">webpack常用的插件安装命令：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>



<h1 id="javascript">JavaScript</h1>

<ul><li><p>单线程</p></li>
<li><p>PC、H5、混合开发(Hybrid)、Node  <br>
性价比超级高</p></li>
</ul>



<h3 id="js组成">js组成</h3>

<ul><li><p>javascript  编程语言</p>

<ul>
<li><p>ECMAScript  标准（语法、规则）</p></li>
<li><p>DOM (Doument Object Model)  文档对象模型</p></li>
<li><p>BOM (Browser Object Model) 浏览器对象模型</p>

<blockquote>
  <p>Vue，React，jQuery，angular</p>
</blockquote></li></ul></li>
</ul>

<p><code>推荐书籍  <br>
JavaScript权威指南  <br>
JavaScript高级程序设计  <br>
DOM编程艺术  <br>
JavaScript性能优化  <br>
JavaScript数据结构与算法  <br>
nodeJS深入浅出  <br>
了不起的nodejs  <br>
http://es6.ruanyifeng.com/ ES6</code></p>



<h3 id="js的使用">js的使用</h3>

<ul><li><p>1.行内 <br>
 <code>&lt;div onclick="alert(1)"&gt;&lt;/div&gt;</code></p></li>
<li><p>2.内嵌</p>

<ul>
<li><p>把script标签放在body结束标签的上方</p></li></ul></li>
<li><p>3.外链 <br>
<code>&lt;script src="js的路径"&gt;&lt;/script&gt;</code>  </p>

<blockquote>
  <p>注意:如果加了src，script中不能执行js了。   </p>
</blockquote></li>
</ul>



<h4 id="代码注释">代码注释</h4>

<ul><li><p>//输出一个js代码   //注释一行代码</p></li>
<li><p>/**/ 多行代码注释    </p></li>
</ul>



<h4 id="获取id类名标签">获取ID、类名、标签</h4>

<ul><li><p>document.getElementById(‘字符串’);</p></li>
<li><p>document.getElementsByTagName(‘标签名’) *获取一组元素</p></li>
<li><p>document.querySelector(”) 能够获取一个元素，就算是获取一组，也只能获取到一组中的第一个。</p></li>
<li><p>document.querySelectorAll() 能够获取一组元素</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">var</span> oDiv1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'oDiv'</span>);
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> oDiv2 = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">'qqq'</span>)[<span class="hljs-number">0</span>];<span class="hljs-comment">//通过类名获取元素，我们得到的是一个集合，想要获取某个元素 需要用对应的索引来获取，索引都是从0开始的</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> oDiv3 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'div'</span>);<span class="hljs-comment">//通过标签名获取元素，得到的结果跟通过类名得到的结果一致</span>
</div><div class="hljs-line">        <span class="hljs-built_in">console</span>.log(oDiv1, oDiv2, oDiv3[<span class="hljs-number">0</span>]);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> str = oDiv2.innerHTML;
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> str1 = oDiv2.innerText;
</div><div class="hljs-line">        <span class="hljs-comment">// innerHTML 可以识别html结构； innerText 不能识别html结构</span>
</div><div class="hljs-line">        <span class="hljs-comment">// oDiv2.innerHTML = '&lt;h1&gt;珠峰&lt;/h1&gt;';</span>
</div><div class="hljs-line">        oDiv2.innerText = <span class="hljs-string">'&lt;h1&gt;珠峰&lt;/h1&gt;'</span>;
</div><div class="hljs-line">        <span class="hljs-comment">//str = '&lt;h1&gt;珠峰&lt;/h1&gt;';  不管用</span>
</div><div class="hljs-line">        <span class="hljs-built_in">console</span>.log(str, str1);
</div><div class="hljs-line">        oDiv2.className = <span class="hljs-string">'www'</span>;
</div></code></pre>



<h4 id="操作属性">操作属性</h4>

<ul><li><p>obj.属性名</p>

<ul>
<li><p>读操作: console.log(obj.属性名)</p></li>
<li><p>写操作: obj.属性名 = 要设置的值</p></li>
<li><p>要操作元素的样式: </p>

<ul>
<li><p>ele.style.某个样式 = ‘值’;</p></li>
<li><p>ele.className 操作类名</p></li></ul></li>
<li><p>要操作元素内容:</p>

<ul>
<li><p>input的内容: value</p>

<ul>
<li><p>input.value = ‘哈哈’;</p></li></ul></li>
<li><p>操作别的元素的内容:</p>

<ul>
<li><p>innerText  操作文本  读操作，只能获得文本</p></li>
<li><p>innerHTML  操作结构，读操作，获取到某个元素下的所有内容（包括文本、标签）</p></li></ul></li></ul></li>
<li><p>src</p></li>
<li><p>href</p></li>
<li><p><code>&lt;a href="javascript:;" id="a"&gt;1234&lt;/a&gt;</code>阻止默认跳转</p></li>
<li><p>scr，href不要直接用来进行判断</p></li></ul></li>
</ul>



<h4 id="变量let-var">变量(let var):</h4>

<ul><li><p>let 与 var 的区别：</p>

<ul>
<li><p>1.let一个变量只能申明一次</p></li>
<li><p>2.声明之后才能使用（有暂存死区）</p></li>
<li><p>3.不做window映射</p></li>
<li><p>4.支持块级作用域</p></li></ul></li>
<li><p>可变的量，把数据存储到自定义的名字中，为了复用，只要使用这个名字，就对应到等号后面的值</p>

<ul>
<li><p>let :</p>

<ul>
<li><p>声明变量的时候名字不能重复 <br>
不能以数字开头 <br>
名字不能用关键字 <br>
为了复用 <br>
**一般变量取名字用小驼峰命名法： <br>
开头小写，字母与字母之间的开头大写** <br>
例：getElementById</p></li></ul></li></ul></li>
</ul>



<h4 id="常量const">常量(const)</h4>

<ul><li><p>不可变的量，把数据存储到自定义的名字中，为了复用，只要使用这个名字，就对应到等号后面的值</p>

<ul>
<li><p>const:</p>

<ul>
<li><p>声明变量的时候名字不能重复 <br>
不能以数字开头 <br>
名字不能用关键字 <br>
一般在获取元素的时候会用</p></li></ul></li></ul></li>
<li><p>console.log  打印日志 <br>
console.dir  打印详细信息日志 <br>
alert        调用浏览器的默认弹框</p></li>
</ul>



<h4 id="点的用法">点的用法</h4>

<ul><li><p>点 从属关系 翻译成汉语 就是“的”</p></li>
<li><p>用 点 的地方我们可以用中括号[]</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"> <span class="hljs-keyword">var</span> oDiv = <span class="hljs-built_in">document</span>[<span class="hljs-string">'getElementById'</span>](<span class="hljs-string">'oDiv'</span>);
</div><div class="hljs-line"> <span class="hljs-keyword">debugger</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"> oDiv.style.width = <span class="hljs-string">'200px'</span>;
</div><div class="hljs-line"> oDiv[<span class="hljs-string">'style'</span>][<span class="hljs-string">'height'</span>] = <span class="hljs-string">'200px'</span>;
</div><div class="hljs-line"> oDiv.style.color = <span class="hljs-string">'#fff'</span>;
</div><div class="hljs-line"> oDiv.style.backgroundColor = <span class="hljs-string">'black'</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"> <span class="hljs-keyword">var</span> tex = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'tex'</span>);
</div><div class="hljs-line"> tex.value = <span class="hljs-string">'222'</span>;
</div></code></pre>



<h2 id="数据类型ecmascript">数据类型:ECMAScript</h2>

<ul><li><p>基本数据类型：操作值，就是单纯的赋值（简单类型、原始值）</p></li>
<li><p>引用数据类型：操作地址，就是赋址，改变A会影响B（复杂类型、引用值）</p></li>
</ul>



<h3 id="基本数据类型">基本数据类型</h3>

<ul><li><p>string 字符串</p></li>
<li><p>number 数字</p></li>
<li><p>boolean 布尔</p></li>
<li><p>null</p></li>
<li><p>undefined</p></li>
</ul>



<h5 id="string-字符串">string 字符串</h5>

<ul><li><p>’ ’ ” ” `` 成对显示的</p></li>
<li><p>有长度:length(只能读不能写)</p></li>
<li><p>获取字符串中的某个字符，使用下标  <br>
<code>字符串的拼接:  <br>
小技巧：  <br>
先把设置一个默认值，然后咔咔加加  '+ +'</code></p>

<blockquote>
  <p>注意: 换行的时候使用字符串拼接</p>
</blockquote></li>
<li><p>反引号(字符串模板) </p>

<ul>
<li><p>语法: 反引号${放变量,放运算}反引号</p></li>
<li><p>任何数据 + 字符串 = 字符串</p></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">&lt;input type=<span class="hljs-string">"text"</span> id=<span class="hljs-string">"inp"</span>&gt;
</div><div class="hljs-line">    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"btn"</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
</div><div class="hljs-line">    &lt;div id=<span class="hljs-string">"oDiv"</span>&gt;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// 字符串  用单引或者双引号或者反引号包含的部分</span>
</div><div class="hljs-line">        <span class="hljs-comment">// 双引号不能包含双引号，单引号不能包含单引号</span>
</div><div class="hljs-line">        <span class="hljs-comment">// var str = "qq'q";</span>
</div><div class="hljs-line">        <span class="hljs-comment">// var str2 = "w\"we";//把中间的双引号转译成了双引号本身</span>
</div><div class="hljs-line">        <span class="hljs-comment">// var str3 = `珠\`峰`;</span>
</div><div class="hljs-line">        <span class="hljs-comment">// var oDiv = document.getElementById('oDiv');</span>
</div><div class="hljs-line">        <span class="hljs-comment">//oDiv.innerHTML = '&lt;h1&gt;好的&lt;/h1&gt;';</span>
</div><div class="hljs-line">        <span class="hljs-comment">//oDiv.innerHTML = 'str';//给的就是字符串'str'</span>
</div><div class="hljs-line">        <span class="hljs-comment">//oDiv.innerHTML = str3;//给的是变量 str对应的值</span>
</div><div class="hljs-line">        <span class="hljs-comment">//oDiv.innerHTML = str + str3 + str2;//字符串的拼接</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">// oDiv.innerHTML = '&lt;h1&gt;' +</span>
</div><div class="hljs-line">        <span class="hljs-comment">//     '&lt;div&gt;' +</span>
</div><div class="hljs-line">        <span class="hljs-comment">//     '珠峰' +</span>
</div><div class="hljs-line">        <span class="hljs-comment">//     '&lt;/div&gt;' +</span>
</div><div class="hljs-line">        <span class="hljs-comment">//     '&lt;/h1&gt;';</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">//模板字符串</span>
</div><div class="hljs-line">        <span class="hljs-comment">// oDiv.innerHTML = `&lt;h1&gt;</span>
</div><div class="hljs-line">        <span class="hljs-comment">//         &lt;div&gt;</span>
</div><div class="hljs-line">        <span class="hljs-comment">//             str</span>
</div><div class="hljs-line">        <span class="hljs-comment">//            ${str} </span>
</div><div class="hljs-line">        <span class="hljs-comment">//         &lt;/div&gt;</span>
</div><div class="hljs-line">        <span class="hljs-comment">//     &lt;/h1&gt;</span>
</div><div class="hljs-line">        <span class="hljs-comment">// `;</span>
</div><div class="hljs-line">        <span class="hljs-comment">//反引号包含的字符串，我们想用变量时，需要使用${变量}的语法</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">//1、写法 引号(单双反)包含  有“\”代表转译</span>
</div><div class="hljs-line">        <span class="hljs-comment">//2、字符串拼接 一种是直接+ 若是反引号 还可以通过${}</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn'</span>),
</div><div class="hljs-line">            inp = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'inp'</span>),
</div><div class="hljs-line">            oDiv = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'oDiv'</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</div><div class="hljs-line">            oDiv.innerHTML = <span class="hljs-string">`我是<span class="hljs-subst">${inp.value}</span>;`</span>;
</div><div class="hljs-line">            inp.value = <span class="hljs-string">''</span>;<span class="hljs-comment">//清空inp</span>
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-comment">// btn.onclick = function () {</span>
</div><div class="hljs-line">        <span class="hljs-comment">//     // var val = inp.value;</span>
</div><div class="hljs-line">        <span class="hljs-comment">//     oDiv.innerHTML = '我是' + inp.value;</span>
</div><div class="hljs-line">        <span class="hljs-comment">// }</span>
</div></code></pre>



<h4 id="number-数字">number 数字</h4>

<ul><li><p>把其他数据类型转化成数字类型</p></li>
<li><p>强制类型转换:</p>

<ul>
<li><p>把数据转成数字 :Number()</p>

<ul>
<li><p>能转长得像数字的字符串</p></li>
<li><p>空字符串为0</p></li>
<li><p>空白数组为0</p></li>
<li><p>布尔值：true:1,false:0</p></li>
<li><p>null:0</p></li>
<li><p>别的都是NaN</p></li>
<li><p>数字类型中 只有 0 和 NaN 转成布尔类型是false; 其他都是true</p></li></ul></li></ul></li>
<li><p>parseInt(字符串,进制数):把字符串转成整数10进制的数字</p></li>
<li><p>parseInt转数组时，数组中第一位长得像数字，能转第一位</p></li>
<li><p>parseFloat(字符串):把字符串转成数字，并且保留小数</p></li>
<li><p>NaN -&gt; not a number 只要是非法的数学运算就会出现NaN</p></li>
<li><p>isNaN -&gt; 是NaN返回true，否则false</p>

<ul>
<li><p>isNaN(”) -&gt; Number(”) -&gt; 0 -&gt; false</p></li></ul></li>
<li><p>toFixed：返回结果是一个字符串</p>

<ul>
<li><p>保留几位小数，会四舍五入保留位数+1的数字 <br>
<code>比如：  <br>
10.322 -&gt; 保留2位 -&gt; 10.32  <br>
10.325 -&gt; 保留2位 -&gt; 10.33</code></p></li></ul></li>
<li><p>隐式类型转换:</p>

<ul>
<li><p>数字 + 字符串 = 字符串</p></li>
<li><p>数字 （-*除%） 字符串 = 数字</p></li></ul></li>
</ul>



<h5 id="运算符">运算符</h5>

<ul><li><p>加+  _    /  *  %模</p></li>
<li><p>! 取反</p></li>
<li><p>== （相等）只比较值即可，不用比较数据类型，在比较的时候会进行数据转换</p></li>
<li><p>如果数字与字符串进行比较的时候，双方转成<em>数字</em></p></li>
<li><p>如果字符串与字符串进行比较的时候，通过unicode编码进行比较</p></li>
<li><p>=== （全等）不但要比较值还要比较类型  性能比 == 要高 </p></li>
<li><p>!= （不等）</p></li>
</ul>



<h5 id="逻辑运算符">逻辑运算符:</h5>

<ul><li><p>&amp;&amp; 并且</p>

<ul>
<li><p>A &amp;&amp; B</p>

<ul>
<li><p>1.在if中使用 &amp;&amp; 的含义 A要成立，B也要成立</p></li>
<li><p>2.从顺序的角度上来说，A需要成立才会找B，如果A不成立就是A</p></li></ul></li></ul></li>
<li><p>|| 或者</p>

<ul>
<li><p>A || B</p>

<ul>
<li><p>1.在if中使用||如果A不成立那么会去找B,如果2个都不成立那么就为false</p></li>
<li><p>2.从顺序上来来说，如果A成立就不会去B了,如果A不成立那么会去找B。</p></li></ul></li></ul></li>
<li><p>: ? 三元(三目)</p>

<ul>
<li><p>一元 -&gt; typeof a;</p></li>
<li><p>二元 -&gt; 1 + 1</p></li>
<li><p>a?a:b 判断a是否成立,如果成立就走a否则走b</p>

<blockquote>
  <p>%： <br>
  5/2余1 <br>
  取余的技巧: <br>
  A &gt; B  取余数 <br>
  A &lt; B  取A <br>
  <code>// console.log(3621%3); <br>
  // console.log('20' &lt; 30); <br>
  // console.log('3' &gt; '2000'); <br>
  // console.log('3' !== 3);</code></p>
</blockquote></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">//number 整数 小数 NaN</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> n2 = <span class="hljs-string">'1'</span> + <span class="hljs-number">2</span>;<span class="hljs-comment">//字符串12</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> n3 = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<span class="hljs-comment">//数字的3</span>
</div><div class="hljs-line">        <span class="hljs-built_in">console</span>.log(n2, n3);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> n4 = <span class="hljs-string">'1'</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<span class="hljs-comment">//'12'+3 '123'</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> n5 = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<span class="hljs-comment">//3+3 6</span>
</div><div class="hljs-line">        <span class="hljs-built_in">console</span>.log(n4, n5);
</div><div class="hljs-line">        <span class="hljs-comment">//对于+号：两边只要有一个是字符串 那么就是字符串拼接；</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> n6 = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-string">'4'</span> + <span class="hljs-number">5</span>;<span class="hljs-comment">//3+3+'4'+5//6+'4'+5//'645'</span>
</div><div class="hljs-line">        <span class="hljs-built_in">console</span>.log(n6);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> n7 = <span class="hljs-string">'12'</span> - <span class="hljs-number">2</span>;<span class="hljs-comment">//10 先把两边的内容转成(Number)数字，再进行运算</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> n8 = <span class="hljs-number">12</span> - <span class="hljs-number">2</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">''</span>);<span class="hljs-comment">//0</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> m2 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">'12q'</span>);<span class="hljs-comment">//NaN</span>
</div><div class="hljs-line">        <span class="hljs-comment">//Number 转化的时候，字符串中有非数字(不包含小数点)，结果就是NaN</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">//四则运算 + - * / % 除了+  其他的都会把符号两边转化成数字再去运算</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> m3 = <span class="hljs-string">'12q'</span> + <span class="hljs-number">3</span>;
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> m4 = <span class="hljs-string">'12q'</span> - <span class="hljs-number">3</span>;<span class="hljs-comment">//NaN-3  --&gt;NaN</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        一个 = 是赋值，
</div><div class="hljs-line">        两个 == 是相对比较，三个 === 是绝对比较
</div><div class="hljs-line">        <span class="hljs-comment">// '1' == 1;//true</span>
</div><div class="hljs-line">        <span class="hljs-comment">// '1' === 1;//false</span>
</div><div class="hljs-line">        <span class="hljs-comment">// NaN == NaN//false</span>
</div><div class="hljs-line">        <span class="hljs-comment">// 'NaN' == NaN//false</span>
</div><div class="hljs-line">        <span class="hljs-comment">// //NaN 和谁都不相等</span>
</div><div class="hljs-line">        <span class="hljs-comment">// 'NaN'=='NaN'//true</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">'m2f4'</span>));<span class="hljs-comment">//isNaN(NaN) //true</span>
</div><div class="hljs-line">        <span class="hljs-literal">NaN</span>+<span class="hljs-number">1</span>+<span class="hljs-string">'2'</span><span class="hljs-comment">//NaN+'2' //NaN2</span>
</div><div class="hljs-line">        <span class="hljs-comment">//NaN和任何数字做运算 结果都是NaN</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-built_in">parseInt</span>    <span class="hljs-built_in">parseFloat</span>
</div><div class="hljs-line">        <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'12.3'</span>)<span class="hljs-comment">//12</span>
</div><div class="hljs-line">        <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'23.3q'</span>)<span class="hljs-comment">//12</span>
</div><div class="hljs-line">        <span class="hljs-comment">//从左向右查看，遇到非数字(包含小数点)即停，获取到的是前边的数字部分</span>
</div><div class="hljs-line">        <span class="hljs-comment">//若第一位是非数字，则结果就是NaN</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-built_in">Number</span>(<span class="hljs-string">''</span>)<span class="hljs-comment">//0</span>
</div><div class="hljs-line">        <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">''</span>)<span class="hljs-comment">//NaN</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">'12.3'</span>)<span class="hljs-comment">//12.3</span>
</div><div class="hljs-line">        <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">'1q2.3'</span>)<span class="hljs-comment">//1</span>
</div><div class="hljs-line">        <span class="hljs-comment">//从左向右查看，遇到非数字(不包含小数点)即停，获取到的是前边的数字部分</span>
</div><div class="hljs-line">        <span class="hljs-comment">//若第一位是非数字，则结果就是NaN</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-number">0.1</span>+<span class="hljs-number">0.2</span>==<span class="hljs-number">0.3</span><span class="hljs-comment">//false</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-built_in">Number</span>(<span class="hljs-string">'12.3q'</span>)<span class="hljs-comment">//NaN</span>
</div><div class="hljs-line"><span class="hljs-built_in">Number</span>() <span class="hljs-built_in">Number</span>(<span class="hljs-string">''</span>) <span class="hljs-built_in">Number</span>([]) <span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">//0</span>
</div><div class="hljs-line"><span class="hljs-built_in">Number</span>({}) <span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">//NaN</span>
</div><div class="hljs-line"><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">'12.3q'</span>)<span class="hljs-comment">//先用Number处理 括号内的参数</span>
</div><div class="hljs-line"><span class="hljs-built_in">parseInt</span>() 
</div><div class="hljs-line"><span class="hljs-built_in">parseFloat</span>()   
</div></code></pre>



<h4 id="布尔类型boolean为了判断验证">布尔类型Boolean(为了判断、验证)</h4>

<ul><li><p>把其他数据类型转化成布尔类型</p></li>
<li><p>数字类型中 只有0 和NaN转成布尔类型是false 其他都是true</p></li>
<li><p>字符串中 只有空字符串转成布尔是false，其他都是true</p></li>
<li><p>两个特殊的null和undefined是false</p></li>
</ul>

<p>值类型  基本数据类型 <br>
<code>除了 0 NaN '' null undefined 这五个值是false，其他都是true</code></p>

<ul><li><p>! 取非、取反 先把感叹号后边的内容转化成布尔类型，然后再去取反</p></li>
<li><p>!! 取反再取反，结果相当于用了一个Boolean，等于没取反 <br>
   <code>var bol = !1; //false <br>
     var bol2 = !''; //true <br>
     var bol3 = ![]; //false</code> </p></li>
</ul>



<h4 id="null和undefined">null和undefined</h4>

<ul><li><p>null 空指针对象</p>

<ul>
<li><p>一般在学习、开发中遇到null的情况基本上是元素没有获取到</p></li></ul></li>
<li><p>undefined 未定义，有五中种情况会出现undefined</p>

<ul>
<li><p>1.变量定义未赋值</p></li>
<li><p>2.对象没有某个属性的时候(对象没有属性是不会报错的)</p></li>
<li><p>3.函数没有return，默认为undefined</p></li>
<li><p>4.函数的形参数没有传实参 </p></li>
<li><p>基本数据类型的自定义属性</p></li></ul></li>
</ul>



<h4 id="windowonload">window.onload:</h4>

<ul><li><p>当页面加载完成执行函数内的代码。 <br>
<code>window.onload = function(){ <br>
const box = document.getElementById('box'); <br>
console.log(box.style); <br>
} <br>
// console.log(Object.prototype.__proto__); <br>
</code></p></li>
</ul>



<h3 id="引用数据类型">引用数据类型</h3>



<h6 id="引用类型复杂类型复合类型">（引用类型、复杂类型、复合类型）</h6>

<ul><li><p>引用数据类型：数组 对象 函数 正则 日期Date Math…</p></li>
</ul>



<h4 id="普通对象">普通对象</h4>

<ul><li><p>键值对    属性名:属性值</p></li>
<li><p>属性值 可以是  任意数据类型</p></li>
<li><p>属性名  都是字符串类型</p>

<ul>
<li><p><code>定义对象: <br>
    标准写法: <br>
       let obj = { <br>
           "name":"小红" <br>
       }  <br>
    不过属性名可以不写引号</code></p></li></ul></li>
</ul>

<p><code>var obj = { <br>
        name:"小红", <br>
        age:9, <br>
        1:2, <br>
        _:2, <br>
        $:3, <br>
    }; <br>
    // var 1 = 2; <br>
    var _ = 1234; <br>
    var $ = 123; <br>
    console.log(obj[1])</code></p>

<ul><li><p>获取属性值 有两种方式 </p>

<ul>
<li><p>一种是打点的方式，另一种是 [] 的方式</p></li>
<li><p>若属性名是 数字； 那么我们只能使用[]的方式</p></li>
<li><p>obj.1 错误</p></li>
<li><p>打点的方式  完全等价于  [字符串] <br>
<code>console.log(obj.age) <br>
console.log(obj['age']); <br>
var age = 'name'; <br>
console.log(obj[age]);// obj['name'] '小红' <br>
console.log(obj['age']) // obj.age 9 <br>
console.log(obj[obj[age]])//obj['小红'] <br>
// 对象中， 若没有对应的属性时，获取到的就是一个 undefined <br>
var qqq = obj.qqq; <br>
qqq === undefined <br>
console.log(qqq+''); <br>
var a = 12; <br>
var b = a; <br>
b = 13; <br>
console.log(a);// 12</code></p></li></ul></li>
</ul>



<h5 id="typeof-检测数据类型">typeof 检测数据类型</h5>

<p><code>string、number、undefined、boolean、object、function</code></p>

<blockquote>
  <p>相比ECMAScript的数据类型，是多了一个function，少了null（为object）</p>
  
  <ul><li><p>console.log(typeof 1) // ‘number’</p></li>
  <li><p>console.log(typeof ‘1’) // ‘string’</p></li>
  <li><p>console.log(typeof true) // ‘boolean’</p></li>
  <li><p>console.log(typeof undefined) // ‘undefined’</p></li>
  <li><p>console.log(typeof null) // ‘object’</p></li>
  <li><p>console.log(typeof typeof 1) // ‘string’      </p></li>
  <li><p>undefined === undefined //true</p></li>
  <li><p>console.log(b === undefined);</p></li>
  </ul>
  
  </blockquote>


<h5 id="判断数组的函数">判断数组的函数:</h5>

<ul><li><p>instanceof:左值是不是右值构造出来的，是就为true，否则false；右值是不是左值的老爹 <br>
<code>let arr = [1,2,3]; <br>
1.console.log(arr instanceof Object); <br>
2.console.log( Object.prototype.toString.call(arr) === '[object Array]' ) <br>
3.console.log(Array.isArray(arr));</code></p></li>
<li><p>delete obj.age;  //删除某个属性就用delete</p></li>
</ul>



<h4 id="循环">循环</h4>



<h5 id="for循环">for循环</h5>

<ul><li><p>1.let i=0 只走一次</p></li>
<li><p>2.判断条件 </p></li>
<li><p>3.进循环体</p></li>
<li><p>4.设置下次循环的条件</p>

<ul>
<li><p>2-&gt;3-&gt;4 2-&gt;3-&gt;4 <br>
<code>for(let i=0;i&lt;6;i++){ <br>
}</code></p>

<blockquote>
  <p>注意: <br>
  遇到for嵌套for的时候，里面的变量名不要和外面的变量名一样 <br>
  或者使用let <br>
  大循环进一次，执行完小循环。</p>
</blockquote></li></ul></li>
</ul>



<h5 id="循环中的跳过跳出">循环中的跳过、跳出</h5>

<ul><li><p>循环中的跳过：continue</p></li>
<li><p>循环中的跳出：break <br>
<code>for(let i=0;i&lt;6;i++){ <br>
    if(i===3){ <br>
        // continue <br>
        // break; <br>
    }; <br>
    alert(i); <br>
}</code></p></li>
</ul>



<h5 id="while循环一般不知道要循环多少次才用">while循环:一般不知道要循环多少次才用</h5>

<ul><li><p>1.判断条件</p></li>
<li><p>2.条件成立进循环体</p></li>
<li><p>3.设置下次循环的条件 <br>
<code>while(条件){ <br>
}</code></p></li>
</ul>



<h5 id="for-in对象使用for-in枚举对象的属性来达到循环目的">for in:对象使用for in枚举对象的属性来达到循环目的</h5>

<ul><li><p>1.通过枚举对象身上的属性名，来做到循环的目的</p></li>
<li><p>2.循环的次数跟对象的属性的个数有关系</p></li>
<li><p>3.只要是遍历对象的情况下，使用for in循环 <br>
<code>let obj = { <br>
    width:'100px', <br>
    height:'200px', <br>
    background:'red', <br>
    border:'1px solid #000' <br>
} <br>
for(let attr in obj){ <br>
    box.style[attr] = obj[attr]; <br>
}</code></p></li>
</ul>



<h4 id="函数function">函数Function:</h4>

<ul><li><p>代码块，为了复用。</p></li>
<li><p>定义:</p>

<ul>
<li><p>1.函数声明</p>

<ul>
<li><p>如果函数不带名字，那么属于匿名函数, 直接写匿名函数是会报错的。</p></li>
<li><p>如何避免报错呢？ <br>
    1.声明函数时要有名字 <br>
    2.匿名函数要为一个表达式</p></li></ul></li>
<li><p>2.函数表达式</p></li>
<li><p>3.类声明</p>

<ul>
<li><p>new Function</p></li></ul></li></ul></li>
<li><p>调用:</p>

<ul>
<li><p>函数名 + 括号  fn()</p></li>
<li><p>事件调用 onclick = function(){}</p>

<ul>
<li><p>一般是赋值一个匿名函数或者是赋值一个函数（名）地址</p></li></ul></li>
<li><p>定时器调用  </p>

<ul>
<li><p>setTimeout(function(){},1000);</p></li>
<li><p>setInterval(function(){},1000);   </p></li></ul></li></ul></li>
<li><p>定义函数的时候开辟了一个新的堆内存空间，把函数内的代码转成字符串，存到堆内存中，再把空间地址赋值给变量或者函数名</p></li>
<li><p>调用开辟一个执行栈，把代码块中的代码复制到执行栈中执行，参数赋值，执行上下文直到销毁变量</p></li>
<li><p>函数参数:</p>

<ul>
<li><p>在函数声明的时候放在括号内的自定义名字（形式上的参数）</p>

<ul>
<li><p>function fn(a){}  a就为形参</p></li></ul></li>
<li><p>实参:在函数调用的时候放在括号内的随意数据说（实实在在的参数）</p>

<ul>
<li><p>fn(1)  1就是实参</p>

<ul>
<li><p>实参能传所有类型的数据</p></li>
<li><p>实参内能传若干个数据，一个与一个之间用逗号分隔，且可以为所有的数据类型</p></li></ul></li></ul></li></ul></li>
<li><p>return</p>

<ul>
<li><p>函数执行有两件大事莫忘:</p>

<ul>
<li><p>1.执行函数</p></li>
<li><p>2.函数返回值</p>

<ul>
<li><p>函数内有return返回值就为return后面的值，如果没有return就是undefined</p></li>
<li><p>不管是函数还是方法，都有返回值。 <br>
<code>function fn(){ <br>
let a = 10; <br>
return a; <br>
} <br>
console.log(fn());</code></p></li></ul></li></ul></li></ul></li>
<li><p>return下面的代码会被中断</p></li>
<li><p>return也可以在函数中的循环下，终止循环</p></li>
<li><p>让函数外使用函数内的运算结果时，使用return。</p>

<ul>
<li><p>alert(alert(5));  //=&gt;5 undefined</p></li></ul></li>
<li><p>arguments是一个在函数内的类数组（长得像数组，但是不是真数组）        </p>

<ul>
<li><p>一般是实参有很多个，能用到arguments</p></li>
<li><p>arguments：只要是一个函数都有arguments，是一个实参的类数组集合，有length，能使用下标操作，但是不能使用数组的方法。</p></li>
<li><p>arguments的某个是跟形参一一对应的。</p></li></ul></li>
</ul>



<h4 id="函数与方法的区分">函数与方法的区分</h4>

<ul><li><p>函数: <br>
<code>function fn(){}</code></p></li>
<li><p>方法: <br>
<code>let obj = { <br>
fn:function(){ <br>
} <br>
}</code></p>

<ul>
<li><p>fn();  函数前面没有主，没有点</p></li>
<li><p>obj.fn(); 方法前面有主，有.</p>

<ul>
<li><p>1.元素没有获取到</p></li>
<li><p>2.在正则中搜索不到字符就会为null</p></li>
<li><p>3.原型链的末端 <br>
<code>function fn(){ <br>
console.log(this); <br>
} <br>
let obj = { <br>
fn:function(){ <br>
console.log(this); <br>
}, <br>
fn2:function(){ <br>
} <br>
} <br>
// fn(); //window <br>
// obj.fn(); //obj，.前面的 <br>
// let box = document.getElementById('box'); <br>
// console.log( box ); <br>
let str = '2345ndsja'; <br>
// console.log(str.match(/a/)); <br>
// console.log(Object.prototype.__proto__);</code></p></li></ul></li></ul></li>
</ul>

<p><code>凡是能用点的地方都能用[] <br>
 不过[]内要么是变量，要么是属性名(字符串) <br>
点 -&gt; 只有属性名才用.</code></p>



<h4 id="匿名函数">匿名函数()</h4>

<ul><li><p>( )提权:</p>

<ul>
<li><p>(1+1)*2  </p>

<ul>
<li><p>括号中的就变成了表达式</p></li></ul></li>
<li><p>匿名函数自执行</p>

<blockquote>
  <p>注意: 在匿名函数的前面加上分号，不然容易报错。</p>
</blockquote></li></ul></li>
</ul>



<h4 id="前自增后自增">前自增后自增</h4>

<ul><li><p>前自增++num;</p></li>
<li><p>后自增num++;</p>

<ul>
<li><p>当输出或者比较某个变量的时候，是变量与变量进行比较</p></li>
<li><p>前自增，在找到变量之前就被处理过了，找到变量是被处理过后的变量</p></li>
<li><p>后自增，在找到变量之前什么事儿都没发生，找到的变量就为非处理过的值  <br>
<code>// alert( num ++); //1  <br>
// alert(++ num); //2  <br>
// console.log(num++ == ++num ); //1 3 false  <br>
// console.log(++ num == num++);//2 2 true  <br>
// console.log(num);  <br>
btn.onclick = function(){  <br>
ul.innerHTML += '&lt;li&gt;'+ (++num) +'&lt;/li&gt;';  <br>
}</code></p></li></ul></li>
</ul>



<h4 id="判断">判断</h4>

<ul><li><p>if判断 <br>
<code>if(条件成立){  <br>
执行这里代码 <br>
}else{ 否则执行这里 <br>
}</code></p></li>
<li><p>switch <br>
<code>switch (变量) {  <br>
case 2: （条件）  <br>
console.log('语句一')  <br>
break; （中断判断）  <br>
default:（默认）  <br>
break;  <br>
}</code></p>

<blockquote>
  <p>注意:  <br>
  break必须写，不然会穿透（当一个条件成立之后，还会执行下面的代码）  <br>
  能用switch一定能用if判断，能用if判断的地方不一定能用switch</p>
</blockquote></li>
</ul>



<h3 id="自定义属性">自定义属性</h3>

<blockquote>
  <p>定义：就是给某个对象（元素）加上一个自定义的“变量” <br>
  目的：为了让这个“变量”跟某个对象（元素）进行对应。</p>
</blockquote>

<ul><li><p>当需要操作一个元素的时候去对应另一个元素（数据）， 那么就要想到索引（自定义属性）。</p>

<ul>
<li><p>obj.属性名 || obj[‘属性名’]</p></li>
<li><p>let a = 10; 变量，前面没有.</p></li>
<li><p>obj = { <br>
        a:10 <br>
    } <br>
    obj.a 属性，前面有.</p></li>
<li><p>function fn(){}  函数 <br>
    fn()</p></li>
<li><p>obj = { <br>
        fn:function(){}  方法 <br>
    } <br>
    obj.fn()</p></li></ul></li>
<li><p>this 在事件中，一般事件触发谁，this就是谁</p>

<ul>
<li><p>事件触发的时候，this就是触发的元素</p>

<ul>
<li><p>onclick  点击</p></li>
<li><p>onmouseover  移入</p></li>
<li><p>onmouseout   移出 <br>
<code>btn.num = 0;  <br>
btn2.num = 0; <br>
btn.onclick = fn; <br>
btn2.onclick = fn; <br>
// function(){ <br>
//     btn2.innerText = '按钮('+ (++num2) +')'; <br>
// } <br>
function fn(){ <br>
this.innerText = '按钮('+ (++this.num) +')'; <br>
// console.dir(this.num); //这个 <br>
}</code></p></li></ul></li></ul></li>
</ul>



<h4 id="属性的操作">属性的操作</h4>

<ul><li><p>box.属性有2种方式是可以直接获得到的</p>

<ul>
<li><p>1.设置了一个 box.zdy = 0;</p>

<ul>
<li><p>console.log(box.zdy)</p></li></ul></li>
<li><p>2.元素对象默认的属性</p>

<ul>
<li><p>box.id</p></li></ul></li></ul></li>
<li><p>在行间设置自定义属性</p>

<ul>
<li><p><strong>ele.setAttribute(‘属性名’,’属性值’)</strong></p></li>
<li><p><strong>ele.dataset.属性名=属性值</strong> 写操作</p></li></ul></li>
<li><p>在行间获取自定义属性</p>

<ul>
<li><p><strong>ele.getAttribute(‘属性名’)</strong></p></li>
<li><p><strong>ele.dataset.属性名</strong>读操作</p></li></ul></li>
</ul>



<h3 id="数组方法">数组方法</h3>

<ul><li><p>数组写法:</p>

<ul>
<li><p>let arr = []; 性能要高</p></li>
<li><p>let arr = new Array();</p>

<ul>
<li><p>有length,既能读也能写</p></li>
<li><p>数组中获取每个值通过下标去操作它 [1,2,3][number]</p></li>
<li><p>数组的最后一个一定是数组.length-1</p></li>
<li><p>把数组清空：arr.length = 0;</p></li>
<li><p>要知道数组中要什么方法，直接console.dir数组 <br>
去看 <code>__proto__</code>下的方法即可。</p></li></ul></li></ul></li>
</ul>



<h4 id="1push">1、push:</h4>

<ul><li><p>给数组的最后一位添加，一个或者多个数据，一个与一个之间用逗号分隔</p></li>
<li><p>返回值为新数组的长度，改变原数组。 <br>
<code>// let arr = new Array(); <br>
let arr = [1,'好的',true,function fn(){}]; <br>
// arr.length = 5; <br>
// arr[4] = '100'; <br>
let a = arr.push(5,2); <br>
console.dir(a);</code></p></li>
</ul>



<h4 id="2pop传参都是唬人的">2、pop(传参都是唬人的)</h4>

<ul><li><p>往数组的最后一位删除一个数据</p></li>
<li><p>返回值为删除的那个，改变原数组</p></li>
</ul>



<h4 id="3unshift">3、unshift:</h4>

<ul><li><p>往数组的首位添加一个或者多个数据</p></li>
<li><p>返回值是新数组的长度，改变原数组</p></li>
</ul>



<h4 id="4shift">4、shift:</h4>

<ul><li><p>往数组的首位删除一个数据</p></li>
<li><p>返回值是删除的那个，空即为undefined，改变原数组</p></li>
</ul>



<h4 id="5splice">5、splice:</h4>

<ul><li><p>能够增删改查数组,根据参数的不同，结果就不同</p></li>
<li><p>返回值为被删除数组，无删除则不返回，改变原数组</p>

<ul>
<li><p>删除:(2个参数)</p>

<ul>
<li><p>第一个参数就是从数组的第几位起（选择数组的起始位置）</p></li>
<li><p>从0开始计数</p></li>
<li><p>第二个参数就是操作几个数据(删除几个)</p></li>
<li><p>返回值就是删除的那几个 <br>
<code>let arr = [1,2,3,4]; <br>
console.log(arr.splice(0,2));//从0开始，删除2个</code></p></li></ul></li>
<li><p>添加:(从哪开始添加,是否替换,添加的数据)</p>

<ul>
<li><p>第一个参数就是从数组的第几位起（选择数组的起始位置）</p></li>
<li><p>从0开始计数</p></li>
<li><p>第二个参数 <br>
    就是操作几个数据(是否替换) <br>
    如果是替换，写替换几个数字</p></li>
<li><p>第三个参数:(或者以上) <br>
    添加多个 <br>
<code>let arr = [1,2,3,6,7,5,6,7,8]; <br>
从5开始，一个都不删除，添加6和7 <br>
最后的结果是: <br>
    [1,2,3,6,7,5,6,7,8] <br>
arr.splice(3,0,6,7);</code></p></li></ul></li>
<li><p>替换:</p>

<ul>
<li><p>第二个参数：替换几个 <br>
<code>let arr = [23,213,12]; <br>
从数组的第0位开始，删除23和213,替换成212 <br>
结果: <br>
    [212,12] <br>
arr.splice(0,2,212); <br>
console.log(arr);</code></p>

<blockquote>
  <p>注意: <br>
  如果第2位为0，那么返回值为空数组， <br>
  也就是说，第二位不为0，返回值就是你删除的那(几)个数据 <br>
  返回的是<em>数组</em>。</p>
</blockquote></li></ul></li></ul></li>
</ul>



<h4 id="6foreach专门用来循环数组的">6、forEach:专门用来循环数组的。</h4>

<ul><li><p>两个参数:</p>

<ul>
<li><p>第一个参数: <br>
函数-&gt; function(){} <br>
function(数组中的每个值,索引值,整个数组){ <br>
}</p></li>
<li><p>第二个参数: <br>
改变this指向,写啥是啥（如果写个null,undefined还是为window）</p></li></ul></li>
<li><p>返回值是undefined，不会改变原数组。 <br>
<code>let arr = [true,'haha',10,{},[1,2,3]]; <br>
arr.forEach(function(item,i,all){ <br>
    // console.log(item);//数组中的每项 <br>
    // console.log(i); //索引 <br>
    // console.log(this); <br>
},arr);</code></p></li>
</ul>



<h4 id="7map">7、map:</h4>

<ul><li><p>循环数组</p></li>
<li><p>返回值为新的数组，原数组不会改变。</p>

<ul>
<li><p>function(item,i,all){ <br>
            return 新数组的每项 <br>
        } <br>
<code>let arr = [1,'你好','哈哈','呵呵']; <br>
let newArr = arr.map(function(item,i,all){ <br>
// console.log(item,i,all) <br>
return '&lt;li&gt;'+ item +'&lt;/li&gt;' <br>
}); <br>
console.log(newArr); <br>
// console.log(); <br>
ul.innerHTML = newArr.join('');</code></p></li></ul></li>
</ul>



<h4 id="8join">8、join():</h4>

<ul><li><p>以某个字符串为连接符，连接数组的每一项</p></li>
<li><p>返回值一个字符串，不改变原数组</p>

<blockquote>
  <p>注意： <br>
  如果不需要连接符，必须使用空字符串表示” <br>
  <code>let arr = ['你','好','吗']; //'你|好' <br>
  console.log(arr.join('')); <br>
  // console.log(arr.join().length); <br>
  // console.log(arr[0]+arr[1]);</code></p>
</blockquote></li>
</ul>



<h4 id="9filter过滤条件成立的值">9、filter：过滤条件成立的值</h4>

<ul><li><p>参数: <br>
function(item,i,all){ <br>
 return 条件成立的某项 <br>
}</p>

<ul>
<li><p>在函数中，只有条件成立的结果才能返回到数组中</p></li>
<li><p>return必须是true</p></li></ul></li>
<li><p>返回值不会改变原数组 <br>
<code>//过滤大于28的数字 <br>
let arr = [18,28,38,48,26]; <br>
let arr2 = arr.filter(function(item,i){ <br>
    if(item &gt; 20 &amp;&amp; item &lt;= 28){ <br>
        return item; <br>
    } <br>
    // return item &gt; 20 &amp;&amp; item &lt;= 28; <br>
}); <br>
// let arr3 = arr.filter(e=&gt;e &gt; 20 &amp;&amp; e &lt;= 28); <br>
console.log(arr3);</code></p></li>
</ul>



<h4 id="10reverse翻转数组">10、reverse：翻转数组</h4>

<ul><li><p>颠倒数组顺序，改变原数组</p>

<ul>
<li><p>[1,2,3] -&gt; [3,2,1] <br>
<code>// let arr = [1,2,3]; <br>
// arr.reverse(); <br>
// console.dir(arr);  <br>
let str = '您迎欢峰珠'; //转成'珠峰欢迎您'    console.log(str.split('').reverse().join(''));</code></p></li></ul></li>
</ul>



<h4 id="11some">11、some:</h4>

<ul><li><p>查看数组中某项数据是否满足某个条件，</p>

<ul>
<li><p>只要有一个符合条件就返回true，</p></li>
<li><p>如果所有项条件都不成立，返回false</p></li></ul></li>
<li><p>返回一个布尔值 <br>
<code>let arr = [1,2,3,4,5]; <br>
//查看数组中是否有6，明显没有，就返回false <br>
console.log(arr.some(function(item){return item===6}))</code></p></li>
</ul>



<h4 id="12every">12、every:</h4>

<ul><li><p>判断数组中是不是每一项都符合某个条件 <br>
全部都符合返回true，只要有一项不符合就返回false</p>

<ul>
<li><p>参数: <br>
function (item,i,all){ <br>
        } <br>
<code>//就想知道，这个数组中是否所有项都为true <br>
let arr = [true,true,true,true,false]; <br>
let a = arr.every(function(item){ <br>
return item; <br>
}) <br>
console.log(a);</code></p></li></ul></li>
</ul>



<h4 id="13sort-排序">13、sort 排序</h4>

<ul><li><p>sort默认排序是按照unicode编码来排序的</p>

<ul>
<li><p>也可以使用自定义排序</p>

<ul>
<li><p>sort中需要传入一个函数，让a,b，是正数就交换位置，是负数就不交换位置</p></li>
<li><p>a-b就是从小到大排序</p></li>
<li><p>b-a就是从大到小排序</p></li></ul></li></ul></li>
<li><p>返回新数组，改变原数组 <br>
<code>let arr = ['2px',3,4,7,1,6,12]; <br>
arr.sort(function(a,b){ <br>
    return parseInt(a)-parseInt(b); <br>
}); <br>
console.log(arr);</code></p></li>
</ul>



<h4 id="14concat">14、concat()</h4>

<ul><li><p>连接一个或者多个数组</p></li>
<li><p>返回值为新的数组，不改变原数组</p></li>
<li><p>就算是没有数组连接</p>

<ul>
<li><p>比如：</p>

<ul>
<li><p>arr.concat() -&gt; 克隆一份数组 <br>
<code>let arr2 = [1,2,3]; <br>
let arr3 = [4,5,6]; <br>
console.log(arr2.concat(arr3,[7,8,9]));</code></p></li></ul></li></ul></li>
</ul>



<h4 id="15数组截取">15、数组截取</h4>

<ul><li><p>slice(包含起始位置,结束位置但不包含结束位置)</p>

<ul>
<li><p>返回值为新数组</p></li>
<li><p>不会改变原数组。 <br>
<code>let arr = [1,2,3,6,5]; <br>
console.log(arr.slice(2,4));//-&gt;[3,6] <br>
console.log(arr);</code>//-&gt;[1, 2, 3, 6, 5]</p></li></ul></li>
</ul>



<h3 id="字符串方法">字符串方法</h3>

<ul><li><p><strong>字符串: ” “” ``</strong></p></li>
<li><p>页面中获取出来的内容都是字符串</p>

<ul>
<li><p>（value、innerHTML、inerText、href、src、className、id、width…）</p>

<ul>
<li><p>new String(‘123’)</p></li></ul></li></ul></li>
<li><p>字符串的length只可读不可写</p></li>
<li><p>字符串的方法基本上是不改变原字符串的。</p></li>
</ul>



<h4 id="1split">1、split(”):</h4>

<ul><li><p>以字符为分隔符，把字符串分割为数组。</p></li>
<li><p>返回值是数组。</p></li>
<li><p>如果没有分割符，使用空字符串去切， <br>
如果什么都不传，把整个字符串放到数组中 <br>
<code>//    let str = '珠-峰'; //-&gt;  <br>
//    console.log(str.split('-')); //-&gt; ['珠','峰'] <br>
let str = '珠峰'; //-&gt; ['珠','峰'] <br>
console.log(str.split(''));</code></p></li>
</ul>



<h4 id="2截取类substring00substr00">2、截取类:substring(0,0)、substr(0,0)</h4>

<ul><li><p>substring(0,0)</p>

<ul>
<li><p>从哪里开始截取，到哪里结束，但不包含结束位置</p></li>
<li><p>如果你只传一个参数，那么就是从哪开始，截取到字符串的最后</p></li></ul></li>
<li><p>substr(0,0)  从哪开始截取几个 <br>
<code>// let str = new String('123'); <br>
// console.log(str); <br>
// let str = 'dsjdsadsandkjwyque01k'; <br>
// str.length = 1; <br>
// console.log(str.length); <br>
// console.dir(str); <br>
// console.log(str.substring(3,9));//dsadsa</code></p></li>
</ul>



<h4 id="3indexof指定字符从哪位开始">3、indexOf(指定字符,从哪位开始)</h4>

<ul><li><p>找到指定字符首次出现的位置，返回出来索引，找不到-1 <br>
<code>let str = 'xsdmufGxw'; <br>
// console.log(str.indexOf('x')) <br>
// console.log(str.indexOf('x',2)) <br>
// console.log(str.indexOf('z'))</code></p></li>
</ul>



<h4 id="4includes-包含字符串中是否包含指定字符包含就返回true否则false">4、includes 包含，字符串中是否包含指定字符，包含就返回true，否则false</h4>

<p><code>console.log(str.includes('z'));</code></p>



<h4 id="5touppercase-把小写英文转成大写英文">5、toUpperCase  把小写英文转成大写英文</h4>

<p><code>console.log(str.toUpperCase())</code></p>



<h4 id="6tolowercase-把大写英文转成小写英文">6、toLowerCase  把大写英文转成小写英文</h4>

<p><code>console.log(str.toLowerCase());</code></p>



<h4 id="7trim-去掉前后空格">7、trim  去掉前后空格</h4>

<p><code>console.log(' dsadjsadsa   '.trim())</code></p>



<h4 id="8replace-替换">8、replace 替换</h4>

<p><code>stringObject.replace(regexp/substr,replacement)</code></p>



<h3 id="时间对象">时间对象</h3>

<ul><li><p>日历、倒计时、时钟</p></li>
<li><p>时间对象:用户本地的时间（所以说不安全）</p></li>
<li><p>new Date()</p></li>
</ul>



<h5 id="获取出来的都是数字类型">获取出来的都是数字类型</h5>

<ul><li><p>年：date.getFullYear()</p></li>
<li><p>月：date.getMonth()+1</p>

<ul>
<li><p>获取出来的时间比当前月份少1,所以要加1</p></li></ul></li>
<li><p>日：date.getDate()</p></li>
<li><p>周几：date.getDay()  周日为0</p></li>
<li><p>时：date.getHours()</p></li>
<li><p>分：date.getMinutes()</p></li>
<li><p>秒：date.getSeconds() <br>
<code>let date = new Date(); <br>
// console.log(date.getFullYear()); <br>
// console.log(date.getMonth()+1); <br>
// console.log(date.getDate()); <br>
// console.log(date.getDay()); <br>
// console.log(date.getHours()) <br>
// console.log(date.getMinutes()); <br>
// console.log(date.getSeconds()); <br>
// console.log( new Date() )</code></p></li>
</ul>



<h3 id="定时器">定时器</h3>

<ul><li><p><strong>setInterval</strong>(函数,指定时间(毫秒),函数的实参) (连续炸)</p>

<ul>
<li><p>每间隔一段指定时间，就执行一次函数</p></li>
<li><p>返回值为数字(即为的编号)。</p>

<ul>
<li><p><strong>clearInterval</strong>(编号) ：清除</p></li></ul></li></ul></li>
<li><p>setTimeout(函数,指定时间(毫秒),第一个函数的实参)</p>

<ul>
<li><p>当到指定的时间时，只执行一次函数</p></li>
<li><p>返回值为数字(即为的编号)。</p>

<ul>
<li><p>clearTimeout(编号); ：清除 <br>
<code>let timer=null,timer2 = null; <br>
btn.onclick = function(){ <br>
// timer = setTimeout(function(){ <br>
//     console.log('bong,bong'); <br>
// },2000); <br>
timer2 = setInterval(function(){ <br>
console.log('bong,bong,就不信炸不死!'); <br>
},2000); <br>
} <br>
btn2.onclick = function(){ <br>
// console.log(timer,timer2); <br>
// clearTimeout(timer); <br>
clearInterval(timer2); <br>
}</code></p></li></ul></li></ul></li>
</ul>



<h3 id="倒计时">倒计时</h3>

<ul><li><p>未来的时间 -  现在的时间 = 剩下的时间</p>

<ul>
<li><p>12:30      -       12:10 = 20</p></li></ul></li>
<li><p>Math.floor(11.638683333) -&gt; 11  向下取整</p></li>
<li><p>Math.ceil(11.638683333) -&gt; 12   向上取整 <br>
<code>//时间对象中可以放数字，月份以当前月份 - 1 <br>
let d = new Date(2019,3,10,12,30); //未来的时间 <br>
function fn(){ <br>
let d2 = new Date(); //当前的时间 <br>
// console.log(d - d2); //毫秒来计算的 <br>
// 848206  <br>
let s = (d - d2)/1000; <br>
let m = Math.floor(s/60) <br>
box.innerHTML = m+'分'+Math.floor(s%60) +'秒'; <br>
// console.log(); <br>
} <br>
fn(); <br>
setInterval(fn,1000);</code></p></li>
</ul>



<h5 id="计算时间公式">计算时间公式</h5>

<ul><li><p>第一种公式： <br>
<code>天：86400 = 60*60*24  : Math.floor(t/86400) <br>
小时：Math.floor(t%86400/3600) <br>
分钟：Math.floor(t%86400%3600/60) <br>
秒：Math.floor(t%60)</code></p></li>
<li><p>第二种公式： <br>
<code>天  Math.floor(t/86400); <br>
    t%=86400; <br>
小时   var h=Math.floor(t/3600); <br>
     t%=3600; <br>
分钟   var m=Math.floor(t/60); <br>
秒     t%=60;</code></p></li>
<li><p>常用的取整公式 <br>
<code>x ~ y : Math.round(Math.random()*(y-x) + x) <br>
0 ~ x : Math.round(Math.random()*x) <br>
1 ~ x : Math.ceil(Math.random()*x)||1 <br>
0 ~ x-1 : Math.floor(Math.random()*x)</code></p></li>
<li><p>时间对象中可以放数字，月份以当前月份 - 1 <br>
<code>let d = new Date(2019,3,10,12,30); //未来的时间</code></p></li>
</ul>



<h3 id="递归函数自己调用自己">递归：函数自己调用自己</h3>

<ul><li><p>为什么要自己调用自己？</p>

<ul>
<li><p>一个函数里面有相应的运算或者是逻辑处理 <br>
需要这个处理重复执行，所以才需要自己调用自己。</p></li></ul></li>
</ul>

<blockquote>
  <p>注意：递归容易死循环，所以需要写上递归中终止条件</p>
  
  <p>遇到Maximum call stack size exceeded报错，就是递归死循环 <br>
  <code>let n = 10; <br>
   function fn(n) { <br>
       if (n == 1) return 1; <br>
       return fn(n - 1) + n; <br>
   } <br>
   console.log(fn(n));</code></p>
</blockquote>



<h3 id="domdocument-object-model-文档对象模型">DOM：Document  Object  Model 文档对象模型</h3>

<ul><li><p>通过document提供了一些api，能够赋予开发者操作页面的能力</p></li>
<li><p>当通过document提供的api获取到元素的时候，获取到的元素是个对象，它跟页面的标签是相映射的关系，也就是说，通过操作对象的属性能够操作标签。</p></li>
<li><p>DOM树 -&gt; 由节点组成。</p></li>
<li><p>难点关系:</p>

<ul>
<li><p>父子关系</p>

<ul>
<li><p>parentNode  父节点</p></li>
<li><p>childNodes  所有子节点（包括元素节点、文本节点、注释节点）</p></li>
<li><p>children  获取某个元素下的元素子节点。</p></li></ul></li>
<li><p>祖孙关系</p></li>
<li><p>兄弟关系：</p>

<ul>
<li><p>previousElementSibling上一个兄弟节点</p></li>
<li><p>nextElementSibling 下一个兄弟节点</p></li>
<li><p>没有就是null</p></li></ul></li></ul></li>
<li><p>第一个娃 firstElementChild</p></li>
<li><p>最后一个娃 lastElementChild</p></li>
</ul>



<h3 id="节点整个html中全是节点">节点：整个html中全是节点</h3>

<ul><li><p>标签-&gt;元素节点：数字1</p></li>
<li><p>属性节点：数字2</p></li>
<li><p>文本节点：数字3  文字、换行</p></li>
<li><p>注释节点：数字 8</p></li>
<li><p>document：数字9</p></li>
</ul>



<h4 id="1属性nodetype-值是一个数字">1、属性：nodeType -&gt;值是一个数字</h4>

<ul><li><p>去查看节点类型的</p></li>
</ul>



<h4 id="2childnodes-子节点">2、childNodes  子节点</h4>



<h4 id="3children-子级元素节点不是标准但是所有浏览器都支持">3、children  子级元素节点，不是标准，但是所有浏览器都支持</h4>



<h4 id="4nodevalue-查看节点内容">4、nodeValue  查看节点内容</h4>



<h4 id="5attributes-属性返回指定节点的属性集合即-namednodemap">5、attributes 属性返回指定节点的属性集合，即 NamedNodeMap。</h4>

<blockquote>
  <p>提示：您可以使用 length 属性来确定属性的数量，然后您就能够遍历所有的属性节点并提取您需要的信息。</p>
</blockquote>



<h4 id="6创建一个元素节点">6、创建一个元素节点</h4>

<ul><li><p>document.createElement(‘li’)</p></li>
</ul>



<h4 id="7添加元素">7、添加元素</h4>

<ul><li><p>往元素的末尾添加元素</p>

<ul>
<li><p>parent.appendChild(child);</p></li></ul></li>
<li><p>往元素的首位添加元素</p>

<ul>
<li><p>parent.insertBefore(插入的元素,参照元素);</p></li></ul></li>
</ul>



<h4 id="8删除parentremovechild哪个元素">8、删除:parent.removeChild(哪个元素)</h4>



<h4 id="9clonenodetrue-克隆元素">9、cloneNode(true) 克隆元素</h4>

<ul><li><p>如果添加了true，不但能克隆元素本身，还克隆子级</p>

<blockquote>
  <p>注意：在chrome的73.0.3683.103中多次克隆报错</p>
</blockquote></li>
</ul>



<h3 id="math">Math</h3>

<blockquote>
  <p>Math  是一个内置对象，处理数学问题，比如：四舍五入  取整  随机数等等</p>
</blockquote>

<ul><li><p>Math.round() 四舍五入 <br>
<code>console.log(typeof Math.round) // "function" <br>
Math.round(1.5) // 2</code></p></li>
<li><p>Math.ceil() 向上取整，有小数，整数部分就加1 <br>
<code>Math.ceil(2.1) // 3 <br>
Math.ceil(0.1) // 1</code></p></li>
<li><p>Math.floor  向下取整 <br>
<code>Math.floor(2.1) // 2 <br>
Math.floor(1.9) // 1</code></p></li>
<li><p>Math.abs 返回绝对值 <br>
<code>Math.abs(-1)//1</code></p></li>
<li><p>Math.max() 返回一堆数中最大值 <br>
<code>Math.max(3,4,7,16)//16 <br>
**Math.max不可以直接对数组进行求值** <br>
var arr = [4, 1, 3, 12, 11] <br>
console.log(Math.max(arr))</code></p></li>
<li><p>Math.min() 返回一堆数中最小值 <br>
<code>Math.min(3,4,7,16)//3</code></p></li>
<li><p><strong>ES6 扩展运算符 …对象 将后面的对象展开</strong> ，新开一个地址 <br>
<code>[4, 1, 3, 12, 11] =&gt; 4 1 3 12 11 <br>
console.log(...arr) // 4 1 3 12 11 <br>
console.log(Math.max(4, 1, 3, 12)) <br>
console.log(Math.max(...arr)) // 12</code></p></li>
<li><p>Math.random() 方法返回介于0到1之间一个随机小数，包含0，不包括1（包前不包后） <br>
<code>Math.random() // 0.8458846320507001</code></p>

<ul>
<li><p>获取n-m之间的随机小数 <br>
<code>Math.random()*(m-n)+n</code></p></li>
<li><p>1到10之间 随机小数 <br>
<code>Math.random() * (10 - 1) + 1</code></p></li>
<li><p>获取n到m之间的随机整数 <br>
<code>Math.round(Math.random() * (m - n) + n)</code></p></li>
<li><p>1到10之间 随机整数 <br>
<code>Math.round(Math.random() * (10 - 1) + 1)</code>        </p></li>
<li><p>0到m之间的随机整数  <br>
 <code>Math.round(Math.random() * m)</code></p></li>
<li><p>获取0到10之间的随机整数  <br>
 <code>Math.round(Math.random() * (10 - 0) + 0) <br>
    Math.round(Math.random() * 10) <br>
    Math.round(Math.random() * 100)</code></p></li></ul></li>
<li><p>Math.PI 圆周率 3.1415926</p></li>
</ul>



<h3 id="作用域">作用域</h3>



<h4 id="1全局作用域">1.全局作用域</h4>

<ul><li><p>执行栈，在script标签内第一层js代码</p></li>
<li><p>(1)如果当前script中的全局没有某个变量， <br>
这个时候还会向上面的script中去查找（只会向上找，默认不会向下找）有就输出，否则报错。</p></li>
<li><p>(2)如果有多个script标签，上面的script中的代码报错，是不会影响，下面script标签内的代码执行的。</p></li>
<li><p>(3)全局的this为window</p></li>
<li><p>(4)从作用域链的角度来说，最终会找到widnow下有没有某个属性(var的情况)</p></li>
<li><p>(5)多个script标签如果都用了let，那么同样走let特性(不能有重名变量)</p></li>
<li><p>(6)使用var的时候等同于在widnow下注册了一个属性，并且在没赋值之前为undefined <br>
不过在chrome|FF下 在变量的上方打印window的时候会有属性值结果，要注意的是，显示出来的是骗人的（跟undefined走）</p></li>
<li><p>(7)函数默认也是挂在window身上的</p></li>
<li><p>(8)变量必须加var或者let来声明,不然在变量没赋值之前访问这个变量就报错</p></li>
</ul>



<h4 id="2私有作用域">2.私有作用域</h4>

<ul><li><p>在函数执行栈中运行代码，函数中的变量和参数，会默认处理在函数内部，不会被外界所干扰。</p></li>
<li><p>如果函数内的计算或者逻辑处理需要被外界所接受， 一般使用return。</p></li>
<li><p>防止全局污染（封闭空间,教科书上说它就是闭包，但是，这样不一定是我们眼中的闭包）</p></li>
</ul>



<h4 id="3块级作用域">3.块级作用域</h4>

<ul><li><p>{}</p></li>
<li><p>let、const 识别块级作用域</p></li>
<li><p>var不识别</p></li>
<li><p>要小心function(){}</p></li>
</ul>



<h4 id="4作用域链">4.作用域链</h4>

<ul><li><p>1.当前域没有会去它的上级域查找， <br>
直到window结束，window都没有就报错.</p></li>
<li><p>2.变量提升</p>

<ul>
<li><p>当代码在执行前会把var和function提前进行解析</p></li>
<li><p>并且变量赋值为undefined，函数赋值代码块.</p></li></ul></li>
<li><p>3.执行上下文</p>

<ul>
<li><p>我只看等号赋值</p></li></ul></li>
<li><p>4.如果在函数中，参数赋值比执行上下文要提前(也可以理解为，函数比正常执行多了一个参数赋值)</p></li>
<li><p>5.赋值参数问题</p>

<ul>
<li><p>如果实参是简单类型，函数内再怎么搞都不会影响原值</p></li>
<li><p>如果实参是个引用类型，函数内<em>直接改形参的&amp;&amp;值&amp;&amp;</em>那么会影响原值；</p></li>
<li><p>但是如果在函数内赋值了一个新的对象，那么此时赋值之后再怎么改参数，都不会影响原值</p></li></ul></li>
</ul>



<h3 id="箭头函数">箭头函数</h3>

<ul><li><p>一种函数的简写方式</p>

<ul>
<li><p>1.let fn = () =&gt; {}   没有参数</p></li>
<li><p>2.let fn = (a,b,c) =&gt; {} 多个参数</p></li>
<li><p>3.let fn = a =&gt; {} 一个参数</p></li>
<li><p>4.let fn = a =&gt; a; return a</p></li></ul></li>
<li><p>箭头函数的this，跟它的执行上下文有直接的关系。</p></li>
<li><p>箭头函数的this找老爹。</p></li>
</ul>



<h5 id="arguments-实参的集合">arguments 实参的集合</h5>

<p><code>function fn(){ <br>
    console.log(arguments);//[1,2,3,4,5] <br>
    } <br>
fn(1,2,3,4,5)</code>            </p>

<ul><li><p>箭头函数中没有arguments</p></li>
</ul>



<h3 id="闭包">闭包</h3>

<ul><li><p>函数形成一个不销毁的作用域，这个作用域就叫闭包</p>

<blockquote>
  <p>函数套函数，子函数使用父函数的参数或者变量 <br>
  并且子函数被外界所引用，此时父级形成闭包环境 <br>
  父级的参数或者变量不被浏览器垃圾回收机制回收. <br>
  此时，打印父函数的返回值，有个属性为Scopes <br>
  Scopes下有个closure的属性，closure 就是闭包。</p>
</blockquote></li>
<li><p>作用</p>

<ul>
<li><p>使用闭包可以一直存储父级的参数或者变量 <br>
不被外界的函数或者变量所干扰（污染）</p></li></ul></li>
</ul>



<h2 id="git是个版本控制工具">git：是个版本控制工具</h2>

<ul><li><p>github</p>

<blockquote>
  <p><a href="https://github.com/" target="_blank">https://github.com/</a> <br>
  程序员交友网站、进行代码托管、去加入一些知名项目的开发、自己静态的页面…</p>
</blockquote></li>
</ul>



<h4 id="git-与-github进行关联">git 与 github进行关联</h4>

<ul><li><p>设置秘钥:</p>

<ul>
<li><p>1.进入github</p></li>
<li><p>2.找到你的头像，点击选择settings       </p></li>
<li><p>3.在最左边有SSH and GPG keys</p></li></ul></li>
<li><p>生成秘钥:</p>

<ul>
<li><p><a href="https://blog.csdn.net/lqlqlq007/article/details/78983879" target="_blank">https://blog.csdn.net/lqlqlq007/article/details/78983879</a></p></li></ul></li>
<li><p>点击鼠标右键，选择git Bash here</p></li>
<li><p>输入: ssh-keygen -t rsa -C “这里换上你的邮箱”</p>

<ul>
<li><p>此处无脑回车，会出现方框</p></li>
<li><p>git config –global  user.name “这里换上你的用户名”</p></li>
<li><p>git config –global user.email “这里换上你的邮箱”</p></li>
<li><p>输入: ssh -T git@github.com </p>

<ul>
<li><p>只要出现Hi ….就说明绑定成功</p></li>
<li><p>如果有兴趣，可以自己研究一下hexo搭建自己的博客</p></li></ul></li></ul></li>
</ul>



<h4 id="git版本控制工具新建控制项目">git:版本控制工具–新建控制项目:</h4>

<ul><li><p>1.git init（第一种）</p></li>
<li><p>2.到github网站中新建项目  （推荐使用）</p></li>
<li><p>步骤:                     </p>

<ul>
<li><p>1.点击头像旁边的 +号 选择 New repository</p></li>
<li><p>2.填写项目名称、描述、勾选readme、点击创建按钮</p></li>
<li><p>3.找到clone按钮，点击复制</p></li>
<li><p>4.在你想管理的文件夹下打开git工具，输入git clone 刚才复制的地址 <br>
可以使用ctrl+v, shift+insert,点击鼠标右键,选择粘贴</p></li></ul></li>
<li><p>git status    查看当前你的版本的状态 </p></li>
<li><p>按方向键上  能够出来刚才输入的命令</p></li>
<li><p>按tab键可以自动补全文件</p></li>
</ul>



<h5 id="工作区到存储区">工作区到存储区:</h5>

<ul><li><p>git add 文件名</p></li>
<li><p>如果已经输入过一次add，那么可以使用git add .的方式快速 <br>
把多个文件放到暂存区。</p></li>
</ul>



<h5 id="暂存区到版本区">暂存区到版本区:</h5>

<ul><li><p>git commit -m “注释(这个注释是为了方便用户查找)”</p></li>
</ul>



<h5 id="快速从工作区提交到版本区">快速从工作区提交到版本区</h5>

<ul><li><p>git commit -a -m “注释”</p></li>
</ul>



<h5 id="工作区查看暂存区">工作区查看暂存区:</h5>

<ul><li><p>git diff</p></li>
</ul>



<h5 id="暂存区查看版本区">暂存区查看版本区:</h5>

<ul><li><p>git diff –cached</p></li>
</ul>



<h5 id="工作区查看版本区">工作区查看版本区:</h5>

<ul><li><p>git diff master</p></li>
</ul>



<h5 id="查看版本">查看版本:</h5>

<ul><li><p>git log</p></li>
</ul>



<h5 id="如果要看操作过的版本">如果要看操作过的版本:</h5>

<ul><li><p>git reflog</p></li>
</ul>



<h5 id="还原版本">还原版本:</h5>

<ul><li><p>git reset –hard 版本号</p>

<ul>
<li><p>版本号通过查看版本去找</p></li></ul></li>
<li><p>当代码已经形成版本之后，想把代码提交到远程仓库(github、gitlab、码云…) <br>
可以使用</p></li>
<li><p>git push origin master</p></li>
</ul>



<h5 id="永久免密上传">永久免密上传:</h5>

<ul><li><p>git config –global credential.helper store</p></li>
</ul>



<h3 id="单例模式">单例模式:</h3>

<ul><li><p>单例 — 单独的实例</p></li>
<li><p>实例:把相同的事务总结(归纳、抽象)出来，形成一类事务，把描述事务的属性和方法具体化，这个具体的描述的对象就是实例</p></li>
<li><p>命名冲突:</p>

<ul>
<li><p><strong>1.封闭空间</strong></p>

<blockquote>
  <p>把一段代码放到一个函数内,当执行函数的时候 <br>
  函数内的域和外界是互不干扰的 <br>
  (function(){})()</p>
</blockquote></li>
<li><p><strong>2.命名空间</strong></p>

<blockquote>
  <p>把一些变量或者函数变成某个对象下的属性和方法，对象与对象之间空间地址是不一样的，所以可以解决命名冲突的问题</p>
</blockquote></li></ul></li>
<li><p><strong>单例模式的优势:</strong></p></li>
<li><p>1.解决命名冲突</p></li>
<li><p>2.把相同事务归为了一类，并且把这些属性或者方法，放到了一个堆内存空间中存储。</p></li>
<li><p>3.模块化的开发</p></li>
</ul>



<h5 id="单例模式功能相对单一用来描述具体一个事务">单例模式功能相对单一,用来描述具体一个事务。</h5>

<ul><li><p>让其复杂，那就需要高级单例模式</p>

<ul>
<li><p>使用一个函数自执行函数，这个函数返回一个对象</p></li></ul></li>
<li><p><strong>高级单例模式，可以实现高内聚、低耦合</strong></p></li>
</ul>



<h3 id="工厂模式">工厂模式:</h3>

<ul><li><p>目的是批量生成多个实例,</p></li>
<li><p>通过传参去描述具体的实例,</p></li>
<li><p>把生产后的对象返回到外界使用。</p></li>
</ul>



<h3 id="构造函数">构造函数:</h3>

<blockquote>
  <p>把属性或者方法挂在this上，然后去new这个函数 <br>
  浅规则是构造函数首字母大写。 </p>
</blockquote>

<ul><li><p>new 是一元运算符 -&gt; <strong>专门</strong>运算<strong>函数</strong>的</p></li>
<li><p><strong>new之后发生了什么？</strong></p>

<ul>
<li><p>1.执行函数,不使用()调用也是可以执行函数的，此时的()只是为了传参   </p></li>
<li><p>2.构造函数(fn)中的this指向了当前实例。</p>

<ul>
<li><p>跟普通函数比较把默认的window转成当前实例 <br>
<code>function Fn(){}  构造函数 <br>
fn{}  实例化对象</code>           </p></li></ul></li>
<li><p>3.return 的结果默认指向当前实例this,</p>

<blockquote>
  <p>有return 如果后面跟着的是一个基本类型 <br>
  结果依然是实例,如果后面跟着的是一个引用 <br>
  类型，那么结果就是这个return后的引用类型</p>
</blockquote></li></ul></li>
</ul>



<h4 id="constructor构造函数">constructor：构造函数</h4>

<ul><li><p>实例下的constructor == 实例的构造函数</p>

<ul>
<li><p>但是这个constructor是随时随地随便可以修改的，constructor只能当作实例中指向构造函数的一种参考物，并不能左右实例的构造函数真相。</p></li></ul></li>
<li><p>constructor什么时候会被修改？</p>

<ul>
<li><p>给构造函数的原型赋址对象的时候会变</p></li></ul></li>
<li><p>解决：</p>

<ul>
<li><p>手动修正constructor指向 <br>
   <code>{ <br>
        constructor：构造函数 <br>
    }</code></p></li></ul></li>
</ul>



<h3 id="面向对象编程">面向对象编程:</h3>

<blockquote>
  <p>把描述相同的事务抽象出来，归为一类，把描述这个类的属性和方法挂在这个类的原型(prototype)上的一种编程方式就叫面向对象</p>
  
  <ul><li><p>抽象:抽离出长的相像的部分。</p></li>
  <li><p>js的面向对象有特征: <br>
          抽象 <br>
          封装 <br>
          继承 <br>
          多态</p></li>
  <li><p>类 -&gt; 构造函数 -&gt; 把相同的代码抽离出来归纳在一个函数中</p></li>
  </ul>
  
  </blockquote>


<h4 id="原型">原型：</h4>

<blockquote>
  <p><strong>定义：</strong>原型是函数的一个属性prototype（当声明一个函数的时候自身带有的一个属性，这个属性一般只给它的实例化对象使用）</p>
</blockquote>

<p><code>原型：prototype为 一个函数天生自带的属性，它的值是一个对象 <br>
为了优化性能的，prototype只给它的实例化对象使用 <br>
如果在相同的类中去new多个实例，它们的方法是相等的</code></p>

<ul><li><p>它的用处是如果实例化对象上没有某个属性或者方法，还会去这个实例化对象的构造函数中的原型下去查找，该属性或者方法.</p></li>
<li><p>如果构造函数的原型上没有这个方法，那么还会去原型下的原型链（<strong>proto</strong>）中查找，找到Object.prototype</p></li>
<li><p>构造函数的原型下的方法只给它的实例化对象使用</p></li>
<li><p>以构造函数模式 + 原型模式 = js面向对象模式</p></li>
<li><p><strong>调用原型上的方法</strong></p>

<ul>
<li><p>Fn.prototype.say</p></li>
<li><p>new Fn.say()</p></li></ul></li>
</ul>



<h4 id="原型链-proto">原型链: <strong><em>_proto_</em></strong></h4>

<blockquote>
  <p><strong>定义：</strong>实例身上都有的一个属性<strong><em>_proto_</em></strong>，这个属性指向构造函数的原型； <br>
   <strong>实例化对象上的原型链 === 构造函数的原型</strong>； <br>
   实例对象上没有，就会通过原型链找到构造函数的原型； <br>
   构造函数的原型又是一个对象，如果在这个对象下还没有；还会通过构造函数的原型的原型链进行查找，最后直到找到Oject.prototype为止。</p>
</blockquote>

<ul><li><p><strong>实例上一定有原型链</strong></p></li>
<li><p><strong>实例化对象上的原型链 === 构造函数的原型</strong></p>

<ul>
<li><p>实例化对象.<strong><em>_proto_</em></strong> === 构造函数.prototype</p></li></ul></li>
<li><p><strong>对象上有原型链 -&gt; 指向构造函数的原型</strong></p>

<blockquote>
  <p>1.先看对象自身有没有这个属性或者方法 <br>
  有就不找了 <br>
  没有的话就接着找 <br>
  2.通过对象的原型链找构造函数的原型 <br>
  有就不找了 <br>
  没有的话就接着找 <br>
  3.因为函数的原型是个对象，对象身上有原型链，通过原型链又去找构造函数原型 <br>
  有就不找了 <br>
  没有的话就接着找</p>
</blockquote></li>
<li><p>所以说，函数即是函数，又是对象(它是Function的实例化对象) <br>
    函数即有原型，也有原型链，函数的原型上的属性或者方法只给它的 <br>
    实例化对象使用。</p></li>
</ul>



<h5 id="function的三种形态">function的三种形态</h5>

<ul><li><p><strong>普通函数</strong> <br>
<code>function fn(){}</code></p></li>
<li><p><strong>构造函数</strong>（类）构造对象的函数 得使用new <br>
<code>function Fn(name){ <br>
                this.name = name; <br>
            }</code>                </p></li>
<li><p><strong>实例化对象</strong>  new Function的实例化对象 <br>
<code>let fn = new Function();</code>       </p></li>
</ul>



<h3 id="this的指向">this的指向</h3>

<ul><li><p><strong>window:</strong></p>

<ul>
<li><p>1.直接在全局输出this</p></li>
<li><p>2.函数打印this,并且直接调用</p></li>
<li><p>3.定时器中普通函数this为window</p></li>
<li><p>4.匿名函数自执行</p></li>
<li><p>5.某些回调</p></li></ul></li>
<li><p><strong>事件中的this:</strong></p>

<ul>
<li><p>哪个对象触发，this就是那个对象</p></li>
<li><p>事件中尽量不用箭头函数，按钮会找不到，体验不好</p></li></ul></li>
<li><p><strong>实例:</strong></p>

<ul>
<li><p>new 构造函数 -&gt; this就是实例</p></li></ul></li>
<li><p><strong>箭头函数:</strong></p>

<ul>
<li><p>this就走定义箭头函数的域</p></li>
<li><p>箭头函数不能new，一new就报错</p></li>
<li><p>箭头函数也没有arguments</p></li></ul></li>
<li><p><strong>方法的this就是“.”前面的对象</strong> <br>
<code>arr.fn = function(){ <br>
    console.log(this); <br>
} <br>
arr.fn(); //[1,2,3,4]</code></p></li>
<li><p>在严格模式下为undefined <br>
<code>function fn(){ <br>
    "use strict" <br>
    console.log(this); <br>
} <br>
fn();</code></p></li>
</ul>



<h3 id="修改this指向的方法">修改this指向的方法</h3>

<blockquote>
  <p>一个函数，天生就自带一些属性和方法 <br>
  其中有：</p>
</blockquote>

<ul><li><p>1、<strong>call():</strong></p>

<ul>
<li><p>有无数的参数</p></li>
<li><p>第一个参数：改变this指向（写啥是啥）</p>

<ul>
<li><p>null undefined为window</p></li></ul></li>
<li><p>第二个参数之后：就是实参</p></li></ul></li>
<li><p>2、<strong>apply():</strong></p>

<ul>
<li><p>有2个参数</p></li>
<li><p>第一个参数:改变this指向（写啥是啥）</p>

<ul>
<li><p>null和undefined为window</p></li></ul></li>
<li><p>第二个参数：数组[1,2,3]，数组中放参数</p></li></ul></li>
<li><p>3、<strong>bind():</strong></p>

<ul>
<li><p>有无数个参数</p></li>
<li><p>第一个参数：改变this指向（写啥是啥）</p>

<ul>
<li><p>null和undefined为window</p></li></ul></li>
<li><p>第二个参数之后：就是实参</p>

<blockquote>
  <p>使用bind不能立马执行函数，会返回一个新函数，这个函数 的this是改变了的，得执行这个新函数才能输出代码。</p>
</blockquote></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">        bind(this,无限个参数)  </span>
</div><div class="hljs-line"><span class="hljs-comment">            改变this指向，返回一个函数，函数才会执行</span>
</div><div class="hljs-line"><span class="hljs-comment">        1.改变this</span>
</div><div class="hljs-line"><span class="hljs-comment">        2.传参</span>
</div><div class="hljs-line"><span class="hljs-comment">        3.如果是构造函数的话，this不需要被改变</span>
</div><div class="hljs-line"><span class="hljs-comment">    */</span>    
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a,b,c</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">this</span>.a = a;
</div><div class="hljs-line">       <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);  
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context,...arg</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-comment">//arg为剩余的参数集合为数组</span>
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> that = <span class="hljs-keyword">this</span>;<span class="hljs-comment">//函数实例</span>
</div><div class="hljs-line">        <span class="hljs-comment">//bind返回的函数</span>
</div><div class="hljs-line">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bound</span> (<span class="hljs-params">...arg2</span>)</span>{<span class="hljs-comment">//arg2为bound的所有参数</span>
</div><div class="hljs-line">            <span class="hljs-comment">//bound是不是this的构造函数，如果是，说明new了</span>
</div><div class="hljs-line">            <span class="hljs-comment">//是构造函数this就不能变</span>
</div><div class="hljs-line">            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> bound){
</div><div class="hljs-line">                that.apply(<span class="hljs-keyword">this</span>,[...arg,...arg2]);
</div><div class="hljs-line">            }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">                 <span class="hljs-comment">//让arg和arg2合并</span>
</div><div class="hljs-line">                that.apply(context,[...arg,...arg2]);<span class="hljs-comment">//把数组放到apply的第二个参数上</span>
</div><div class="hljs-line">            }
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">//在new bound的时候，让bound的实例拥有fn原型上的方法</span>
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.prototype){
</div><div class="hljs-line">            bound.prototype = <span class="hljs-keyword">this</span>.prototype;
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">return</span> bound;
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    fn.prototype.aaa = <span class="hljs-number">555</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">// fn.bind = function(){}</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> f = fn.bind(<span class="hljs-built_in">document</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> f().aaa);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">// console.log(new f(3).aaa);</span>
</div><div class="hljs-line">    <span class="hljs-comment">// console.log(f);</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">//第一个需求</span>
</div><div class="hljs-line">    <span class="hljs-comment">// Function.prototype.bind = function(context){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     let that = this;//函数实例</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     //bind返回的函数</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     function bound (){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//         that.apply(context);</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     }</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     return bound;</span>
</div><div class="hljs-line">    <span class="hljs-comment">// }</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">//第二个需求</span>
</div><div class="hljs-line">    <span class="hljs-comment">// Function.prototype.bind = function(context,...arg){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     //arg为剩余的参数集合为数组</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     let that = this;//函数实例</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     //bind返回的函数</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     function bound (...arg2){//arg2为bound的所有参数</span>
</div><div class="hljs-line">    <span class="hljs-comment">//         //让arg和arg2合并</span>
</div><div class="hljs-line">    <span class="hljs-comment">//         that.apply(context,[...arg,...arg2]);//把数组放到apply的第二个参数上</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     }</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     return bound;</span>
</div><div class="hljs-line">    <span class="hljs-comment">// }</span>
</div><div class="hljs-line"><wbr>
</div></code></pre>

<ul><li><p><strong>Object.prototype.toString.call(arr)</strong></p>

<ul>
<li><p>每个数据类型都有自己的toString方法</p></li>
<li><p>每个toString方法都不一样</p></li>
<li><p>正好Object的toString方法能够显示当前的数据类型</p></li></ul></li>
<li><p><strong>类数组转数组的方法:</strong></p>

<ul>
<li><p>Array.prototype.slice.call(arr);</p></li>
<li><p>Array.form(arr);</p></li></ul></li>
<li><p><strong>取数组大小值:</strong></p>

<ul>
<li><p>console.log(Math.max.apply(null,ary));</p></li>
<li><p>console.log(Math.max(…ary))</p></li></ul></li>
</ul>

<p><code>function fn(){ <br>
    console.log(this); <br>
} <br>
fn.call('你的');</code></p>



<h3 id="包装对象">包装对象：</h3>

<blockquote>
  <p>定义：当简单类型去使用某个属性或者方法的时候，内部会偷偷地转成对象（new 内置类）把属性或者方法提供使用者，然后再悄悄的销毁，这个过程就叫包装对象。</p>
</blockquote>

<ul><li><p><strong>只有在引用类型下才能添加属性和方法</strong></p></li>
</ul>



<h3 id="自身属性">自身属性</h3>

<blockquote>
  <p>obj.hasOwnProperty(‘属性名’)</p>
</blockquote>

<ul><li><p>for in不但会枚举本对象，还会枚举原型，此时就好多出来一些莫名其妙的东西，但是我们不想要不是对象身上的东西</p></li>
<li><p>obj.hasOwnProperty(‘属性名’)</p>

<ul>
<li><p>查看某个属性是不是对象自身的</p></li>
<li><p>是就返回true，不是就返回false</p></li></ul></li>
</ul>



<h3 id="json方法">JSON方法</h3>

<ul><li><p>JSON -&gt; [] | {}</p>

<blockquote>
  <p>JSON 只是一种数据格式     ‘{}’  |  ‘[]’</p>
</blockquote>

<ul>
<li><p><strong>JSON.parse()</strong></p>

<ul>
<li><p>能够把json转成对象或者数组</p></li>
<li><p>json必须是一个标准格式的json,不然转不出来</p></li>
<li><p>json中不能放函数、不能为undefined <br>
<code>'{"name":12,"nn":"ds"}'</code></p></li></ul></li>
<li><p><strong>JSON.stringify()</strong></p>

<ul>
<li><p>把对象或者数组转成json</p></li>
<li><p>对象中不能放函数、不能为undefined <br>
<code>JSON.parse(JSON.stringify(arr)); 深拷贝：先把数组或者对象转成字符串，再转成数组或对象，这样就不是同一个地址</code></p></li></ul></li>
<li><p>低版本可以使用<strong>json2.js</strong></p></li>
<li><p><strong>eval</strong> 能够把字符串尽量转成js能执行的代码。 <br>
<code>new Function('','console.log()')</code></p></li></ul></li>
<li><p><strong>请求JSON</strong> <br>
    <code>fetch(url) url-&gt; 文件路径 <br>
    .then(d=&gt;d.text()) <br>
    .then(arr=&gt;{ <br>
        //arr = eval('('+arr+')'); <br>
        console.log(arr); <br>
    })</code></p></li>
</ul>



<h3 id="继承">继承:</h3>

<blockquote>
  <p>子类继承了父类的一些特征，然后自己还有一套自己的特征</p>
</blockquote>

<ul><li><p>为什么要继承：</p>

<ul>
<li><p>就是为了代码能够更好复用，组合起来生成一个新的类别</p></li></ul></li>
<li><p><strong>属性继承：类式继承(构造函数继承)</strong></p>

<ul>
<li><p>把父类看做一个函数，调用这个父类并且通过call去改变this指向，把指向改为子类。</p></li>
<li><p><code>function Child(){ <br>
Parent.call(this) <br>
}</code></p></li>
<li><p>class式 <br>
<code>class Child extends Parent {}</code></p></li></ul></li>
<li><p><strong>方法继承：</strong> </p>

<ul>
<li><p>扩展式继承</p>

<ul>
<li><p>{…父类原型} <br>
<code>child.prototype={...Parent.prototype}</code></p></li></ul></li>
<li><p>拷贝继承                  </p>

<blockquote>
  <p>一、<strong>浅拷贝定义：</strong>一个引用类型赋值的时候，只赋值第一层的简单类型，这样两个空间地址不一样，改变一个空间的属性是不会影响另一个空间地址的属性的; <br>
  把一个对象中的第一层的简单类型赋值给另一个对象</p>
</blockquote>

<ul>
<li><p><strong>child.prototype = Object.assgin(parent.prototype)</strong> <br>
<code>let obj2 = Object.assgin(obj) <br>
let obj2 = {...obj} <br>
for(let attr in obj){ <br>
obj2[attr] = obj[attr]; <br>
}</code></p>

<ul>
<li><p>对象的属性只能有一个，如果写多个，下面的会把上面的覆盖</p></li>
<li><p>Object.assign(对象1,对象2,对象3….)</p></li>
<li><p>从后往前合并，改变第一个对象，第一个对象可以为{} <br>
<code>Child.prototype = Object.assign({},parent.prototype)</code> <br>
<code>console.log(Object.assign({},obj,obj2,obj3));</code> </p></li></ul></li></ul>

<blockquote>
  <p>二、<strong>深拷贝定义：</strong>把一个对象中的第一层有引用类型，那么赋值的时候改变一个会影响另一个（因为赋值的过程还是赋值地址），需要只要发现引用类型就深入到内部去找简单类型，直到对象中的所有属性都是简单类型为止。</p>
</blockquote>

<ul>
<li><p><strong>child.prototype=deepclone (Parent.prototype)深度克隆（深拷贝）</strong> <br>
<code>function deepClone(obj) { <br>
//先声明一个数组，去存克隆出来的内容 <br>
//判断obj是否为数组，是数组就o就为[],否则为{} <br>
let o = obj.push ? [] : {}; <br>
//循环传进来的对象 <br>
for (let attr in obj) { <br>
// for(let i=0;i&lt;arr.length;i++){ <br>
//判断对象中的某个值是否为引用类型 <br>
//如果是，就继续调用deepClone把引用值传到函数中 <br>
if (obj.hasOwnProperty(attr)) { <br>
if (typeof obj[attr] === 'object') { <br>
 o[attr] = deepClone(obj[attr]) <br>
} else { <br>
//如果是简单类型就直接赋值 <br>
 o[attr] = obj[attr]; <br>
} <br>
} <br>
} <br>
return o; <br>
} <br>
let arr2 = deepClone(arr); <br>
console.log(arr2);</code></p></li></ul></li></ul></li>
<li><p><strong>原型继承</strong></p>

<ul>
<li><p>例： <br>
<code>function Ph(){ <br>
Ph.prototype=Fruit.prototype; <br>
Coconut.prototype=new Ph; <br>
}</code></p></li></ul></li>
<li><p><strong>寄生式继承</strong></p>

<ul>
<li><p>child.prototype = Object.create(parent.prototype)</p>

<blockquote>
  <p>必须传入一个对象 <br>
  返回值为一个新的对象，这个对象的原型链指向传入的参数</p>
</blockquote>

<ul>
<li><p>就是把对象中的方法挂在新对象的原型链上，括号中的对象变成了新的对象，而这个对象的原型链指向构造函数的原型；</p></li>
<li><p>这个构造函数是传递进来的那个。 <br>
<code>Coder.prototype=Object.create(Person.prototype);</code> <br>
<code>Coder子类  Person父类</code></p></li></ul></li></ul></li>
</ul>



<h4 id="class继承常用"><strong>class继承</strong>–常用</h4>

<ul><li><p>class (类) 保留字</p></li>
<li><p>let   关键字</p>

<blockquote>
  <p>class是ES6才出来的新语法，优势就是写起来方便；它其实还是之前构造函数的语法糖  <br>
  <code>https://segmentfault.com/a/1190000010159725</code></p>
</blockquote></li>
<li><p>class 类名 {  }</p></li>
<li><p>使用constructor去接收参数 <br>
<code>constructor(a,b){ super下面才能写this，不然就报错,super括号中传入父类使用的参数}</code></p></li>
<li><p>class Cat extends Animal 继承用<strong>extends </strong></p></li>
<li><p>写方法: 直接在类中</p>

<ul>
<li><p>方法名 () {  }</p></li></ul></li>
<li><p>设置静态方法</p>

<ul>
<li><p><code>static shui(){  }</code></p></li></ul></li>
</ul>



<h4 id="三点">三点…</h4>

<p><strong>… </strong></p>

<ul><li><p>1.扩展运算符 <br>
<code>let arr = [1,2,3,4]; <br>
console.log(...arr); <br>
function fn(){ <br>
console.log(arguments); //...[] <br>
function f(a,b){ <br>
console.log(a,b); <br>
} <br>
f(...arguments); <br>
} <br>
fn(1,2);</code></p></li>
<li><p>2.剩余运算符 <br>
<code>...c 是个数组 <br>
function fn(a,...c){ <br>
console.log(a,c); <br>
} <br>
fn(1,2,3,4,5);</code></p>

<ul>
<li><p>扩展运算符和剩余运算符的应用 <br>
<code>class Person { <br>
constructor(name,age) { <br>
    this.name = name; <br>
    this.age = age; <br>
} <br>
} <br>
class Women extends Person { <br>
constructor(fs,...arg) {  //剩余运算符 <br>
    super(...arg);   //扩展运算符 <br>
    console.log(arg) <br>
    this.sex = '女'; <br>
    this.fushi = fs; <br>
} <br>
} <br>
let w = new Women('爱穿裙子','马骅骏',18); <br>
console.log(w);</code></p></li></ul></li>
</ul>



<h3 id="正则">正则</h3>

<ul><li><p><strong>正则(对象)：</strong></p>

<blockquote>
  <p><strong>概念：专门用来检索（检查、搜索）模糊范围字符串的一种规则。</strong> <br>
  特征： <br>
  懒惰性：\d 让它找一个一定不会找第二个 <br>
  贪婪性：\d+ 有多少就尽量匹配多少</p>
</blockquote></li>
<li><p><strong>字面量–//</strong>：<strong>/ 不带引号的字符串 /</strong> -&gt; /a/ 找字符串’a’</p></li>
<li><p><strong>实例化</strong>：<strong>new RegExp(‘字符串’,’修饰符’)</strong>，里面可以放变量，返回的是正则    </p>

<ul>
<li><p><code>例：new RegExp('\\b'+ sCLASS +'\\b'); // \b是边界符，前面再加\是转义</code></p></li></ul></li>
<li><p><strong>正则的方法：</strong></p>

<ul>
<li><p><strong>exec[Ig’zek]：/规则/.exec(字符串)</strong>，找到正则中第一个匹配的字符，并且放到数组中。</p>

<ul>
<li><p>捕获一项</p></li>
<li><p>[字符、index、input、groups]</p></li></ul></li>
<li><p><strong>test[test]：/规则/.test(字符串)</strong></p>

<ul>
<li><p>检测正则中的规则是否匹配字符串，成立就返回true，否则false</p></li></ul></li></ul></li>
<li><p><strong>字符串用正则的方法：</strong></p>

<ul>
<li><p><strong>string.match(/正则/)  捕获一项或多项</strong> </p>

<ul>
<li><p>找到正则中所有匹配的字符且放到数组中。</p></li>
<li><p>没匹配到就是null <br>
<code>let str = 'x1j89321Xeu218nX2d32'; <br>
//全局查找整个字符串，把为数字的存在数组中 <br>
console.log(str.match(/\d/g)); <br>
// 全局查找整个字符串，把一个数字或者连续多个数字的存在数组中 <br>
console.log(str.match(/\d+/g));</code></p></li></ul></li>
<li><p><strong>string.replace(要替换的字符串 || /正则/，替换成什么 || 函数);</strong></p>

<ul>
<li><p>当第二个参数为函数的时候</p></li>
<li><p>默认情况:</p>

<ul>
<li><p>函数的第一个参数就是每次匹配到的结果；</p></li>
<li><p>函数的第二个参数是index，也就是索引</p></li>
<li><p>函数的第三个参数input，也就是所有项</p></li>
<li><p>函数的第四个(及以后)参数都是undefined  </p></li></ul></li>
<li><p>此函数必须要有return，不然就是undefined</p></li>
<li><p>返回为新的字符串</p></li></ul></li></ul></li>
<li><p><strong>修饰符：</strong></p>

<ul>
<li><p><strong>g</strong> -&gt; global  全局</p></li>
<li><p><strong>i</strong> -&gt; ignore case 忽略大小写</p></li>
<li><p><strong>m</strong> -&gt; 多行匹配     </p></li></ul></li>
<li><p><strong>量词 </strong>： <strong>+</strong> 最少1个最多无限</p></li>
<li><p><strong>“.” -&gt; 任意一个字符，除回车(\r)</strong></p></li>
<li><p><strong>“ \”  转义符：需要注意的是在写 “ \” 记得转义，在字符串中需要转义</strong></p></li>
<li><p><strong>元字符：</strong></p>

<blockquote>
  <p>当 “ \ + 字母 ” 的时候会有特殊含义，这种带有特殊含义的，我们叫<strong>元字符</strong>。</p>
</blockquote>

<ul>
<li><p><strong>\n 换行</strong></p></li>
<li><p><strong>\r  回车</strong><code>“\r\n 回车并换行”</code></p></li>
<li><p><strong>\d  一个数字</strong></p></li>
<li><p><strong>\D 一个非数字(不是数字)</strong></p></li>
<li><p><strong>\s  一个空格</strong></p></li>
<li><p><strong>\S 一个非空格</strong></p></li>
<li><p><strong>\w 一个数字、字母、下划线</strong></p></li>
<li><p><strong>\W 一个非数字、字母、下划线</strong></p></li>
<li><p><strong>\b 一个边界符</strong></p></li>
<li><p><strong>\B 一个非边界符</strong></p></li></ul></li>
<li><p><strong>“ | ”或者</strong></p></li>
<li><p><strong>( )小括号</strong></p>

<ul>
<li><p>1.<strong>( ) 提权</strong> (1+1)*1</p></li>
<li><p>2.<strong>( ) 子项</strong>： 能够在一个规则中提取某些(指定)字符</p>

<blockquote>
  <p>子项如果包了一个规则，在规则之后有量词，那么结果为最后一个</p>
  
  <ul>
  <li><p>比如： <br>
  <code>let str='2019' <br>
  (\d)+ -&gt;  找到的数字不是2是9</code>    </p></li></ul>
</blockquote>

<ul>
<li><p>子项的顺序是从左往右数的，每有一个()就是一个子项</p></li>
<li><p>子项的个数代表着形参的个数(从第二个开始计算)</p></li>
<li><p>从第二个参数起子项与形参一一对应 <br>
<code>let str = '2019----4/-/-/-//26';  //2019年4月26日 <br>
let s = str.replace(/(\d+)\D+(\d+)\D+(\d+)/,function(<span class="mathjax-replacement" rel="d9f29a7376b88cf1b46c705218a662dd">$0,$</span>1,<span class="mathjax-replacement" rel="bcfac7709c36a0b8e2bde3f6ecb3adf7">$2,$</span>3){ <br>
    // console.log($3);  <br>
    return <span class="mathjax-replacement" rel="1e67a8c07c6aed8552f89666fb41bf78">$1 + '年' + $</span>2 + '月' + $3 + '日'; <br>
}); <br>
console.log(s);</code></p></li></ul></li></ul></li>
<li><p><strong>子项重复项：</strong></p>

<blockquote>
  <ul>
  <li><p>比如：<code>/(d1)c1(b1)\1\2/</code> <br>
  当前有2个子项，一个是d1另一个是b1 <br>
  \1就代表第一个子项，\2就代表第二个子项</p></li></ul>
</blockquote>

<p><code>let str = '437826357384623537463363726573384633278467382'; <br>
let min = -Infinity; <br>
    let i; <br>
    //把字符串变成有序的 <br>
    str = str.split('').sort().join(''); <br>
    // console.log(str); <br>
  //比较大小  <span class="mathjax-replacement" rel="8bdff0fe99d7c72fc90529f31f79cf4b">$0就是当前匹配的 , $</span>1 子项 <br>
  str.replace(/(\d)\1+/g,(<span class="mathjax-replacement" rel="d9f29a7376b88cf1b46c705218a662dd">$0,$</span>1)=&gt;{ <br>
      if(min &lt; $0.length){ <br>
          min = $0.length;//求出多少次 <br>
          i = $1;// 它是谁 <br>
      } <br>
  }); <br>
console.log(min,i);</code></p></li>
<li><p>解题思路：</p>

<blockquote>
  <p>比如：[].push()  <br>
  这个方法是什么 （Array的方法） <br>
  有什么用，（用来向数组的最后一为添加一个或者多个数据） <br>
  参数传的是什么(至少是一个数据，也可以是多个数据) <br>
  返回值是什么(新数组的长度)</p>
</blockquote></li>
<li><p><strong>[ ] 中括号 </strong>：例：[ab]要么是a，要么是b</p>

<ul>
<li><p>在中括号中任意选择一个字符</p>

<ul>
<li><p>比如:[12345] 可以为1也可以为2也可以为3…</p></li>
<li><p>也可以简写为[1-5],因为 - 是1到5的意思</p></li></ul></li>
<li><p>为什么能那么写呢？</p>

<ul>
<li><p>因为顺序是按照unicode编码来的</p>

<ul>
<li><p><strong>数字是：[0-9]</strong></p></li>
<li><p><strong>小写英文：[a-z]</strong></p></li>
<li><p><strong>大写英文：[A-Z]</strong></p></li>
<li><p><strong>从大A到小z： [A-Za-z]</strong></p></li>
<li><p><strong>中文区间范围 ：[\u4e00-\u9fa5]</strong>  <br>
<code>let str = 'hello!~张欢,您老贵庚?'; //21 <br>
let num = 0; <br>
for(let i=0;i&lt;str.length;i++){ <br>
if(/[\u4e00-\u9fa5]/.test(str[i])){ <br>
num += 2; <br>
}else{ <br>
num ++ <br>
} <br>
} <br>
console.log(num);</code></p></li></ul></li></ul></li></ul></li>
<li><p><strong>^ 开头、非</strong></p>

<ul>
<li><p>开头：<code>/^\d/</code></p></li>
<li><p>排除：<code>[^3465] 排除3465</code></p></li></ul></li>
<li><p><strong>$ 结尾</strong> <br>
<code>let str = '180'; <br>
str.match(/^1[89]$/)</code></p>

<blockquote>
  <p>意义：<strong>整段字符串</strong>是否都满足正则的规则，而不是字符串中有一段匹配正则的规则就返回</p>
</blockquote></li>
<li><p><strong>{ } 范围</strong></p>

<ul>
<li><p><strong>{n,m}：最小n次，最大m次</strong></p></li>
<li><p><strong>{n}：最大是n，最小也是n</strong></p></li>
<li><p><strong>+ -&gt; {1,}：最小一次，最多无限</strong></p></li>
<li><p><strong>？ -&gt; {0,1}：最小0次，最多1次</strong></p></li>
<li><p><strong>“ * ” -&gt; {0, }：最小0次，最多无限次</strong> <br>
<code>1、qq:首字母不能是0，全部都要是数字，最小5位,最多11位  -&gt;    /^[1-9]\d{4,10}$/</code> <br>
<code>2、手机号:1[3456789]\d{9}</code></p></li></ul></li>
</ul>



<h3 id="盒子模型">盒子模型</h3>



<h4 id="计算后的样式">计算后的样式：</h4>

<ul><li><p><strong>getComputedStyle(element).属性</strong></p>

<ul>
<li><p>获取到的结果为<strong>带单位</strong>的字符串，比如:100px</p></li></ul></li>
</ul>



<h4 id="获取宽高尺寸">获取宽高尺寸：</h4>

<ul><li><p><strong>ele.clientWidth/ele.clientHeight</strong></p>

<ul>
<li><p>支持padding，不包含边框</p></li>
<li><p>元素可视区宽度 ，不带单位的数字</p></li>
<li><p>如果设置一个固定值，就以固定值为依据显示，不会以被内容撑开显示</p></li></ul></li>
<li><p><strong>ele.offsetWidth/ele.offsetHeight</strong></p>

<ul>
<li><p>支持padding，也包含边框，不带单位的数字</p></li>
<li><p>如果设置一个固定值，就以固定值为依据显示，不会以被内容撑开显示</p></li></ul></li>
<li><p><strong>ele.scrollHeight/ele.scrollWidth</strong></p>

<ul>
<li><p>被内容撑开的高度（不包含边框）</p></li>
<li><p>不管设不设置固定样式，都以被内容撑开为显示结果。</p></li></ul></li>
</ul>



<h4 id="可视区的宽高">可视区的宽高</h4>

<ul><li><p><strong>document.documentElement.clientWidth/document.documentElement.clientHeight</strong>  </p>

<ul>
<li><p>不包含滚动条</p></li></ul></li>
<li><p><strong>window.innerWidth/window.innerHeight</strong> （BOM）</p>

<ul>
<li><p>包含滚动条</p>

<blockquote>
  <p>注意: <br>
  window.innerWidth||window.innerHeight如果有滚动条，是忽略了滚动条的尺寸的  1280 <br>
  document.body.clientWidth(浏览器的尺寸,排除滚动条的) ，使用的时候把默认样式清除  1263</p>
</blockquote></li></ul></li>
</ul>



<h4 id="绝对位置当前元素到页面顶端的位置">绝对位置：当前元素到页面顶端的位置。</h4>

<ul><li><p><strong>offsetParent  定位父级，没有就按照body走</strong></p></li>
<li><p><strong>offsetLeft/offsetTop  当前元素的左|上外边框到定位父级的左|上的内边框的距离</strong></p>

<blockquote>
  <p>如果要使用offsetLeft/offsetTop的属性，一定要做到以下几点: <br>
  1.子级有绝对定位 <br>
   2.定位父级也一定要有定位 <br>
  3.子级和父级都要有宽高（触发haslayout，zoom:1）</p>
</blockquote></li>
<li><p><strong>getBoundingClientRect( )top/left( )  当前元素到页面可视区的尺寸、距离</strong></p>

<ul>
<li><p>width/height/left/right/top/bottom/x/y</p></li>
<li><p><strong>注意：是跟滚动条走的。</strong></p></li></ul></li>
<li><p><strong>clientLeft/clientTop  边框尺寸</strong></p>

<ul>
<li><p>获得绝对位置： <br>
<code>let obj = div1; <br>
let ot = obj.clientTop <br>
let t = 0; <br>
while(obj){ <br>
t += obj.offsetTop + obj.clientTop; <br>
obj = obj.offsetParent; <br>
} <br>
t - ot</code></p></li></ul></li>
</ul>



<h3 id="bombrowser-object-model-浏览器对象模型">BOM:Browser Object Model  浏览器对象模型</h3>



<h4 id="滚动距离">滚动距离</h4>

<ul><li><p><strong>window.pageYOffset/window.pageXOffset</strong></p>

<ul>
<li><p>滚动条的距离，只能读不能写</p></li></ul></li>
<li><p><strong>window.scrollTo(x,y) </strong></p>

<ul>
<li><p>专门用来写滚动条距离的，只写</p></li></ul></li>
<li><p><strong>document.documentElement.scrollTop/document.documentElement.scrollLeft</strong></p>

<ul>
<li><p>滚动条的距离，既能读也能写(document.documentElement=HTML)</p></li></ul></li>
<li><p>打开新的窗口</p>

<ul>
<li><p><strong>window.open(url,用什么方式打开_blank,_self)</strong></p>

<blockquote>
  <p>注意：需要用户主动触发才不会被拦截 <br>
  <code>比如： window.open('http://www.baidu.com')</code></p>
</blockquote></li></ul></li>
<li><p>关闭浏览器窗口，最好也是用户主动触发体验才好</p>

<ul>
<li><p><strong>window.close( );</strong></p></li></ul></li>
<li><p><strong>window.onresize  缩放浏览器的时候触发的事件</strong></p></li>
<li><p><strong>window.onscroll  有滚动条的时候滚轮时触发</strong></p></li>
<li><p><strong>window.navigator.userAgent  查看用户的浏览器内核信息</strong></p>

<ul>
<li><p>注意：使用的时候判断的字符串有可能会被模拟。</p></li>
<li><p>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36</p></li>
<li><p>操作系统的版本，位数</p></li></ul></li>
</ul>



<h4 id="浏览器地址信息">浏览器地址信息</h4>

<ul><li><p><strong>window.location.hash</strong> 即能读也能写 –<strong>重点</strong></p>

<ul>
<li><p><strong>hash: “”</strong>  浏览器hash信息 (#及之后的信息)，更换这个信息是不会刷新页面的 </p></li></ul></li>
<li><p><strong>host: “”</strong>  ip地址 + 端口号</p></li>
<li><p><strong>hostname: “”</strong> ip地址</p></li>
<li><p><strong>href: “”</strong>  url地址 –<strong>重点</strong></p>

<ul>
<li><p><strong>window.location.href   在当前页面中跳转页面</strong></p></li></ul></li>
<li><p><strong>origin: “file://”</strong></p></li>
<li><p><strong>port: “”</strong> 端口 –<strong>重点</strong></p></li>
<li><p><strong>protocol: “file:”</strong>  协议 –<strong>重点</strong></p></li>
<li><p><strong>reload: ƒ reload()</strong>   刷新页面 –<strong>重点</strong></p></li>
<li><p><strong>replace: ƒ ()</strong> 替换页面</p></li>
<li><p><strong>search: “”</strong>  查询信息  –<strong>重点</strong></p>

<ul>
<li><p>window.location.search –<strong>重点</strong></p></li>
<li><p>?到#号之间的信息</p></li>
<li><p>即可读也可写，只不过写的时候会刷新页面 <br>
<code>http://www.zhufengpeixun.cn?num=1#page=0</code></p></li></ul></li>
<li><p><strong>window.onhashchange</strong>   当hash值发生变化的时候就触发 <br>
<code>window.onhashchange = function(){ <br>
    alert('触发'); <br>
}</code></p></li>
<li><p><strong>window.location.reload( )</strong>  刷新页面  –<strong>重点</strong></p></li>
</ul>



<h4 id="延迟加载">延迟加载</h4>

<ul><li><p>延迟加载的原理：</p>

<ul>
<li><p>可视区的高度 + 滚动条的高度如果大于等于图片的绝对位置，就加载把图片的src赋值。</p></li></ul></li>
<li><p>防抖：高频率不触发，停下来才触发</p></li>
<li><p>节流：每隔一段时间触发                </p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">//工具中的绝对位置</span>
</div><div class="hljs-line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tools</span> </span>{
</div><div class="hljs-line">po(ele){
</div><div class="hljs-line"><span class="hljs-keyword">let</span> obj = ele,
</div><div class="hljs-line">top = <span class="hljs-number">0</span>,left = <span class="hljs-number">0</span>;
</div><div class="hljs-line"><span class="hljs-keyword">while</span>(obj){
</div><div class="hljs-line"> top += obj.offsetTop;
</div><div class="hljs-line"> left += obj.offsetLeft;
</div><div class="hljs-line"> obj = obj.offsetParent;
</div><div class="hljs-line">}
</div><div class="hljs-line">top -= ele.clientTop;
</div><div class="hljs-line">left -= ele.clientLeft;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">//new Tools().po(ele).l</span>
</div><div class="hljs-line"><span class="hljs-keyword">return</span> {
</div><div class="hljs-line"> top,
</div><div class="hljs-line"> left
</div><div class="hljs-line">}
</div><div class="hljs-line">}
</div><div class="hljs-line">}
</div><div class="hljs-line"><span class="hljs-comment">//实例化Tools</span>
</div><div class="hljs-line"><span class="hljs-keyword">let</span> t = <span class="hljs-keyword">new</span> Tools();
</div><div class="hljs-line"><span class="hljs-comment">//可视区的高度</span>
</div><div class="hljs-line"><span class="hljs-keyword">let</span> winH = <span class="hljs-built_in">window</span>.innerHeight;
</div><div class="hljs-line"><span class="hljs-comment">//获取页面中所有li和img</span>
</div><div class="hljs-line"><span class="hljs-keyword">let</span> lis = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'li'</span>);
</div><div class="hljs-line"><span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'img'</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">scrollPic();
</div><div class="hljs-line"><span class="hljs-comment">//当滚轮的时候触发</span>
</div><div class="hljs-line"><span class="hljs-built_in">window</span>.onscroll = scrollPic;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scrollPic</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line"><span class="hljs-comment">//滚轮事件</span>
</div><div class="hljs-line"><span class="hljs-comment">//拿到滚动条的距离</span>
</div><div class="hljs-line"><span class="hljs-keyword">let</span> scrollT = <span class="hljs-built_in">window</span>.pageYOffset;
</div><div class="hljs-line"><span class="hljs-comment">//循环每个li。</span>
</div><div class="hljs-line"><span class="hljs-comment">//看一看滚动条的距离 + 可视区的高度</span>
</div><div class="hljs-line"><span class="hljs-comment">//是否大于等于每个li的绝对Top位置</span>
</div><div class="hljs-line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;lis.length;i++){
</div><div class="hljs-line"><span class="hljs-keyword">if</span>(scrollT + winH &gt;= t.po(lis[i]).top){
</div><div class="hljs-line"> <span class="hljs-comment">//如果是那么就把图片的pic中的路径取出来</span>
</div><div class="hljs-line"> <span class="hljs-comment">//赋值给img的src</span>
</div><div class="hljs-line"> <span class="hljs-keyword">if</span>(!img[i].src){
</div><div class="hljs-line">     <span class="hljs-comment">// console.log(i);</span>
</div><div class="hljs-line">     <span class="hljs-comment">//oimg就是背锅侠，就为了试试图片是否正常</span>
</div><div class="hljs-line">     <span class="hljs-keyword">let</span> oimg = <span class="hljs-keyword">new</span> Image;
</div><div class="hljs-line">     oimg.src = img[i].getAttribute(<span class="hljs-string">'pic'</span>);
</div><div class="hljs-line">     oimg.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">         img[i].src = img[i].getAttribute(<span class="hljs-string">'pic'</span>);
</div><div class="hljs-line">         <span class="hljs-comment">//删除pic</span>
</div><div class="hljs-line">         img[i].removeAttribute(<span class="hljs-string">'pic'</span>);
</div><div class="hljs-line">         <span class="hljs-comment">//异步队列</span>
</div><div class="hljs-line">         setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
</div><div class="hljs-line">             img[i].style.opacity = <span class="hljs-number">1</span>;
</div><div class="hljs-line">         });
</div><div class="hljs-line">     }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">     oimg.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">         img[i].src = <span class="hljs-string">'./img/timg.jpg'</span>;
</div><div class="hljs-line">         <span class="hljs-comment">//删除pic</span>
</div><div class="hljs-line">         img[i].removeAttribute(<span class="hljs-string">'pic'</span>);
</div><div class="hljs-line">         <span class="hljs-comment">//异步队列</span>
</div><div class="hljs-line">         setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
</div><div class="hljs-line">             img[i].style.opacity = <span class="hljs-number">1</span>;
</div><div class="hljs-line">         });
</div><div class="hljs-line">     }
</div><div class="hljs-line"> }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">}
</div><div class="hljs-line">}
</div><div class="hljs-line"><span class="hljs-comment">// console.log(scrollT + winH,t.po(lis[6]).top);</span>
</div><div class="hljs-line">}
</div></code></pre>



<h4 id="替换图片">替换图片</h4>

<ul><li><p><strong>onload  图片加载成功的时候触发</strong></p></li>
<li><p><strong>onerror 图片加载失败的时候触发</strong></p>

<blockquote>
  <p>如果发现某张图是坏图，那么在onerror中重新赋值一个好的(预备)图片即可</p>
</blockquote></li>
</ul>

<p><code>let timg = new Image; <br>
 timg.src = './img/1.jpg'; <br>
 timg.onload = function(){ <br>
     // alert('好图'); <br>
     img.src = './img/1.jpg'; <br>
 } <br>
 timg.onerror = function(){ <br>
     // alert('坏'); <br>
     img.src = './img/timg.jpg'; <br>
 }</code></p>



<h3 id="修改class">修改class</h3>

<ul><li><p>元素身上有个classList对象</p>

<ul>
<li><p><strong>add(类名,…)  添加类名</strong></p>

<ul>
<li><p>在元素中添加一个或多个类名。</p></li>
<li><p>如果指定的类名已存在，则不会添加</p></li></ul></li>
<li><p><strong>remove(类名) 移除类名</strong>。</p>

<ul>
<li><p>移除元素中一个或多个类名。</p></li>
<li><p>注意： 移除不存在的类名，不会报错。</p></li></ul></li>
<li><p><strong>replace(替换谁，替换成什么)  替换</strong></p></li>
<li><p><strong>contains(类名)  判断指定的类名是否存在</strong></p>

<ul>
<li><p>返回布尔值</p></li>
<li><p>true - 元素已经包含了该类名</p></li>
<li><p>false - 元素中不存在该类名</p></li></ul></li>
<li><p><strong>toggle(类名, true|false)   在元素中切换类名</strong>。  </p>

<ul>
<li><p>返回值是布尔值</p></li>
<li><p>第一个参数为要在元素中移除的类名，并返回 false。 </p></li>
<li><p>如果该类名不存在则会在元素中添加类名，并返回 true。</p></li>
<li><p>第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存在。</p>

<ul>
<li><p>移除一个 class: element.classList.toggle(“classToRemove”, false); </p></li>
<li><p>添加一个 class: element.classList.toggle(“classToAdd”, true);</p>

<blockquote>
  <p>注意： Internet Explorer 或 Opera 12 及其更早版本不支持第二个参数。</p>
</blockquote></li></ul></li></ul></li></ul></li>
</ul>

<p><code>document.onclick = function(){ <br>
        // addClass(box,'red'); <br>
        // box.classList.add('red'); <br>
        // box.classList.replace('bg','red'); <br>
        // console.log(box.classList.contains('bg')) <br>
        console.log(box.classList.toggle('bg')); <br>
        console.log(box.classList); <br>
    } <br>
    function addClass(obj,cname){ <br>
        let cn = obj.className; <br>
        if(!cn.split(' ').includes(cname)){ <br>
            cn += ' red'; <br>
            obj.className =  cn; <br>
        }; <br>
    }</code></p>



<h3 id="运动函数-tween">运动函数   Tween</h3>

<ul><li><p>ActionScript  -&gt; AS</p></li>
</ul>



<h4 id="速度版运动">速度版运动</h4>



<h4 id="时间版运动">时间版运动</h4>

<ul><li><p>t : time 已过时间</p></li>
<li><p>b : begin 起始值</p></li>
<li><p>c : count 总的运动值</p></li>
<li><p>d : duration 持续时间</p></li>
</ul>



<h5 id="动画帧">动画帧:</h5>

<ul><li><p><strong>requestAnimationFrame(函数)   动画帧</strong></p>

<ul>
<li><p>返回值为number（编号）</p></li></ul></li>
<li><p><strong>cancelAnimationFrame(编号)  关闭动画帧</strong></p></li>
<li><p>匀速运动:</p>

<ul>
<li><p>b + c * (t/d)  </p></li></ul></li>
</ul>



<h4 id="回调函数">回调函数</h4>

<blockquote>
  <p>回调（ 钩子函数 ） -&gt; 在做某件事情(某个条件成立)的时候调用函数</p>
</blockquote>

<ul><li><p>点击 onclick</p>

<ul>
<li><p>在按下的时候 + 抬起的时候 = 点击</p></li></ul></li>
<li><p>onmousedown -&gt; 鼠标按下</p></li>
<li><p>onmouseup -&gt; 鼠标抬起</p></li>
</ul>



<h3 id="事件">事件</h3>

<blockquote>
  <p>1、每个元素天生都有很多属性、方法及事件，如果没有事件函数，赋值此时事件的默认值为null <br>
  2、如果有系统内置的事件默认值为null，自定义的事件为undefined <br>
  3、当用户操作浏览器的时候，用户被当做被监听者，浏览器一直监听者用户的操作，会触发若干个事件，如果某个事件上有事件函数，那么就被执行</p>
</blockquote>

<ul><li><p><strong>DOM0级事件</strong></p>

<ul>
<li><p>on事件 + 事件函数为原始的事件绑定方式</p></li>
<li><p>解除事件将某个元素的事件赋值为null</p>

<ul>
<li><p>ele.事件 = null </p></li></ul></li></ul></li>
<li><p>1级DOM–(为什么没有1级DOM)</p>

<ul>
<li><p>DOM级别1于1998年10月1日成为W3C推荐标准。1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型 </p></li></ul></li>
<li><p><strong>DOM2级事件</strong></p>

<ul>
<li><p>事件绑定:</p>

<ul>
<li><p><strong>ele.addEventListener(‘不带on的事件名’,函数,是否捕获)</strong></p></li></ul></li>
<li><p>事件解除:(重要的是解除绑定)</p>

<ul>
<li><p><strong>ele.removeEventListener(‘不带on的事件名’,有名函数(和绑定函数一个地址),是否捕获)</strong> <br>
<code>btn.addEventListener('click',c.bind(this)); <br>
function c(){ <br>
alert(1); <br>
//绑定和解除绑定不是同一地址，所以解除不了 <br>
btn.removeEventListener('click',c); <br>
}</code></p></li></ul></li></ul></li>
<li><p><strong>onclick  点击</strong></p></li>
<li><p><strong>ondblclick  鼠标双击事件</strong></p></li>
<li><p><strong>onmouseover  移入</strong></p></li>
<li><p><strong>onmouseout  移出</strong></p></li>
<li><p><strong>onmousedown  鼠标按下</strong></p></li>
<li><p><strong>onmouseup  鼠标抬起</strong></p></li>
<li><p><strong>onscroll 有滚动条的时候滚轮时触发</strong></p></li>
<li><p><strong>onload  加载完后</strong></p></li>
<li><p><strong>onerror  异常加载</strong></p></li>
<li><p><strong>onhashchange  当hash值发生变化的时候就触发</strong></p></li>
<li><p><strong>onresize  缩放浏览器的时候触发的事件</strong></p></li>
</ul>



<h4 id="事件模型">事件模型</h4>

<ul><li><p>从捕获阶段 到 目标阶段 再到 冒泡阶段 的过程称为<strong>事件流</strong>。</p>

<ul>
<li><p>先执行捕获再执行冒泡</p></li>
<li><p>如果事件绑定的是目标元素，那么是按照绑定事件函数的先后顺序来依次执行（跟捕获冒泡没关系）</p></li></ul></li>
<li><p>从window 到 目标点的阶段叫<strong>捕获阶段</strong>。</p>

<ul>
<li><p>在捕获的过程中，如果上级和下级(祖先级关系)绑定同一事件函数；那么先触发上级的在触发下级的</p></li>
<li><p>DOM0捕获不到捕获阶段，只有冒泡阶段。 <br>
<code>box1.addEventListener(不带on的事件名,function(){ <br>
    alert('red'); <br>
},是否捕获); <br>
捕获就为: true <br>
冒泡就为:false  （默认）</code></p></li></ul></li>
<li><p>从目标点由下而上 直到window 叫做<strong>冒泡阶段</strong> 。</p>

<ul>
<li><p>在这个过程中，如果上级和下级同理有祖先关系，绑定同一事件函数 先触发目标 再触发目标的上级，这整个过程叫做<strong>事件流 事件模型</strong></p></li></ul></li>
<li><p>祖先级关系 是套个多层 </p></li>
</ul>



<h4 id="冒泡的坏处阻止冒泡">冒泡的坏处–阻止冒泡</h4>

<ul><li><p>事件函数中的第一个参数，默认为<strong>事件对象</strong></p></li>
<li><p><strong>事件对象:</strong></p>

<ul>
<li><p>当用户触发某个事件的时候，记录用户操作页面的一些细节信息</p></li></ul></li>
<li><p><strong>阻止冒泡</strong>：(目的是为了不让自己冒泡触发祖先级的同一事件)</p>

<ul>
<li><p>ev.cancelBubble = true;  它不是一个标准，但是所有浏览器都支持</p></li>
<li><p>ev.stopPropagation(); 它是标准，但是在低版本IE下是不兼容的</p></li></ul></li>
<li><p>chrome/IE</p>

<ul>
<li><p>window中都有一个event</p></li></ul></li>
<li><p>FF中是没有event对象的  <br>
<code>let onoff = true; <br>
btn.onclick = function(ev){ <br>
    if(onoff){ <br>
        box.style.display = 'block'; <br>
        btn.innerHTML = '隐藏' <br>
    }else{ <br>
        box.style.display = 'none'; <br>
        btn.innerHTML = '打开' <br>
    } <br>
    onoff = !onoff; <br>
    // alert(1); <br>
    // ev.cancelBubble = true; <br>
    ev.stopPropagation(); <br>
    // console.log(ev) <br>
} <br>
document.onclick = function(){ <br>
box.style.display = 'none'; <br>
onoff = true; <br>
btn.innerHTML = '打开' <br>
}</code></p></li>
</ul>



<h4 id="冒泡的好处事件委托">冒泡的好处–事件委托</h4>

<ul><li><p><strong>ev.target  目标点(事件源)</strong></p>

<ul>
<li><p>在嵌套关系中，给上层元素绑定事件，可以通过事件源查到事件触发的对象(元素)</p></li></ul></li>
<li><p><strong>tagName 查看标签名  注意：大写</strong></p></li>
<li><p>jq中有个delegate原理就是事件委托。 <br>
<code>ul.onclick = function(ev){ <br>
// console.log(ev.target) <br>
if(ev.target.tagName === 'LI'){ <br>
   console.log(ev.target.parentNode.children) <br>
   let lis = ev.target.parentNode.children; <br>
   for(let i=0;i&lt;lis.length;i++){ <br>
       console.log(lis[i]===ev.target,lis[i],i); <br>
       if(lis[i] !== ev.target){ <br>
           lis[i].style.background = ''; <br>
       }else{ <br>
           ev.target.style.background = 'green'; <br>
       } <br>
   } <br>
} <br>
// console.log(ev.target.tagName) <br>
}</code></p></li>
</ul>



<h4 id="没有冒泡的也可以阻止穿透">没有冒泡的，也可以阻止穿透</h4>

<ul><li><p><strong>onmouseenter 移入</strong></p></li>
<li><p><strong>onmouseleave 移出</strong> <br>
<code>box.onmouseenter = function(){ <br>
    alert('box移入') <br>
} <br>
box.onmouseleave = function(){ <br>
    alert('bo移出') <br>
} <br>
box1.onmouseenter = function(){ <br>
    alert('box2移入') <br>
}</code></p></li>
</ul>



<h4 id="坐标值">坐标值</h4>

<ul><li><p>基于浏览器可视区的顶端</p>

<ul>
<li><p><strong>ev.clientX  横轴   数字类型</strong></p></li>
<li><p><strong>ev.clientY  纵轴   数字类型</strong></p></li></ul></li>
<li><p>基于body的</p>

<ul>
<li><p><strong>ev.pageX   横轴</strong></p></li>
<li><p><strong>ev.pageY   纵轴</strong>     </p></li></ul></li>
</ul>



<h4 id="键盘事件">键盘事件</h4>

<ul><li><p><strong>onkeydown  键盘按下</strong>  获取不到最新的value值</p></li>
<li><p><strong>onkeyup    键盘抬起</strong>  可以获取到最新的value值</p></li>
<li><p><strong>ev.keyCode   键码</strong>  获取的值为数字类型</p>

<ul>
<li><p>37-40  键盘的左上右下</p></li>
<li><p>空格 32</p></li></ul></li>
<li><p>特殊按键:</p>

<ul>
<li><p><strong>ev.ctrlKey</strong></p></li>
<li><p><strong>ev.shiftKey</strong></p></li>
<li><p><strong>ev.altKey</strong></p></li></ul></li>
<li><p>只要按住就为true，否则false <br>
<code>//第一种2个键值写法 <br>
    let code = false; <br>
    txt.onkeydown = function (ev) { <br>
        if (ev.keyCode === 17) { <br>
            code = true; <br>
            console.log(code); <br>
        } <br>
    } <br>
    txt.onkeyup = function (ev) { <br>
        if (ev.keyCode === 13 &amp;&amp; code) { <br>
            console.log('bong'); <br>
        } <br>
        if (ev.keyCode === 17) { <br>
            code = false; <br>
        } <br>
    }</code> <br>
<code>//第二种2个键值写法。 <br>
    txt.onkeyup = function (ev) { <br>
        if (ev.keyCode === 13 &amp;&amp; ev.shiftKey) { <br>
            let li = document.createElement('li'); <br>
            li.innerHTML = this.value; <br>
            //下面这种写法和上面这种写法结果一样 <br>
            ul.insertBefore(li, ul.children[0]); <br>
            txt.value = ''; <br>
        } <br>
    }</code></p></li>
<li><p>当按键的时候会停顿一下，这个停顿有助于提高用户体验，避免重复输入</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">let</span> numL = <span class="hljs-number">0</span>;
</div><div class="hljs-line"><span class="hljs-keyword">let</span> numT = <span class="hljs-number">0</span>;
</div><div class="hljs-line"><span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
</div><div class="hljs-line"><span class="hljs-built_in">document</span>.onkeydown = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>{
</div><div class="hljs-line">   clearInterval(timer);
</div><div class="hljs-line">   timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
</div><div class="hljs-line">       <span class="hljs-keyword">switch</span> (ev.keyCode) {
</div><div class="hljs-line">           <span class="hljs-keyword">case</span> <span class="hljs-number">39</span>: <span class="hljs-comment">//右</span>
</div><div class="hljs-line">               numL += <span class="hljs-number">10</span>;
</div><div class="hljs-line">               box.style.left = numL + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">               <span class="hljs-keyword">break</span>;
</div><div class="hljs-line">           <span class="hljs-keyword">case</span> <span class="hljs-number">40</span>: <span class="hljs-comment">//下</span>
</div><div class="hljs-line">               numT += <span class="hljs-number">10</span>;
</div><div class="hljs-line">               box.style.top = numT + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">               <span class="hljs-keyword">break</span>;
</div><div class="hljs-line">           <span class="hljs-keyword">case</span> <span class="hljs-number">37</span>: <span class="hljs-comment">//左</span>
</div><div class="hljs-line">               numL -= <span class="hljs-number">10</span>;
</div><div class="hljs-line">               box.style.left = numL + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">               <span class="hljs-keyword">break</span>;
</div><div class="hljs-line">           <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>: <span class="hljs-comment">//上</span>
</div><div class="hljs-line">               numT -= <span class="hljs-number">10</span>;
</div><div class="hljs-line">               box.style.top = numT + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">               <span class="hljs-keyword">break</span>;
</div><div class="hljs-line">       }
</div><div class="hljs-line">   }, <span class="hljs-number">22</span>);
</div><div class="hljs-line">}
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-built_in">document</span>.onkeyup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</div><div class="hljs-line">   clearInterval(timer);
</div><div class="hljs-line">}
</div></code></pre>



<h4 id="事件默认行为">事件默认行为</h4>

<ul><li><p>默认行为:</p>

<ul>
<li><p>没有人为主动设置，浏览器默认的行为。</p></li></ul></li>
<li><p>行为使用:</p>

<ul>
<li><p>可以设置布尔值来控制是否阻止默认行为</p>

<ul>
<li><p>ev.returnValue = false;  都支持</p></li>
<li><p>return false;  只支持DOM0</p></li>
<li><p>ev.preventDefault();  DOM2支持</p></li></ul></li></ul></li>
</ul>

<blockquote>
  <p>注意： <br>
  如果在document身上阻止默认行为，会把整个页面的默认行为都阻止掉。 <br>
  如果想阻止某部分元素的默认行为，那么在指定的元素下阻止即可。</p>
</blockquote>



<pre class="prettyprint hljs-dark"><code class="hljs lua"><div class="hljs-line">// document.onkeydown = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ev)</span></span>{
</div><div class="hljs-line">    //     // console.log(ev);
</div><div class="hljs-line">    //     // ev.returnValue = <span class="hljs-literal">false</span>;
</div><div class="hljs-line">    //     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
</div><div class="hljs-line">    // }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    document.addEventListener(<span class="hljs-string">'keydown'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ev)</span></span>{
</div><div class="hljs-line">        // ev.returnValue = <span class="hljs-literal">false</span>;
</div><div class="hljs-line">        // <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
</div><div class="hljs-line">        ev.preventDefault();
</div><div class="hljs-line">    });
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    img.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ev)</span></span>{
</div><div class="hljs-line">        ev.returnValue = <span class="hljs-literal">false</span>;
</div><div class="hljs-line">    }
</div></code></pre>



<h4 id="右键默认菜单">右键默认菜单</h4>

<ul><li><p>oncontextmenu 事件可以阻止右键菜单</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line"><span class="hljs-built_in">document</span>.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">   <span class="hljs-comment">// console.log(1);</span>
</div><div class="hljs-line">      ev.returnValue = <span class="hljs-literal">false</span>;
</div><div class="hljs-line">  } 
</div></code></pre>



<h4 id="输入文字">输入文字</h4>

<ul><li><p>oninput： 改变输入框的内容就触发    </p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs matlab"><div class="hljs-line">txt.oninput = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
</div><div class="hljs-line">        <span class="hljs-built_in">size</span>.innerHTML = this.value.<span class="hljs-built_in">length</span> + <span class="hljs-string">'字'</span>;
</div><div class="hljs-line">    }
</div></code></pre>



<h4 id="焦点事件">焦点事件</h4>

<ul><li><p>聚焦事件： onfocus()           </p></li>
<li><p>失去焦点事件： onblur()</p></li>
<li><p>自动聚焦： ele.focus()     </p></li>
<li><p>select() 选中文本框的内容 （它也有聚焦的功能）</p></li>
<li><p>onchange  内容改变的时候触发(内容一定要不一致才触发)</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs awk"><div class="hljs-line">let arr = [<span class="hljs-string">'0.jpg'</span>,<span class="hljs-string">'1.jpg'</span>,<span class="hljs-string">'2.jpg'</span>]
</div><div class="hljs-line">    sele.onchange = <span class="hljs-keyword">function</span>(){
</div><div class="hljs-line">        <span class="hljs-regexp">//</span> console.log(this.value);
</div><div class="hljs-line">        div.innerHTML = arr[this.value];
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-regexp">//</span> txt.onfocus = <span class="hljs-keyword">function</span>(){
</div><div class="hljs-line">    <span class="hljs-regexp">//</span>     console.log(<span class="hljs-string">'聚焦'</span>);
</div><div class="hljs-line">    <span class="hljs-regexp">//</span> }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-regexp">//</span> <span class="hljs-regexp">//</span> txt.focus();
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-regexp">//</span> txt.select();
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-regexp">//</span> btn.onclick = <span class="hljs-keyword">function</span>(){
</div><div class="hljs-line">    <span class="hljs-regexp">//</span>     txt.select();
</div><div class="hljs-line">    <span class="hljs-regexp">//</span> }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-regexp">//</span> txt.onblur = <span class="hljs-keyword">function</span>(){
</div><div class="hljs-line">    <span class="hljs-regexp">//</span>     console.log(<span class="hljs-string">'失焦'</span>);
</div><div class="hljs-line">    <span class="hljs-regexp">//</span> }
</div></code></pre>



<h4 id="滚轮事件">滚轮事件</h4>

<ul><li><p>onscroll  滚轮事件  （页面必须要有滚动条）</p></li>
<li><p>onmousewheel  （Chrome）没有滚动条的滚轮事件(只要鼠标滚轮就触发)</p>

<ul>
<li><p>ev.wheelDelta 可以检测滚动的方向</p>

<ul>
<li><p>大于0， 为上滚轮</p></li>
<li><p>小于0， 为下滚轮    </p></li></ul></li></ul></li>
<li><p>DOMMouseScroll  （FF的滚轮）（只能使用DOM2来进行绑定）</p>

<ul>
<li><p>ev.detail  可以检测滚动的方向</p>

<ul>
<li><p>小于0， 为上滚轮</p></li>
<li><p>大于0， 为下滚轮</p></li></ul></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line"><span class="hljs-built_in">document</span>.onmousewheel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(ev.wheelDelta &gt; <span class="hljs-number">0</span>){
</div><div class="hljs-line">            alert(<span class="hljs-string">'向上'</span>);
</div><div class="hljs-line">        }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">            alert(<span class="hljs-string">'向下'</span>);
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-built_in">console</span>.log(ev.wheelDelta);
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'DOMMouseScroll'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-comment">// alert('Gunlun');</span>
</div><div class="hljs-line">        alert(ev.detail);
</div><div class="hljs-line">    })
</div></code></pre>



<h4 id="加载事件">加载事件</h4>

<blockquote>
  <p>把页面中的所有静态资源加载完成之后触发window.onload <br>
  <code>// window.onload = function(){ <br>
      //     alert(1); <br>
      // }</code></p>
</blockquote>

<ul><li><p>DOM加载完成才触发的事件</p>

<ul>
<li><p>jQ: ready()  $(function(){ })</p></li>
<li><p>DOMContentLoaded   高版本</p></li>
<li><p>onreadystatechange  低版本IE都支持这个事件</p></li></ul></li>
</ul>

<blockquote>
  <p>在低版本IE下，document有个doScroll的方法 <br>
  document.documentElement.doScroll(‘left’) <br>
  这个方法在DOM没有加载出来之前是没有的，也就是说调用该方法会报错，换句话来说，只要DOM记载成功就有doScroll方法</p>
</blockquote>

<ul><li><p>在try中包裹可能会报错的代码，包裹之后不会影响下面代码执行，只要捕获到错误，那么会进catch</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs scilab"><div class="hljs-line"><span class="hljs-keyword">try</span>{
</div><div class="hljs-line">     document.documentElement.doScroll(<span class="hljs-string">'left'</span>)
</div><div class="hljs-line">     console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'DOM加载完成'</span>);
</div><div class="hljs-line">     }<span class="hljs-keyword">catch</span>(e){
</div><div class="hljs-line">         再次调用<span class="hljs-keyword">try</span>、<span class="hljs-keyword">catch</span>直到进<span class="hljs-keyword">try</span>
</div><div class="hljs-line">     }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">例如：
</div><div class="hljs-line"><span class="hljs-keyword">try</span>{
</div><div class="hljs-line">        console.<span class="hljs-built_in">log</span>(a);
</div><div class="hljs-line">    }<span class="hljs-keyword">catch</span>(<span class="hljs-built_in">error</span>){
</div><div class="hljs-line">        a = <span class="hljs-number">10</span>;
</div><div class="hljs-line">        console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">error</span>);<span class="hljs-comment">//字符串</span>
</div><div class="hljs-line">    }
</div><div class="hljs-line">    alert(a);
</div></code></pre>



<h3 id="拖拽">拖拽</h3>

<ul><li><p>实现的原理：改变元素top值和left值</p></li>
<li><p>拖拽三大事件：这3个事件写拖拽在PC上是需要嵌套的。</p>

<ul>
<li><p>onmousedown</p></li>
<li><p>onmousemove</p></li>
<li><p>onmouseup</p></li></ul></li>
</ul>



<h5 id="1拖拽">1、拖拽</h5>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">//存按下的坐标的</span>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> ol = <span class="hljs-number">0</span>;
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> ot = <span class="hljs-number">0</span>;
</div><div class="hljs-line">    box.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">        l = ev.pageX; <span class="hljs-comment">//按下的坐标</span>
</div><div class="hljs-line">        t = ev.pageY;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">//每次按下的时候去记录元素的初始距离</span>
</div><div class="hljs-line">        ol = box.offsetLeft;
</div><div class="hljs-line">        ot = box.offsetTop;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        box.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">            <span class="hljs-comment">//移动的坐标（ev.pageX） - 按下的坐标（l）</span>
</div><div class="hljs-line">            <span class="hljs-comment">// console.log()</span>
</div><div class="hljs-line">            box.style.left = ol + ev.pageX - l + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">            box.style.top = ot + ev.pageY - t + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        box.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">            box.onmousemove = <span class="hljs-literal">null</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">    }
</div></code></pre>



<h5 id="2拖拽">2、拖拽</h5>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;
</div><div class="hljs-line">    <span class="hljs-comment">//按下的时候</span>
</div><div class="hljs-line">    box.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-comment">//拿到那一小段距离（按下的位置到边界位置）</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">            按下的位置：</span>
</div><div class="hljs-line"><span class="hljs-comment">                ev.pageX </span>
</div><div class="hljs-line"><span class="hljs-comment">                ev.pageY</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">            元素的初始位置</span>
</div><div class="hljs-line"><span class="hljs-comment">                box.offsetLeft</span>
</div><div class="hljs-line"><span class="hljs-comment">                box.offsetTop</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">            按下的位置 - 元素的初始位置 = 拿到那一小段距离</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">            问题:</span>
</div><div class="hljs-line"><span class="hljs-comment">                1.当mousemove在元素身上的时候，鼠标移动过快会导致</span>
</div><div class="hljs-line"><span class="hljs-comment">                鼠标脱离元素，脱离元素就不能让元素移动</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">                解决:</span>
</div><div class="hljs-line"><span class="hljs-comment">                    把元素身上的mousemove换到document身上</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">                2.当mouseup的时候如果鼠标不在元素身上，那么</span>
</div><div class="hljs-line"><span class="hljs-comment">                  解除move行为也就失效了</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">                解决:</span>
</div><div class="hljs-line"><span class="hljs-comment">                    把元素身上的mouseup换到document身上</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">                3.如果在mouseup的时候只清除move函数的行为</span>
</div><div class="hljs-line"><span class="hljs-comment">                那么在document进行up的行为还会执行</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">                解决:</span>
</div><div class="hljs-line"><span class="hljs-comment">                    在清除mousemove的时候也把mouseup清除</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">        */</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> disX = ev.pageX - box.offsetLeft;
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> disY = ev.pageY - box.offsetTop;
</div><div class="hljs-line">        <span class="hljs-comment">//为了保证移动过元素的</span>
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> onoff = <span class="hljs-literal">false</span>;
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">            <span class="hljs-comment">//只要移动过元素就设置为true</span>
</div><div class="hljs-line">            onoff = <span class="hljs-literal">true</span>;
</div><div class="hljs-line">            <span class="hljs-comment">//在move的过程当值就可以求出元素的位置</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">                移动时的坐标 - 那一小段距离 = 盒子当前的位置 </span>
</div><div class="hljs-line"><span class="hljs-comment">            */</span>
</div><div class="hljs-line">            box.style.left = ev.pageX - disX + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">            box.style.top = ev.pageY - disY + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">            <span class="hljs-comment">//只要移动过就进行累计</span>
</div><div class="hljs-line">            <span class="hljs-keyword">if</span>(onoff){
</div><div class="hljs-line">                num++;
</div><div class="hljs-line">                <span class="hljs-built_in">console</span>.log(num);
</div><div class="hljs-line">            }
</div><div class="hljs-line">            <span class="hljs-comment">//在鼠标抬起的时候清除move</span>
</div><div class="hljs-line">            <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-literal">null</span>;
</div><div class="hljs-line">            <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-literal">null</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
</div><div class="hljs-line">    }
</div></code></pre>



<h5 id="3dom2拖拽">3、DOM2拖拽</h5>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">box.addEventListener(<span class="hljs-string">'mousedown'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> disX = ev.pageX - <span class="hljs-keyword">this</span>.offsetLeft;
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> disY = ev.pageY - <span class="hljs-keyword">this</span>.offsetTop;
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> move = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">            box.style.left = ev.pageX - disX + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">            box.style.top = ev.pageY - disY + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">up</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">            <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">'mousemove'</span>,move);
</div><div class="hljs-line">            <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">'mouseup'</span>,up);
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'mousemove'</span>,move);
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'mouseup'</span>,up);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">// ev.returnValue = false;</span>
</div><div class="hljs-line">        ev.preventDefault();
</div><div class="hljs-line">    });
</div></code></pre>



<h4 id="4在限制范围内拖拽">4、在限制范围内拖拽</h4>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">        在拖拽元素的时候，要注意该元素的一个定位问题</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">        父级要有相对定位，自己有绝对定位</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">        如果没有相对定位，在限制范围的时候还要减去box的offsetLeft和border的尺寸</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">    */</span>
</div><div class="hljs-line">    box2.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> disX = ev.pageX - box2.offsetLeft;
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> disY = ev.pageY - box2.offsetTop;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-built_in">console</span>.log(ev.pageX,box2.offsetLeft)
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        box.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">            <span class="hljs-keyword">let</span> l = ev.pageX - disX;
</div><div class="hljs-line">            <span class="hljs-keyword">let</span> t = ev.pageY - disY;
</div><div class="hljs-line">            <span class="hljs-keyword">if</span>(l &lt; <span class="hljs-number">0</span>){
</div><div class="hljs-line">                l = <span class="hljs-number">0</span>;
</div><div class="hljs-line">            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l &gt; <span class="hljs-number">2</span> + box.offsetLeft + box.clientWidth - box2.clientWidth){
</div><div class="hljs-line">                l = <span class="hljs-number">2</span> + box.offsetLeft + box.clientWidth - box2.clientWidth;
</div><div class="hljs-line">            }
</div><div class="hljs-line">            <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>){
</div><div class="hljs-line">                t = <span class="hljs-number">0</span>;
</div><div class="hljs-line">            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t &gt; box.clientHeight - box2.clientHeight){
</div><div class="hljs-line">                t = box.clientHeight - box2.clientHeight;
</div><div class="hljs-line">            }
</div><div class="hljs-line">            box2.style.left = l + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">            box2.style.top = t + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">            box.onmousemove = <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-literal">null</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">    }
</div></code></pre>



<h5 id="5仿windows的拖拽">5、仿windows的拖拽</h5>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">        1.在按下box的时候，创建一个跟它一样一样的元素</span>
</div><div class="hljs-line"><span class="hljs-comment">        2.拖动一样一样的那个元素</span>
</div><div class="hljs-line"><span class="hljs-comment">        3.抬起的时候把一样一样元素的位置给按下的那个box</span>
</div><div class="hljs-line"><span class="hljs-comment">        4.再删除一样一样的那个元素</span>
</div><div class="hljs-line"><span class="hljs-comment">    */</span>
</div><div class="hljs-line">    box.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> disX = ev.pageX - box.offsetLeft;
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> disY = ev.pageY - box.offsetTop;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">//创建一个元素</span>
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> createBox = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        createBox.className = <span class="hljs-string">'active'</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">//为了第二次点击的时候一样一样这个元素的位置不为0</span>
</div><div class="hljs-line">        <span class="hljs-comment">//所以把box的初始位置给一样一样这个元素</span>
</div><div class="hljs-line">        createBox.style.left = box.offsetLeft + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">        createBox.style.top = box.offsetTop + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">// for(let attr in getComputedStyle(box)){</span>
</div><div class="hljs-line">        <span class="hljs-comment">//     createBox.style[attr] = getComputedStyle(box)[attr];</span>
</div><div class="hljs-line">        <span class="hljs-comment">// }</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">//插入到页面</span>
</div><div class="hljs-line">        body.appendChild(createBox);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">// console.log(createBox)</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">            <span class="hljs-keyword">let</span> l = ev.pageX - disX;
</div><div class="hljs-line">            <span class="hljs-keyword">let</span> t = ev.pageY - disY;
</div><div class="hljs-line">            <span class="hljs-comment">//移动一样一样那个元素</span>
</div><div class="hljs-line">            createBox.style.left = l + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">            createBox.style.top = t + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">            <span class="hljs-comment">//把一样一样那个元素的位置给box</span>
</div><div class="hljs-line">            box.style.left = createBox.style.left;
</div><div class="hljs-line">            box.style.top = createBox.style.top;
</div><div class="hljs-line">            <span class="hljs-comment">//删除一样一样那个元素</span>
</div><div class="hljs-line">            createBox.remove();
</div><div class="hljs-line">            <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-literal">null</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-comment">//阻止默认行为</span>
</div><div class="hljs-line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
</div><div class="hljs-line">    }
</div></code></pre>



<h4 id="自定义滚动条">自定义滚动条</h4>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">        比例:</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">            0 - 1</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">            1/1</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">            box2的top / (黑色的高度 - 红色的高度) = 0到1之间的比例</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">    */</span>
</div><div class="hljs-line">    box2.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> disY = ev.pageY - box2.offsetTop;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">            <span class="hljs-keyword">let</span> t = ev.pageY - disY;
</div><div class="hljs-line">            <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>){
</div><div class="hljs-line">                t = <span class="hljs-number">0</span>;
</div><div class="hljs-line">            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t &gt; box.clientHeight - box2.clientHeight){
</div><div class="hljs-line">                t = box.clientHeight - box2.clientHeight;
</div><div class="hljs-line">            }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-keyword">let</span> scale = t / (box.clientHeight - box2.clientHeight);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-built_in">console</span>.log(box4.scrollHeight)
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">                box4的top值 = 比例 * (被内容撑开的高度 - 内容可视区的高度)</span>
</div><div class="hljs-line"><span class="hljs-comment">            */</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            box4.style.top = - scale * (box4.scrollHeight - box3.clientHeight) + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            box2.style.top = t + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">            <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-literal">null</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">    }
</div></code></pre>



<h5 id="自定义滚动条加滚轮">自定义滚动条—加滚轮</h5>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">       1.加滚轮</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">       2.页面的内容是否小于内容可视区的高度，就隐藏滚动条</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">       3.内容越多，滚动条越短，内容越少滚动条就越长</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">    */</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> b4h = box4.scrollHeight;  <span class="hljs-comment">//box4的被内容撑开的高度</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> b3h = box3.clientHeight;<span class="hljs-comment">//内容可视区的高度</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">//如果box4的高度小于等于可视区的高度，那么隐藏滚动条</span>
</div><div class="hljs-line">    <span class="hljs-keyword">if</span>(b4h &lt;= b3h){
</div><div class="hljs-line">        box.style.display = <span class="hljs-string">'none'</span>;
</div><div class="hljs-line">    }
</div><div class="hljs-line">    <span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">        内容越多，滚动条就越短，否则就越长</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">        最小30，最长150</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">        30 + box3高度/box4高度 * 120</span>
</div><div class="hljs-line"><span class="hljs-comment">    */</span>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> h = <span class="hljs-number">30</span> + b3h/b4h * <span class="hljs-number">120</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">// if(h &lt; 30){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     h = 30;</span>
</div><div class="hljs-line">    <span class="hljs-comment">// }else if(h &gt; 150){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     h = 150;</span>
</div><div class="hljs-line">    <span class="hljs-comment">// }</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    box2.style.height = h + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    box2.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> disY = ev.pageY - box2.offsetTop;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">            <span class="hljs-keyword">let</span> t = ev.pageY - disY;
</div><div class="hljs-line">            <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>){
</div><div class="hljs-line">                t = <span class="hljs-number">0</span>;
</div><div class="hljs-line">            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t &gt; box.clientHeight - box2.clientHeight){
</div><div class="hljs-line">                t = box.clientHeight - box2.clientHeight;
</div><div class="hljs-line">            }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-keyword">let</span> scale = t / (box.clientHeight - box2.clientHeight);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-built_in">console</span>.log(box4.scrollHeight)
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">                box4的top值 = 比例 * (被内容撑开的高度 - 内容可视区的高度)</span>
</div><div class="hljs-line"><span class="hljs-comment">            */</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            box4.style.top = - scale * (box4.scrollHeight - box3.clientHeight) + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            box2.style.top = t + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">            <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-literal">null</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    addWheel(box,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> t = box2.offsetTop;
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(o){
</div><div class="hljs-line">            t -= <span class="hljs-number">5</span>;
</div><div class="hljs-line">        }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">            t += <span class="hljs-number">5</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>){
</div><div class="hljs-line">            t = <span class="hljs-number">0</span>;
</div><div class="hljs-line">        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t &gt; box.clientHeight - box2.clientHeight){
</div><div class="hljs-line">            t = box.clientHeight - box2.clientHeight;
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> scale = t / (box.clientHeight - box2.clientHeight);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        box4.style.top = - scale * (box4.scrollHeight - box3.clientHeight) + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">        box2.style.top = t + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">    });
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addWheel</span>(<span class="hljs-params">obj,fn</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-comment">//let w = window.navigator.userAgent.toLowerCase();</span>
</div><div class="hljs-line">        <span class="hljs-comment">// if(w.includes('chrome')){</span>
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(obj.onmousewheel === <span class="hljs-literal">null</span>){
</div><div class="hljs-line">        <span class="hljs-comment">// if('onmousewheel' in window){</span>
</div><div class="hljs-line">            obj.onmousewheel = whell;
</div><div class="hljs-line">        }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">            obj.addEventListener(<span class="hljs-string">'DOMMouseScroll'</span>,whell);
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">whell</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">            <span class="hljs-keyword">let</span> o = <span class="hljs-literal">true</span>;
</div><div class="hljs-line">            <span class="hljs-comment">// console.log(ev.wheelDelta);</span>
</div><div class="hljs-line">            <span class="hljs-keyword">if</span>(ev.wheelDelta){ <span class="hljs-comment">//是chrome</span>
</div><div class="hljs-line">                o = ev.wheelDelta &gt; <span class="hljs-number">0</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;
</div><div class="hljs-line">            }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">                o = ev.detail &lt; <span class="hljs-number">0</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;
</div><div class="hljs-line">            }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-comment">//回调函数</span>
</div><div class="hljs-line">            fn &amp;&amp; fn(o);
</div><div class="hljs-line">        }
</div><div class="hljs-line">    }
</div></code></pre>



<h1 id="云思路">云思路</h1>



<h2 id="面包屑">面包屑</h2>

<ul><li><p>获得当前页面的id，通过这个id向上找pid，直到找到-1为止</p></li>
</ul>

<blockquote>
  <p>比如:周杰伦 id:3  pid:2  传入的是3  data[3].pid -&gt; 2  data[2].pid -&gt; 0 data[0].pid -&gt; -1 </p>
</blockquote>



<pre class="prettyprint hljs-dark"><code class="hljs zephir"><div class="hljs-line">    <span class="hljs-number">1.</span>先找到一个父级
</div><div class="hljs-line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParent</span><span class="hljs-params">(id)</span></span>{
</div><div class="hljs-line">        <span class="hljs-comment">//有这个数据并且pid不等于-1</span>
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(data[id] &amp;&amp; data[id].pid != <span class="hljs-number">-1</span>){
</div><div class="hljs-line">            <span class="hljs-keyword">return</span> data[id].pid;
</div><div class="hljs-line">        }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-number">2.</span>获取一堆的父级   <span class="hljs-comment">//有问题</span>
</div><div class="hljs-line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParents</span><span class="hljs-params">(id)</span></span>{ <span class="hljs-comment">//3</span>
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> <span class="hljs-keyword">parent</span> = getParent(id); <span class="hljs-comment">// 我的音乐</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> arr = [];
</div><div class="hljs-line">        arr.push(data[id]); <span class="hljs-comment">//周杰伦   [周杰伦]</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">parent</span>){
</div><div class="hljs-line">            arr.unshift(<span class="hljs-keyword">parent</span>); <span class="hljs-comment">//[微云,我的音乐,周杰伦]</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-keyword">parent</span> = getParent(data[id].pid);  
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-comment">//data[3].pid -&gt; 2   </span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-keyword">parent</span> = getParent(<span class="hljs-number">2</span>)  <span class="hljs-comment">//微云</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-keyword">return</span> arr;
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    getParents(<span class="hljs-number">3</span>)
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParents</span><span class="hljs-params">(id)</span></span>{ <span class="hljs-comment">//3</span>
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> arr = [];
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> now = data[id]; <span class="hljs-comment">// data[3]  -&gt; 周杰伦</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">while</span>(now){
</div><div class="hljs-line">            arr.unshift(now); <span class="hljs-comment">//[我的音乐,周杰伦]</span>
</div><div class="hljs-line">            now = getParent(now.id); <span class="hljs-comment">//3 </span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-comment">//  now = {id:2,我的音乐}</span>
</div><div class="hljs-line">            getParent(<span class="hljs-number">2</span>);
</div><div class="hljs-line">            <span class="hljs-comment">//  now = {id:0,微云}</span>
</div><div class="hljs-line">        }
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div></code></pre>



<h2 id="树形菜单">树形菜单</h2>

<ul><li><p>如果传入一个0，拿到0和0的子级</p></li>
<li><p>子级是否有子级，如果有子级添加tree-title tree-ico close，如果没有就添加tree-title tree-ico-none</p></li>
<li><p>第一个是open</p></li>
</ul>



<h2 id="移动到">移动到</h2>

<ul><li><p>点击确定的时候，判断选中的id，是否在移动到的数据或者数据的子孙级上，如果是就不能让其移动</p></li>
<li><p>核心思想就是把选中数据的pid换成移动到数据的id</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line">    <span class="hljs-comment">//当点击的时候获取移动到的id</span>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> id = li.dataset.id * <span class="hljs-number">1</span>;
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> ary = getChild(globalId);
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> arr = ary.filter(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item.checked);
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> len = arr.length;
</div><div class="hljs-line">    <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">1</span>){
</div><div class="hljs-line">        <span class="hljs-keyword">return</span>;
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">//[{id:0},{id:1}]</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">//[{id:0},{id:2,pid:0},{id:1}]</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> onoff = <span class="hljs-literal">false</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">id</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> arr = getChild(id);
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(arr &amp;&amp; arr.length){
</div><div class="hljs-line">            arr.forEach(<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>{
</div><div class="hljs-line">                <span class="hljs-keyword">if</span>(id === e.id){
</div><div class="hljs-line">                    onoff = <span class="hljs-literal">true</span>;
</div><div class="hljs-line">                    <span class="hljs-keyword">return</span>;
</div><div class="hljs-line">                }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">                fn(e.id)
</div><div class="hljs-line">                }
</div><div class="hljs-line">            });
</div><div class="hljs-line">        }
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    fn(globalId);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">if</span>(onoff){
</div><div class="hljs-line">        <span class="hljs-comment">//移动不合法</span>
</div><div class="hljs-line">    }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">        <span class="hljs-comment">//开始移动</span>
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> ary = getChild(选中的id);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    ary.push(data[id]);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    ary.forEach(<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(e.id === id){
</div><div class="hljs-line">            onoff = <span class="hljs-literal">true</span>;
</div><div class="hljs-line">            <span class="hljs-keyword">return</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">    })
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">if</span>(onoff){
</div><div class="hljs-line">        <span class="hljs-comment">//移动不合法</span>
</div><div class="hljs-line">    }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">        <span class="hljs-comment">//开始移动</span>
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div></code></pre>



<h2 id="柯里化函数名字就是大高上currying">柯里化函数：名字就是大高上（Currying）</h2>

<blockquote>
  <p>函数嵌套函数，子函数用父函数的参数，通常子函数自己还有参数， <br>
  父函数返回子函数，子函数的运行结果还要和父函数的参数有关联并且子函数被外界引用。</p>
</blockquote>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><wbr>
</div><div class="hljs-line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x</span>)</span>{
</div><div class="hljs-line">      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>)</span>{
</div><div class="hljs-line">          <span class="hljs-built_in">console</span>.log(x,y)
</div><div class="hljs-line">      }
</div><div class="hljs-line">  }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">  <span class="hljs-keyword">let</span> f = fn(<span class="hljs-string">'number'</span>)
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">  <span class="hljs-keyword">let</span> f2 = fn(<span class="hljs-string">'string'</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">  fn(<span class="hljs-string">'number'</span>,<span class="hljs-number">5</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">  fn = <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> {
</div><div class="hljs-line">      <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">b</span>)=&gt;</span>{
</div><div class="hljs-line">         <span class="hljs-keyword">return</span> a+b;
</div><div class="hljs-line">      }
</div><div class="hljs-line">  } 
</div><div class="hljs-line">  fn = <span class="hljs-function"><span class="hljs-params">a</span>=&gt;</span><span class="hljs-function"><span class="hljs-params">b</span>=&gt;</span>a+b
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">  f(<span class="hljs-number">5</span>);
</div><div class="hljs-line">  f(<span class="hljs-number">5</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">  fn(<span class="hljs-string">'string'</span>,<span class="hljs-number">5</span>);
</div><div class="hljs-line">  f2(<span class="hljs-string">'哈哈'</span>)
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        需求:
</div><div class="hljs-line">            <span class="hljs-number">1.</span>改变<span class="hljs-keyword">this</span>
</div><div class="hljs-line">            <span class="hljs-number">2.</span>要传参
</div><div class="hljs-line">            <span class="hljs-number">3.</span>要<span class="hljs-keyword">new</span>
</div><div class="hljs-line">    *<span class="hljs-regexp">/    </span>
</div><div class="hljs-line"><span class="hljs-regexp"></span>
</div><div class="hljs-line"><span class="hljs-regexp">    /</span><span class="hljs-regexp">/context 就是改变this的参数</span>
</div><div class="hljs-line"><span class="hljs-regexp">    /</span><span class="hljs-regexp">/Function.prototype.bind()  fn.bind()</span>
</div><div class="hljs-line"><span class="hljs-regexp">    /</span><span class="hljs-regexp">/当需要在bind上写多个参数的时候，就需要剩余运算符，arg除了第一个参数以外的参数</span>
</div><div class="hljs-line"><span class="hljs-regexp">    Function.prototype.bind = function(context,...arg){</span>
</div><div class="hljs-line"><span class="hljs-regexp">        /</span><span class="hljs-regexp">/ console.log(this); /</span><span class="hljs-regexp">/实例fn</span>
</div><div class="hljs-line"><span class="hljs-regexp">        let that = this;</span>
</div><div class="hljs-line"><span class="hljs-regexp">        function bound(...args){</span>
</div><div class="hljs-line"><span class="hljs-regexp">            /</span><span class="hljs-regexp">/ console.log(arg);</span>
</div><div class="hljs-line"><span class="hljs-regexp">            /</span><span class="hljs-regexp">/ that.call(context,...arg);</span>
</div><div class="hljs-line"><span class="hljs-regexp">            /</span><span class="hljs-regexp">/合并数组arg.concat(args)</span>
</div><div class="hljs-line"><span class="hljs-regexp"></span>
</div><div class="hljs-line"><span class="hljs-regexp">            /</span><span class="hljs-regexp">/如果是构造函数this就不能变</span>
</div><div class="hljs-line"><span class="hljs-regexp">            /</span><span class="hljs-regexp">/检测this是不是bound构造出来的</span>
</div><div class="hljs-line"><span class="hljs-regexp">            /</span><span class="hljs-regexp">/如果是就说明new了bound</span>
</div><div class="hljs-line"><span class="hljs-regexp">            if(this instanceof bound){</span>
</div><div class="hljs-line"><span class="hljs-regexp">                that.apply(this,[...arg,...args]);</span>
</div><div class="hljs-line"><span class="hljs-regexp">            }else{</span>
</div><div class="hljs-line"><span class="hljs-regexp">                that.apply(context,[...arg,...args]);</span>
</div><div class="hljs-line"><span class="hljs-regexp">            }</span>
</div><div class="hljs-line"><span class="hljs-regexp">            /</span><span class="hljs-regexp">/ console.log(this);</span>
</div><div class="hljs-line"><span class="hljs-regexp">        }</span>
</div><div class="hljs-line"><span class="hljs-regexp"></span>
</div><div class="hljs-line"><span class="hljs-regexp">        /</span><span class="hljs-regexp">/要把fn的prototype下的方法给bound</span>
</div><div class="hljs-line"><span class="hljs-regexp">        if(this.prototype){</span>
</div><div class="hljs-line"><span class="hljs-regexp">            bound.prototype = this.prototype;</span>
</div><div class="hljs-line"><span class="hljs-regexp">        }</span>
</div><div class="hljs-line"><span class="hljs-regexp">        return bound;</span>
</div><div class="hljs-line"><span class="hljs-regexp">    }</span>
</div><div class="hljs-line"><span class="hljs-regexp"></span>
</div><div class="hljs-line"><span class="hljs-regexp">    function fn(a,b,c,d,e){</span>
</div><div class="hljs-line"><span class="hljs-regexp">        /</span><span class="hljs-regexp">/ console.log(this,a,b,c,d,e);</span>
</div><div class="hljs-line"><span class="hljs-regexp">        this.a = a;</span>
</div><div class="hljs-line"><span class="hljs-regexp">        console.log(this.aaa);</span>
</div><div class="hljs-line"><span class="hljs-regexp">    }</span>
</div><div class="hljs-line"><span class="hljs-regexp"></span>
</div><div class="hljs-line"><span class="hljs-regexp">    fn.prototype.aaa = 20;</span>
</div><div class="hljs-line"><span class="hljs-regexp"></span>
</div><div class="hljs-line"><span class="hljs-regexp">    /</span><span class="hljs-regexp">/fn{a:1}</span>
</div><div class="hljs-line"><span class="hljs-regexp">    /</span><span class="hljs-regexp">/ fn();</span>
</div><div class="hljs-line"><span class="hljs-regexp"></span>
</div><div class="hljs-line"><span class="hljs-regexp">    let f = fn.bind(document,1,2,3,4);</span>
</div><div class="hljs-line"><span class="hljs-regexp"></span>
</div><div class="hljs-line"><span class="hljs-regexp">    console.log(new f(5));</span>
</div></code></pre>



<h1 id="jquery">jquery</h1>

<ul><li><p>1.引入jquery</p></li>
<li><p>2.选择器</p>

<ul>
<li><p>“#” <code>$('#')</code></p></li>
<li><p>“.”点</p></li>
<li><p>标签选择器</p></li>
<li><p>属性选择器 input[type=”text”]</p></li></ul></li>
<li><p>3.操作属性</p>

<ul>
<li><p>innerHTML  ：  html()  <code>html('&lt;li&gt;&lt;/li&gt;')</code></p></li>
<li><p>innerText  ：  text()</p></li>
<li><p>value    ：    val()</p></li>
<li><p>getAttribute|setAttribute|removeAttribute：attr(id,’box’) </p></li>
<li><p>removeAttr()</p></li>
<li><p>className    addClass   removeClass  replaceClass</p></li>
<li><p>style    ：    css(‘width’)</p></li>
<li><p>cssText  ：    css(‘height’,’200px’)</p></li>
<li><p>prop 复选框使用</p></li>
<li><p>index(‘设置范围’)</p></li></ul></li>
</ul>

<blockquote>
  <p>在JQ中一般都有这么一个特性，传一个字符串或者不传参就是获取 <br>
  两个参数就是设置css(‘height’,’200px’) <br>
  如果传入一个参数，这个参数还是对象，批量设置</p>
</blockquote>

<ul><li><p>原生对象转JQ对象 -&gt; $(原生对象)</p></li>
<li><p>jQ对象转原生 -&gt; <span class="" rel="98ecce1d6148bf8d5779d9a5b7c9f107"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" role="textbox" aria-readonly="true" style="font-size: 100%; display: inline-block;"><span><img type="image/png" width="125" height="17" longdesc="__SVG__undefined" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAAiCAYAAAB2gcR/AAAUH0lEQVR4Xu3dCbRu4VgH8D+JUNJgatCciqJSNNFcGqhEpkpSQoOUSmUomqNJcylp0IAoigYZQhqVopEIlaEBjcj63fU+1tu79v6+vfc537nn3Huftc6693zfHt7h+T/D/3n2PpfJJbm0Aodfgfsk+cYkH57kdw9/u4Pd4cpJvj3J3do8Pj/JX3Z3u2KS70pyl2Oc62WT3C7Jg5J8RZKfTfL6tTO8zIoTrpDktUlet+KcQx5qUf8ryf8d8iaXrn0sK/DlSR58jMo/DurazZBc61hGO3+RqyS5cfc1o9WDHZ7u137mjNoHJLlvEvq7RBx3gyRvkeRVzcg8M8mbJnllkn8aLvKWSd6uffbc+m4p0A3um5I8JskPLRndCRzDsr5rknsk+YcV9/uoJF/SjFZ/mrVgNP6gWe0Vl7zgDr1qkp/o1mg0pv+c5F5J/nPhzG+f5KdXAN1e+Fnjua6R5EpJ/nHhuA7hfS3HvujFvN68jZHjXCvvkOQJSd6n4fGzkvx3d5FHJvn09vv7Jvlz/18C9M9N8s1JfjnJ3deO6oDH26jHN+tljKzcEvnSJN/dzf23k7y8WUgK/YdtvkuudaEe89ZJfrIDOsDxZG/fJvynST42ycsWLsA+oPNOlL4Myts0wHxvkr/bcY8PSXKnJF8/4dn2De18AX3fuPZ9/44N4O+f5BeSfM4A9EckuXW7yPWT/NkSoH9NknsneXiSL943gvPw/eWTPCqJSQuhfn3BGHjz72lA/9skN0ryigXnXcyHcAgUCvjJs5N83DEBnSe2HzyRH0YF0H8myQe1e/3vxOLLXd8jyTslodz0c80+niTQ3yrJv62MUOb07diBfv+Wa/xqkpuf4lzYhj22AfYTkzx9DyJ7oFMQCjylSBczsKfmft3mHYB+Cug4HOH8R0ycfLVmjEVd/z58X9/JP0Vmj+6A7lDRwByAhcmf3bz601Zu2EkBXdTx/Y2j2ESkDfM6VqBbcFb2BUluluSlKxfxpA//wCS/0siKWyZ5zo4B9ECfCn1Oeuxn5X7vl+RPWiQ059EvlwQzDbR9fr0rdP+wJEB6zyTf10L48uhLgG6/5ak9+71kTY8K9Ou1lIG37kWEcZ2WSr66izqKSDsq2I8N6MJgXhxzd4vmLZcs3Pk+BimntCFv/7QdXvoS0Lft1BKgz115F9CBVGT18Ul+o13gLADdUJFq/9N+/P5mrQym/HaIUqJoCtEm2ka0bc7RkSK/2AD+Ww0wrNJZEJbuWUmumeTzunxyHPsloG/bzaMAfRcTPWUEzgrQx5XkHHELH3kAoBfIEcmqC9ZoM9Dl4kpo5AuT/Og2nThvZxnvnVsOiRXGpp9moFdJ76gLdlzX2TWOowJd/s5rj9WR0wB0eiOk/r2Fpbm5dVKZeGKreY8e/RNaWZcz3SLOw6JXqmDPVcJus5Z1d6FfS/IxSV6S5CZJsNL7BGsqJ1GffudWmvrr4STHMBzKM98xXFcjgM8pQRE+D5m4qTTik5M8KcnPzQxKWIOFJ1+WRHnmOICuUcICs6LWRaPOj3fpgYYNG2kNfqfVoKcIPqGe+SpfYfs1eLDQr5kYp7VwPHb5j4bNRHwZj+u8d5IbtutU8wQl+JQ2HhEZtnwsUzmXYac8z2vz2VXXPSrQ53Lp0wB0ekWHNfb8ZpKf2gh6HXHVZ/LRTVdra5fUz2stNNQ8YEbHj5yjv2erIVMuVveTkvzLDpRrqviBJB/aShx16B83QBaBJ5xhQCgKEV4rzWi2UJf/zKZs7lviM6WWEl1VNqHExsjFR9FAg9gBIAbBHICylzWh+2c0Vv5tk7xL13GEqMQJEKz91zZFqfsIqW7bEVJCLQpgfP6PByHGCGxjeuRe9uDqrYSFuWV0EV3uzTBKUXRMEd+JYJCn1vHHGkFV41FLZcCr7u08DTF1vuOMmXeY6zTcCvQ3aUprL6ZIsymgM2JKusi9faz7cZJxHNU3tD3VdWYMP9wM4b4OzJ7cs54MvmrQj8wY8gn1PTdXjUUHBXqRWbXpNmWXaLX7ohbq89hCn2q9Q4ZJAQDuKV2Xk7rnk5v3Q2LcMQnvL4L4lq7Qjydwf4uLYAP8FzajwvvxqrzcKACJW6CUWE512JGNXQP0T20Adn8euMT9n9qiFIqh1RARA5DEfIRuz2+/s+YMKYDaxJu2z7HMGnhG+YKmID7X0MMYmDdlYvBEFqohvDkpApKnt+66phg8BtU+EV5fM5DyF1DrbgN8BoAw0Ob74plN3wr0AgCPSZGtTS8M5Ve2vRdZkDoH8E4S6O4tgmLgH9gZbxEk/TzXfDIj5vfzzWk5RKnXvr17iy5rbjsucTJA/6UkrCN5aGtA2TWo8TseAnAJcGq0MXEWHWiBkFLx1GMt1TmUnxUkyjhCeV4AMJT7/qKBjYfmCaeEojMSFJZMhe9rgF73oORKSkSdXhohNMau8tSMnBJf1XJ5WMZgVGrjUwYEQEKh1I17YTAel0ToR/rooY6zpg9rIPAZY2PNAZgXVFvWoGE85bXNAYCcx3iIQhiecy2SzXCa01wpdSvQpSrqyKKTKdAi6kavfD6BXmss+vrOrp3075seclRTYi+lSCJVc2XoRQWMBJ21J31Kaw/H50YO7tHloLrKyiOxsJ6WWSNADuxEeY7HNXl56xQpNl6b0gEwr09svnxeKUEItUR4TkAvgyXXB+xetgDdk1cUkpij/JzB+qqWz/ncRsrtiLCbUfuP4d7yKxGHOerJVkMec2d7oJcZQEhFR/2lGE2lqAKxPFsbqOYTXkQ0wxt66EKURcFEJcJC53kKiogmGBLCuFi3vm+6v+dWoBeD/qJmeMc1Oa1AN3c8xrcmEWERobj/i4Z6KcME4Pb1rg3o9ICOaCE3T8+LiFIZfHotQqBHteYj0OHHMb2BOFKOLsSWR1MYsgXoyKNqVOHRKKoy11QuPazTuV95MlGF/JsIh5+xIbJgQeWaxP9FAz0xthboNsVm1Lj0VgMKT96Thp5asnlkLiRn5YX8hFcVGYz5OQKxjNPfNIMhbelFmPj7bY31nTNuAC5Pr2hJiaciH3vrPkBWUZfrmRdlIsgf0dOcbAW60FWdXAqnpVrK1gsAWAd7Zr7kNHj0GiOwc3q1blP1cbpvDxzHsPaP5FYzF6cl6iI4GLopHWQ8GAMp5gh0zk/k5XpFtB4J6Lp5hJBFEulSqkHt2Pv/95U8nScqYyGMAfQ1goEWbhObLnzlCdaI8PVW7QTlEsrfg2kt0K0Ny4z8MiahrpCroga3UrFgpICNTIXkPgcmnpdMGQNPJjEAFdXwsq41gkNeKwQnQGyM1hrRWdIbHpUIxwB/rYX9UgoqkrR4h7m13gr0KjkpryG2eqnHOh3Th/WnCejGiwsRyYl86ValOzUXbLuIyb4o7/ZANxdgFe2VZ7anjCz9pI+emOTpp0J3n4n8vrpFakcCOgsjB61wca40tQtwSAwgKwB4yEButkZqAZyDVPIUzqjk+64nX8Z4E3Oi3P/anbQW6H3JDqHCw6s0CNFKemPgc4orp+tljAymjAEwePy2ZM7L9nwIby+XZDhKPOxTXh6JZ0xeXtAbgp53sE7Io35O4zpvBTrlF/kgD8eXTswB+rQB3VowvgAn/enLkCoElcppltn3mKrKifUQISg5q5AUoz8FdOmAOr9HsXl+EQZsbHp6jaIqvlfOJzRV0lorNUnnGZyJrBF5pVCUwWH9EHRr++wRgPWYnlQCKOWsJWuBDkD15B5veIeuqaiu2RuDOS+s1i4/F8pO5efv1shIKYwcnEx5WWVN9zAvMlVG7A2PY4SU0rFe7DEDQXj8PkKZ2rMtQGdw5LiUcopxL0ArOSq11j6dRqDP6TGDLe3g1ZWj9wG9wnz6Peb7c2RcOUCpD/2uJzZXd8YJS4WABXSltiJplgJVWCN0rzdwUGoA6EG271qUUS5TYjzFdu87t77vQ3f/l6P3tfQ1QFeaQlLWnDDmFn1sLOnzamGbsHkUpKSwnPQlszpOKMfAFSOP51AKGw3dezXPXNEXphzwe/GZsRLnywX7FGgkLZXspE27ZAvQcT9CVnwCAIwss/Xl0TydZgz1IouzAnQ6DyfybWkQ2QV0626euBzkbXWh1rrPAb2iBmmoNABPtMmjs6iYcspIXEzdcI1gFKvhgneiYBR1SXed+1Qup+lDwz4RypbXWTqW3qPLmytfr/PXAB2oKGk18yjbWadeRgM3Z5z6nJlhKC7CtYrgQ1jpTSCAb+xjo0ZvDHVxYeXHzrre8OBacC69MOwMGD5FlPLBjfzctcZbgK7yIJWSNjD8oxQjr0LTGwL6CEDy0ZOuoy/VM8cpAYu6ALeM/y6gFwknagX4cd92lde8b4FRtFYMId5gtUc3aLXzIs9cYF/DTL8gACBUVztnqcpgzJFS42IKR0UUmjUoYPXYC1GQHPu6kup6QkU5VIFbTtNHCI5bA/S+cUV+aZ5jtyAGHJnCGNhAHln5xWaUh9qVnwMQMMjH3a8aWCqqUhcvJRpJP0qlsaMXnp6RqMhgiiUGcL0KBNEof8ZjGOdxldfUiRk3TUt0YqrEWow8z9a3fJ6Fh1p4WfOjX32T0RzQeXNEnRQFh/TG97l1m7cL6GUkGGWpn2hpE9ABCoFD5vLMKWvnhkJ24Sjl7JnzvtlD3giAct5RmXggpJnQRH5arCbgsJpVWvi6RmRoBpkSSq5JZBeTvAbofflpqnHFGBhHRrKMJcsLkGr/8jZj7XsE+vyccRBiy9fkskpvyjPSHRuK/JOX+R2xabM17PDIPLHSzV8NC9FHIdXcM4KsXtboVEQSBUQSUVrGemp913r0UkxG2z2mpKI4dWdEVslZALq0VEPM2EAzB3T8EyekLGuuU85rF9CrlZg+2Hu6vgnoyCJ0PyWqzrSpd4JhAXkYkyRqpD7j7YQiPTEltJQvEjmMsBfJJyQTohPkFgVDBlHMvo3V99o5WT8sJRDxPnOPzjIm7slTzCn5UqD34a1xzD1fLJwyLoJhBnDhspbXei6+96DGpwyntq8PGjA9EMPzVXhr7NbN58JukRHWtTfGc7380oACFnbe772ojoggKmKzrkp1lEadneGaUsI1QC/vxXPx5nNttfUQCNJV2nKWgC7S8nKN/gUbBUbGstcX66E5iU6IMqceYjL3fZ1xojROVaQovdkEdDfq81sbO/b2ClPrpYEUlqeySRSwjgU2jS48Pc8gb6eogIMNp1T18AlPIycF9P5Jsx48wKBH2wJRTv+fk3pbie8ZlOoA649fCnS5V1lrUQLQjq80YlU1BNnUMgbWQv2/f3li34EGzFpW5doYWGsjcumfNcAt+KEw+JJqOrL2yEUy9eDDSLJNddXpnqMs1TOBqKNgeBFNQXNvdl0DdN7LWBk8xp2O6ABkrCoN4bXtM88/Puyy5J1x1oCuIVrPxxtmpnRw7q011k53nOpNObip8/cBHf5EmaI+qcNmoCvZyJEpMIKBQvYCbN/WfSCkpEzFJvtqzCN9psxF+SnZ2GwwElOO7xtC/O4+cpt9rbDCa6ASHgPfFBG4FOh9c8tc84/QW6MRUBNdaaIglrceaPE54m1ktYXc0pKqt/fhtHyZd+DNgYH0DS7WQ6vsuJYabnj6uRKe61AS6YJXeNfaIhw9VzCXnztuKdCNm564j38BEZjNj6HXAcaY1CuXrC0A9F5uTeg+95z7FJD6z476KqmlQJcS0SU8xFyffF1rH9BxKPRIzwNjuhnoblheXVlrfHkDT0yxbbqnnRBB9fx3P3GKxiM5nuIJ0YCPx5Gz2XDKaqD946d1DWERUPMw7mNy48Mf40IzIvq4hclz3tw5S4Du/nItaQOCz/3nHqSRsthIoZSGFGsyPqnEcBp/PesvTGXh+4jJMXoZgBWZZ52qd964AaP4DZGQdRsfwbXuauaajFzDMVMNRyIo6QPAacFkvOfCyVrnpUAXVVljxm384wLSFMaYgSOMnAgImdnLGqBv/QswJwF0KZhoQ3iP/9pHKpeD2/WYKoCLkkSD9g6W5t7rvvN1z32eK0zslc1mAJTuHF5n3Mh+s+Thmj+Ea304KEdkAEx+1zu7eQZlOgo4l+P196vwWNrAQMw9S78E6K5rnH7IvhftS2GMlzGb6+QDZOmMTdHNNrXp9YILHMTUm08ZIDLmhv06LDmmDIe1XfLAkeOXAF3UoczK2Eyxyq6jLKTubJ2kK/ZrXIsLBegqNeM762uvOD8enLGnD/RHJIiUls6O7cJ1Hp3kgHh3PFkfOTpGiiyachwnea53Ye4POLAsvAcg80Jr+81Hb3vo39WuRSLCJDlv3+o53nsp0A895rN2/X1AZ2CkGgjdXSGq47STylXn+IACulSoOs6m1os38/iynzV/1cW16h4Iz+N6kePaKIFhR+R6/oHzJCJdhPZU38Fmndn1l1rq0UylNmHe2oXcPKiVJ4oahDJIJUqBUd4lPdCn3rm18vYXzeH73uvOIagk9Oz51sXBfXidMo+0izfYev0COh4K0ek9CEv/vNSue64Fel3LXHExdFj5TES0L4pcNfd9f5JJ7oZQUcM9jX+ppRpRMMj66sdW0KnF6IHuxRDCfLlirYUS05j7rlrUC+RgrG6vH7znD7a5rf1LLRfIkuydBqDDi74I5Ns+3qO/IFJblUo0dOxOdR/QDQShg31XFhtf4rB35gc8gCdXIdAvreFi6d9eQxIp+9Tc5dVynXqTKgKlXjRwwOGf6ktXg095FTk0zqX667H9uh+X/u21Uz3Zi2FwS4BuHTCpmGx5u+6e0yA6jORZSLg1T7hhpudSEQqNMVdnvphFpOQ1WXMsMcMoRTrW8PJiXvBDz30p0I2D55xrPT30OKeuj8iYevfc+RjLpXteWoFTvQJvADu3IH2d18kKAAAAAElFTkSuQmCC" style="margin-top:0;margin-bottom:0;"></span></span></span>(“img”).get(0);</p></li>
<li><p>$ 就是jquery对象</p></li>
<li><p>divs.eq(数字)  div中的第某个元素，是个jquery对象</p></li>
<li><p>index(‘缩小范围’)  自动去找某个元素基于父级的子级为第几个元素</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">//给所有按钮加点击事件函数</span>
</div><div class="hljs-line">    btns.click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">        <span class="hljs-comment">//当点击某个按钮的时候把所有的active清空</span>
</div><div class="hljs-line">        btns.removeClass(<span class="hljs-string">'active'</span>);
</div><div class="hljs-line">        <span class="hljs-comment">//把所有div中的show清空</span>
</div><div class="hljs-line">        divs.removeClass(<span class="hljs-string">'show'</span>);
</div><div class="hljs-line">        <span class="hljs-comment">//当前按钮的class名变成active</span>
</div><div class="hljs-line">        $(<span class="hljs-keyword">this</span>).addClass(<span class="hljs-string">'active'</span>);
</div><div class="hljs-line">        <span class="hljs-comment">//让div中个对应按钮索引的div的className换成show</span>
</div><div class="hljs-line">        divs.eq($(<span class="hljs-keyword">this</span>).index(<span class="hljs-string">'button'</span>)).addClass(<span class="hljs-string">'show'</span>);
</div><div class="hljs-line">    });
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// btns.click(function(){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     $(this).addClass('active').siblings().removeClass('active');</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     divs.eq($(this).index()).addClass('show').siblings().removeClass('show');</span>
</div><div class="hljs-line">    <span class="hljs-comment">// });</span>
</div></code></pre>

<ul><li><p>prop 复选框使用 <br>
<code>$('li').each(function(i,ele){   })</code></p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">all.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">        $(<span class="hljs-string">'input'</span>).prop(<span class="hljs-string">'checked'</span>,<span class="hljs-literal">true</span>);
</div><div class="hljs-line">    }
</div><div class="hljs-line">    no.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">        $(<span class="hljs-string">'input'</span>).prop(<span class="hljs-string">'checked'</span>,<span class="hljs-literal">false</span>);
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    reverse.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">        $(<span class="hljs-string">'input'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i,ele</span>)</span>{ <span class="hljs-comment">//ele是原生对象</span>
</div><div class="hljs-line">            <span class="hljs-comment">// console.log(ele)</span>
</div><div class="hljs-line">            <span class="hljs-comment">//获取当前input的checked，返回布尔值</span>
</div><div class="hljs-line">            <span class="hljs-keyword">if</span>( $(ele).prop(<span class="hljs-string">'checked'</span>) ){
</div><div class="hljs-line">                $(ele).prop(<span class="hljs-string">'checked'</span>,<span class="hljs-literal">false</span>);
</div><div class="hljs-line">            }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">                $(ele).prop(<span class="hljs-string">'checked'</span>,<span class="hljs-literal">true</span>);
</div><div class="hljs-line">            }
</div><div class="hljs-line">        });
</div><div class="hljs-line">    }
</div></code></pre>



<h3 id="jquery框架">jquery框架</h3>

<blockquote>
  <p>不带min为学习版，可以去看里面的代码 <br>
  <a href="http://jquery.cuishifeng.cn/jQuery_selector_context.html" target="_blank">http://jquery.cuishifeng.cn/jQuery_selector_context.html</a></p>
</blockquote>

<ul><li><p>匿名函数自执行,为了不让外界的代码影响到里面的代码(函数内的代码不受外界干扰)，但是，这样做外界就拿不到里面的函数了，所以jQ做了一件事，把jQuery挂在了window下，外界就能使用，return把变量挂全局</p></li>
<li><p>无new化操作，不在外面new,在里面new</p></li>
<li><p>不new自己，new了个其他函数，这个其他函数又拥有，jquery函数原型下的所有方法</p></li>
<li><p>链式调用 <br>
<code>$('li').css('width','200px').css('height','200px');</code></p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">global,factory</span>)</span>{
</div><div class="hljs-line">        factory(global);
</div><div class="hljs-line">        <span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">            判断是否为window环境下，如果不是undefined那么当前</span>
</div><div class="hljs-line"><span class="hljs-comment">            环境就是window，否则为this</span>
</div><div class="hljs-line"><span class="hljs-comment">        */</span>
</div><div class="hljs-line">    })(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">'undefined'</span>?<span class="hljs-built_in">window</span>:<span class="hljs-keyword">this</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">global,noGlobal</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-comment">//noGlobal 为undefined，因为在低版本下undefined会被修改,函数不传参一定是undefined</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">            如果自己调用自己，就递归了</span>
</div><div class="hljs-line"><span class="hljs-comment">            如何才能让其不递归呢？</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">            1.不自己调用自己就不会递归</span>
</div><div class="hljs-line"><span class="hljs-comment">            2.还能使用jQuery原型上的方法</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">            {</span>
</div><div class="hljs-line"><span class="hljs-comment">                0:xxx,</span>
</div><div class="hljs-line"><span class="hljs-comment">                1:xxx,</span>
</div><div class="hljs-line"><span class="hljs-comment">                length:2</span>
</div><div class="hljs-line"><span class="hljs-comment">            }</span>
</div><div class="hljs-line"><span class="hljs-comment">        */</span>
</div><div class="hljs-line">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jQuery</span>(<span class="hljs-params">selector</span>)</span>{
</div><div class="hljs-line">           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> jQuery.fn(selector);
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        jQuery.fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>)</span>{
</div><div class="hljs-line">            <span class="hljs-keyword">let</span> ele = <span class="hljs-built_in">document</span>.querySelectorAll(selector);
</div><div class="hljs-line">            <span class="hljs-comment">// console.log(ele);</span>
</div><div class="hljs-line">            <span class="hljs-comment">//循环获取的元素，把每个元素挂在实例上</span>
</div><div class="hljs-line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;ele.length;i++){
</div><div class="hljs-line">                <span class="hljs-keyword">this</span>[i] = ele[i];
</div><div class="hljs-line">            }
</div><div class="hljs-line">            <span class="hljs-keyword">this</span>.length = ele.length;
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        jQuery.prototype.trim = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>)</span>{
</div><div class="hljs-line">            <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/^\s+|\s+$/g</span>,<span class="hljs-string">''</span>);
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        jQuery.prototype.css = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">            <span class="hljs-keyword">let</span> arg = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
</div><div class="hljs-line">            <span class="hljs-comment">//如果参数为2个，就是设置，有可能是批量设置</span>
</div><div class="hljs-line">            <span class="hljs-keyword">if</span>(arg.length === <span class="hljs-number">2</span>){
</div><div class="hljs-line">                <span class="hljs-comment">//循环this的每一项</span>
</div><div class="hljs-line">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">this</span>.length;i++){
</div><div class="hljs-line">                    <span class="hljs-comment">//把每项的样式设置成参数值即可</span>
</div><div class="hljs-line">                    <span class="hljs-keyword">this</span>[i].style[arg[<span class="hljs-number">0</span>]] = arg[<span class="hljs-number">1</span>];
</div><div class="hljs-line">                }
</div><div class="hljs-line">            }
</div><div class="hljs-line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
</div><div class="hljs-line">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'进了css'</span>);
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">            让 jQuery.fn.prototype 等于 jQuery.prototype</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">            当new jQuery.fn 这个实例时上面就有 jQuery原型下的所有方法</span>
</div><div class="hljs-line"><span class="hljs-comment"></span>
</div><div class="hljs-line"><span class="hljs-comment">        */</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        jQuery.fn.prototype = jQuery.prototype;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">// 把jQuery暴露到了全局</span>
</div><div class="hljs-line">        global.jQuery  = global.$ = jQuery;
</div><div class="hljs-line">    });
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> jQuery = <span class="hljs-number">10</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">// var lis = new $('li');  //$是个函数名</span>
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> lis = $(<span class="hljs-string">'li'</span>); <span class="hljs-comment">//不想在外面new</span>
</div><div class="hljs-line">    lis.css(<span class="hljs-string">'background'</span>,<span class="hljs-string">'red'</span>).css(<span class="hljs-string">'width'</span>,<span class="hljs-string">'200px'</span>);
</div></code></pre>



<h3 id="jquery版dom">jquery版DOM</h3>

<ul><li><p>append 后添加</p></li>
<li><p>remove</p></li>
<li><p>prepend(content)  前添加</p></li>
<li><p>sibilings(‘设置范围’) 兄弟</p></li>
<li><p>parent()</p></li>
<li><p>children</p></li>
<li><p><code>$('&lt;li&gt;&lt;/li&gt;')</code> 添加</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">$(<span class="hljs-string">'#txt'</span>).keyup(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(ev.keyCode === <span class="hljs-number">13</span>){
</div><div class="hljs-line">           <span class="hljs-keyword">let</span> val = $(<span class="hljs-string">'#txt'</span>)[<span class="hljs-number">0</span>].value;
</div><div class="hljs-line">        <span class="hljs-comment">//    $('#ul').append($('&lt;li&gt;'+val+'&lt;/li&gt;'));</span>
</div><div class="hljs-line">           $(<span class="hljs-string">'#ul'</span>).prepend($(<span class="hljs-string">'&lt;li&gt;'</span>+val+<span class="hljs-string">'&lt;/li&gt;'</span>));
</div><div class="hljs-line">           $(<span class="hljs-string">'#txt'</span>).val(<span class="hljs-string">''</span>);
</div><div class="hljs-line">        }
</div><div class="hljs-line">    });
</div></code></pre>



<h3 id="jquery版事件">jquery版事件</h3>

<blockquote>
  <p>jq中所有的事件都为事件绑定</p>
</blockquote>

<ul><li><p>click,mousedown…    都有on()二次封装</p></li>
<li><p>on(‘不带On的事件名’,’事件源元素’,事件函数)  事件委托</p></li>
<li><p>解绑为off(‘click.aa’)</p></li>
<li><p>jq中的ev是二次封装的对象</p></li>
<li><p>ev.originalEvent  原生事件对象</p></li>
<li><p>事件的冒泡和事件的阻止默认行为：return false;</p></li>
<li><p>trigger()</p></li>
<li><p>delegate 的原理 <br>
<code>事件委托 ——&gt;  $('ul').on('click','li',function(){})</code></p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">// $('li').on('click',function(){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     $(this).css('background','red');</span>
</div><div class="hljs-line">    <span class="hljs-comment">// });</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">// $('ul').on('click','li',function(){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     $(this).css('background','red');</span>
</div><div class="hljs-line">    <span class="hljs-comment">// })</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">$(<span class="hljs-string">'#btn'</span>).on(<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">     alert(<span class="hljs-number">1</span>);
</div><div class="hljs-line"> });
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"> <span class="hljs-comment">//在移入box的时候，让btn的点击事件调用</span>
</div><div class="hljs-line"> $(<span class="hljs-string">'#box'</span>).mouseover(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">     $(<span class="hljs-string">'#btn'</span>).trigger(<span class="hljs-string">'click'</span>);
</div><div class="hljs-line"> });
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    $(<span class="hljs-string">'#box'</span>).on(<span class="hljs-string">'mouseover'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-built_in">console</span>.log(ev);
</div><div class="hljs-line">        $(<span class="hljs-keyword">this</span>).css(<span class="hljs-string">'background'</span>,<span class="hljs-string">'red'</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">//在绑定click之前，解除上次click，触发的时候始终就一个</span>
</div><div class="hljs-line">        $(<span class="hljs-string">'button'</span>).off(<span class="hljs-string">'click.bbb'</span>);
</div><div class="hljs-line">        $(<span class="hljs-string">'button'</span>).on(<span class="hljs-string">'click.bbb'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'请求'</span>);
</div><div class="hljs-line">        });
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        $(<span class="hljs-string">'button'</span>).on(<span class="hljs-string">'click.aaa'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'请求2'</span>);
</div><div class="hljs-line">        });
</div><div class="hljs-line">    })
</div><div class="hljs-line">    $(<span class="hljs-string">'#box'</span>).on(<span class="hljs-string">'mouseout'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">        $(<span class="hljs-keyword">this</span>).css(<span class="hljs-string">'background'</span>,<span class="hljs-string">'#000'</span>);
</div><div class="hljs-line">    });
</div><div class="hljs-line"><wbr>
</div></code></pre>



<h3 id="jquery插件接口">jquery插件接口</h3>

<ul><li><p>工具方法:$.  </p>

<ul>
<li><p>$.ajax()</p></li>
<li><p>$.each()</p></li>
<li><p>$.isArray()</p>

<blockquote>
  <p>不只JQ对象能使用，还可以处理一些原生的数据</p>
</blockquote></li></ul></li>
<li><p>工具方法扩展:</p>

<ul>
<li><p>$.extend({})  </p></li></ul></li>
<li><p>功能方法: $(‘#box’).css();</p>

<ul>
<li><p>只能是jQ对象才能使用</p>

<ul>
<li><p>$.fn.extend({})</p></li></ul></li></ul></li>
<li><p>$.extend();</p>

<ul>
<li><p>1.浅拷贝 -&gt; Object.assign()</p></li>
<li><p>2.深拷贝 -&gt; deepClone</p></li>
<li><p>3.插件接口</p></li></ul></li>
</ul>



<h3 id="jquery运动">jquery运动</h3>

<blockquote>
  <p>$(‘#box’).animate({})  所有的运动都是animate二次封装的</p>
</blockquote>

<ul><li><p>显示隐藏</p>

<ul>
<li><p>show()  block</p></li>
<li><p>hide()  none</p></li>
<li><p>toggle</p></li></ul></li>
<li><p>改变高度</p>

<ul>
<li><p>slideDown</p></li>
<li><p>slideUp</p></li>
<li><p>slideToggle</p></li></ul></li>
<li><p>淡入淡出</p>

<ul>
<li><p>fadeIn</p></li>
<li><p>fadeOut</p></li>
<li><p>fadeToggle</p></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">// $('#box').animate({</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     width:100,</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     height:200,</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     fontSize:50</span>
</div><div class="hljs-line">    <span class="hljs-comment">// },2000,function(){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     console.log('玩完');</span>
</div><div class="hljs-line">    <span class="hljs-comment">// });</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    $(<span class="hljs-built_in">document</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">        <span class="hljs-comment">// $('#box').hide(1000);</span>
</div><div class="hljs-line">        <span class="hljs-comment">// $('#box').slideUp(200);</span>
</div><div class="hljs-line">        $(<span class="hljs-string">'#box'</span>).fadeOut(<span class="hljs-number">200</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    });
</div></code></pre>



<h3 id="订阅模式">订阅模式</h3>

<blockquote>
  <p>订阅就是一个收集器，收集事件名和函数，当某个条件成立的时候，批量执行函数</p>
</blockquote>

<ul><li><p>订阅模式 <br>
<code>document.addEventListener('click',fn);</code></p></li>
<li><p>发布模式：真的点击document</p>

<ul>
<li><p>当某个条件成立的时候发布 <br>
<code>document.dispatch(ev);</code></p></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">let</span> event = <span class="hljs-built_in">document</span>.createEvent(<span class="hljs-string">'HTMLEvents'</span>)  创建一个事件对象
</div><div class="hljs-line"><span class="hljs-comment">//初始化，事件类型，是否冒泡，是否阻止浏览器的默认行为</span>
</div><div class="hljs-line">event.initEvent(<span class="hljs-string">'事件名'</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>) 初始化事件
</div><div class="hljs-line">element.dispatchEvent(event) 发布
</div></code></pre>



<h1 id="es6">ES6</h1>



<h3 id="解构赋值用于对象或者数组">解构赋值：用于对象或者数组</h3>



<h5 id="什么是变量">什么是变量:</h5>

<ul><li><p>把js中的数据存储到一个自定义的名字中，可以为一个数组也可以为一个对象。</p>

<ul>
<li><p>这个名字可变</p></li>
<li><p>目的:为了复用</p></li></ul></li>
</ul>



<h4 id="数组解构申明一个数组把变量放到数组中变量数组的索引就对应赋值数组的索引赋值别的数据就报错">数组解构：申明一个数组，把变量放到数组中，变量数组的索引就对应“赋值数组”的索引。赋值别的数据就报错</h4>

<ul><li><p>变量数组中是可以设置默认值，用=设置</p>

<ul>
<li><p>什么时候会用到默认值呢？</p>

<ul>
<li><p>1.赋值没数据  let [a=1] = [];  1</p></li>
<li><p>2.赋值为undefined的时候 </p></li></ul></li></ul></li>
<li><p>[] 数组 下标</p>

<ul>
<li><p>[任意一个]</p></li>
<li><p>[1,2,3][0]=&gt;1</p></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">let</span> [a,b] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-keyword">let</span> [a,b,c] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];
</div><div class="hljs-line">c = ?  <span class="hljs-literal">undefined</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-keyword">let</span> [,,c] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// let arr =  [1,2,3,[5,6,[7,[[[[[9]]]]]]]];</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> [a,b,c,[d,e,[f,[[[[[g]]]]]]]] =  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,[<span class="hljs-number">7</span>,[[[[[<span class="hljs-number">9</span>]]]]]]]];
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-built_in">console</span>.log(g);
</div><div class="hljs-line">    <span class="hljs-comment">// console.log(arr[3][2][1][0][0][0][0][0]);</span>
</div></code></pre>



<h4 id="对象解构值为对象变量也是对象变量对象的名字默认要是对象属性的名字">对象解构：值为对象，变量也是对象，变量对象的名字默认要是对象属性的名字</h4>

<ul><li><p>下面的a和b都是对象的属性名 <br>
<code>let {a,b} = { <br>
        a:1, <br>
        b:2 <br>
    }</code></p></li>
<li><p>c直接代表了a，此时访问a是会报错的，因为a的值已经给了c</p>

<ul>
<li><p>访问c其实就是访问a了，改名字使用：号 <br>
<code>let {a:c,b:d} = { <br>
    a:1, <br>
    b:2 <br>
}</code></p></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">let</span> {<span class="hljs-attr">width</span>:w,<span class="hljs-attr">height</span>:h,<span class="hljs-attr">fontSize</span>:fz} = getComputedStyle(body);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">// console.log(w,h,fz);</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">// console.dir(console);</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> {log,dir} = <span class="hljs-built_in">console</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">// log(1);</span>
</div><div class="hljs-line">    dir(<span class="hljs-built_in">Array</span>);
</div></code></pre>



<h2 id="iterator-和-forof-循环">Iterator 和 for…of 循环</h2>



<h3 id="for-of进行循环">for of进行循环</h3>

<ul><li><p>在ES6中添加了别的数据结构(Set,Map)，他们都需要循环，所以专门通过for of来遍历这些数据结构（循环的统一标准）</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs fsharp"><div class="hljs-line">    <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> <span class="hljs-keyword">val</span> <span class="hljs-keyword">of</span> arr){
</div><div class="hljs-line">        console.log(<span class="hljs-keyword">val</span>); <span class="hljs-comment">//1,2,3,4</span>
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div></code></pre>

<ul><li><p>如果使用for of循环的时候要获取数据的键值，那么可以借助数组的keys() 获取键 ,values() 获取值,entries() 获取键值对</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs fsharp"><div class="hljs-line"><wbr>
</div><div class="hljs-line">    这三个方法的返回值都是一个Iterator对象，可以通过next()去调用继续执行
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
</div><div class="hljs-line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key,<span class="hljs-keyword">val</span>] <span class="hljs-keyword">of</span> arr.entries()){
</div><div class="hljs-line">        console.log(key,<span class="hljs-keyword">val</span>);  <span class="hljs-comment">//key为下标，val为值</span>
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div></code></pre>



<pre class="prettyprint hljs-dark"><code class="hljs xquery"><div class="hljs-line">    对象默认不能进行<span class="hljs-keyword">for</span> <span class="hljs-keyword">of</span>循环，因为没有遍历器。
</div><div class="hljs-line">    以下代码会报错
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> obj = {
</div><div class="hljs-line">         name:<span class="hljs-string">'林同贺'</span>,
</div><div class="hljs-line">         age:<span class="hljs-number">81</span>
</div><div class="hljs-line">    }
</div><div class="hljs-line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> attr <span class="hljs-keyword">of</span> obj){
</div><div class="hljs-line">         console.log(attr);
</div><div class="hljs-line">    }
</div></code></pre>



<h3 id="set">set</h3>

<blockquote>
  <p>ES6 提供了新的数据结构 Set。它类似于数组， <br>
      但是成员的值都是唯一的，没有重复的值 <br>
      size就等同于length</p>
</blockquote>

<pre class="prettyprint hljs-dark"><code class="hljs sql"><div class="hljs-line">add(value)：添加某个值，返回 <span class="hljs-keyword">Set</span> 结构本身。
</div><div class="hljs-line"><span class="hljs-keyword">delete</span>(<span class="hljs-keyword">value</span>)：删除某个值，返回一个布尔值，表示删除是否成功。
</div><div class="hljs-line">has(<span class="hljs-keyword">value</span>)：返回一个布尔值，表示该值是否为<span class="hljs-keyword">Set</span>的成员。
</div><div class="hljs-line"><span class="hljs-keyword">clear</span>()：清除所有成员，没有返回值。
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">let s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Set</span>();  //<span class="hljs-keyword">set</span>{}
</div><div class="hljs-line">s.add(<span class="hljs-string">'1'</span>); //添加一个数据 //<span class="hljs-keyword">set</span>{<span class="hljs-string">'1'</span>}
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">let s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]);  //<span class="hljs-keyword">set</span>{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>}
</div></code></pre>



<pre class="prettyprint hljs-dark"><code class="hljs lsl"><div class="hljs-line"><wbr>
</div><div class="hljs-line">    写出一个方法join([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])找出交集 <span class="hljs-comment">//[2,3]</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    function join(a,b){
</div><div class="hljs-line">        let s = new Set(a);
</div><div class="hljs-line">        return b.filter(e=&gt;s.has(e));
</div><div class="hljs-line">    }
</div><div class="hljs-line">    console.log(join([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])); <span class="hljs-comment">//[2,3]</span>
</div></code></pre>



<h3 id="map">Map</h3>

<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 <br>
    let m = new Map(); <br>
    m.set(ele,’哈哈’); <br>
    console.log(m.get(ele));</p>



<h3 id="iterator-遍历器只要数据中有symboliterator就能使用for-of">Iterator ,遍历器，只要数据中有Symbol.iterator就能使用for of</h3>

<pre class="prettyprint hljs-dark"><code class="hljs ocaml"><div class="hljs-line">遍历接口返回一个对象，对象中有一个next方法
</div><div class="hljs-line">这个方法必须return对象，在这个对象下有<span class="hljs-number">2</span>个属性
</div><div class="hljs-line"><span class="hljs-keyword">value</span>，<span class="hljs-keyword">done</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-keyword">value</span>就是<span class="hljs-keyword">for</span> <span class="hljs-keyword">of</span>中的attr
</div><div class="hljs-line"><span class="hljs-keyword">done</span>:为<span class="hljs-literal">true</span>的时候不遍历
</div><div class="hljs-line"><span class="hljs-keyword">done</span>:为<span class="hljs-literal">false</span>的时候遍历
</div></code></pre>

<blockquote>
  <p>当使用for of的时候，内部会调用next方法，只要next的返回值done为false就一直调用next，直到为true就不调用next方法了</p>
</blockquote>



<h3 id="promise">promise</h3>

<ul><li><p>promise解决把异步编程转成同步编程的，也就是让代码从上往下阅读即可。</p></li>
<li><p>有三种状态，pending（初始化）、fulfilled（成功）、rejected（失败）</p>

<blockquote>
  <p>怎么用？ <br>
  只要是嵌套多个回调函数就可以使用promise进行异步请求的时候使用 fetch <br>
  <code>let p = new Promise((resolve,reject)=&gt;{ <br>
          resolve(); <br>
      }) <br>
  p.then(()=&gt;{ <br>
    执行这句话，resolve一定调用了 <br>
  });</code></p>
</blockquote></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line">    <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span>  <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>{
</div><div class="hljs-line">        <span class="hljs-comment">//放异步代码</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-comment">//当异步代码执行完成手动调用resolve或者reject</span>
</div><div class="hljs-line">    })
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    返回值为一个promise对象
</div><div class="hljs-line">    在promise对象下有几个方法
</div><div class="hljs-line">    .then(fn1,fn2)  
</div><div class="hljs-line">        fn1代表异步代码执行成功之后的回调
</div><div class="hljs-line">        fn2代表异步代码执行失败之后的回调
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    .catch(异步代码执行失败之后的回调)
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"> <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{})
</div><div class="hljs-line"> <span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{})
</div><div class="hljs-line"> <span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{})
</div><div class="hljs-line"> <span class="hljs-built_in">Promise</span>.all([p1,p2,p3])
</div><div class="hljs-line">（<span class="hljs-number">1</span>）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">（<span class="hljs-number">2</span>）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">代码如下：
</div><div class="hljs-line"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>{
</div><div class="hljs-line">            resolve(<span class="hljs-number">1</span>);
</div><div class="hljs-line">            reject(<span class="hljs-number">2</span>);
</div><div class="hljs-line">        });
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        p.then(<span class="hljs-function">(<span class="hljs-params">val</span>)=&gt;</span>{
</div><div class="hljs-line">            <span class="hljs-built_in">console</span>.log(val)
</div><div class="hljs-line">        },(val2)=&gt;{
</div><div class="hljs-line">            <span class="hljs-built_in">console</span>.log(val2)
</div><div class="hljs-line">        })
</div><div class="hljs-line"><wbr>
</div></code></pre>



<h2 id="generator">Generator</h2>

<ul><li><p>特征一：function关键字与函数名之间有一个星号；</p></li>
</ul>

<blockquote>
  <p>function* fn(){}</p>
</blockquote>

<ul><li><p>特征二：函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">    <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;
</div><div class="hljs-line">    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
</div><div class="hljs-line">}
</div><div class="hljs-line"><wbr>
</div></code></pre>

<ul><li><p>Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line">    <span class="hljs-comment">//当前这个fn是一个暂缓执行的函数，一开始是不执行的，只有调用了next方法才执行函数内的代码</span>
</div><div class="hljs-line">    <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);
</div><div class="hljs-line">    }
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> f = fn();
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
</div><div class="hljs-line">        f.next();
</div><div class="hljs-line">    },<span class="hljs-number">1000</span>)
</div><div class="hljs-line"><wbr>
</div></code></pre>

<blockquote>
  <p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>
</blockquote>



<h4 id="yield做了2件事">yield做了2件事</h4>

<blockquote>
  <p>1.给value设置值  {value:0,done:false}</p>
  
  <p>2.给reset返回了一个undefined</p>
</blockquote>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
</div><div class="hljs-line">  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
</div><div class="hljs-line">  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
</div><div class="hljs-line">  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>
</div><div class="hljs-line">  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>
</div><div class="hljs-line">}
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// 扩展运算符</span>
</div><div class="hljs-line">[...numbers()] <span class="hljs-comment">// [1, 2]</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// Array.from 方法</span>
</div><div class="hljs-line"><span class="hljs-built_in">Array</span>.from(numbers()) <span class="hljs-comment">// [1, 2]</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// 解构赋值</span>
</div><div class="hljs-line"><span class="hljs-keyword">let</span> [x, y] = numbers();
</div><div class="hljs-line">x <span class="hljs-comment">// 1</span>
</div><div class="hljs-line">y <span class="hljs-comment">// 2</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// for...of 循环</span>
</div><div class="hljs-line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> numbers()) {
</div><div class="hljs-line">  <span class="hljs-built_in">console</span>.log(n)
</div><div class="hljs-line">}
</div><div class="hljs-line"><span class="hljs-comment">// 1</span>
</div><div class="hljs-line"><span class="hljs-comment">// 2</span>
</div></code></pre>

<ul><li><p>第一步，协程A开始执行。</p></li>
<li><p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p></li>
<li><p>第三步，（一段时间后）协程B交还执行权。</p></li>
<li><p>第四步，协程A恢复执行。</p></li>
</ul>



<h1 id="html5-css3-移动端">html5 + css3 + 移动端</h1>



<h3 id="html5的标签公司中对h5的理解就是移动端">html5的标签（公司中对H5的理解就是移动端）</h3>

<ul><li><p>设计理念:</p></li>
<li><p>我们采用两种设计理念来规划我们的网站</p></li>
<li><p>渐进增强 (progressive enhancement) :</p>

<ul>
<li><p>一开始只构建站点的最少特性,然后不断的针对浏览器追加功能</p></li></ul></li>
<li><p>优雅降级 (graceful degradation) :</p>

<ul>
<li><p>一开始就构建站点的完整功能,然后针对浏览器测试和修复</p></li></ul></li>
</ul>



<h3 id="块元素行内元素行内块元素">块元素/行内元素/行内块元素</h3>



<pre class="prettyprint hljs-dark"><code class="hljs css"><div class="hljs-line">块:（独占一行,自上而下排列）
</div><div class="hljs-line">   <span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">li</span>,<span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">h1--h6</span>,<span class="hljs-selector-tag">dl</span>  <span class="hljs-selector-tag">dt</span>  <span class="hljs-selector-tag">dd</span> <span class="hljs-selector-tag">table</span>  <span class="hljs-selector-tag">form</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">行内元素(内联元素)<span class="hljs-selector-pseudo">:(</span>不独占一行,不能设置宽高)
</div><div class="hljs-line">   <span class="hljs-selector-tag">span</span>  <span class="hljs-selector-tag">a</span>   <span class="hljs-selector-tag">label</span>  <span class="hljs-selector-tag">em</span> <span class="hljs-selector-tag">i</span>  <span class="hljs-selector-tag">b</span>  <span class="hljs-selector-tag">strong</span>  <span class="hljs-selector-tag">br</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">行内块元素:（既能设置宽高又不能独占一行）
</div><div class="hljs-line">   <span class="hljs-selector-tag">input</span>  <span class="hljs-selector-tag">img</span>  <span class="hljs-selector-tag">textarea</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">块元素转行内元素:
</div><div class="hljs-line">   <span class="hljs-selector-tag">display</span><span class="hljs-selector-pseudo">:inline</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">行内元素转块元素:
</div><div class="hljs-line">   <span class="hljs-selector-tag">display</span><span class="hljs-selector-pseudo">:block</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">元素转行内块元素:
</div><div class="hljs-line">    <span class="hljs-selector-tag">display</span><span class="hljs-selector-pseudo">:inline-block</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-selector-tag">margin</span>  
</div><div class="hljs-line">   外边距  
</div><div class="hljs-line">       重叠:
</div><div class="hljs-line">           2个元素都加<span class="hljs-selector-tag">margin</span>值重叠的时候会取最大值
</div><div class="hljs-line">       塌陷:
</div><div class="hljs-line">           一个父元素里面嵌套了一个子元素，给子元素加<span class="hljs-selector-tag">margin-top</span>值，想让子元素和父元素有一个距离，但是子元素没有与父元素分离，反而是子元素把<span class="hljs-selector-tag">margin-top</span>值传递给了父元素，一起出现了下移。
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">           解决方案:
</div><div class="hljs-line">               1.加有值的<span class="hljs-selector-tag">border</span>
</div><div class="hljs-line">               2.给父级加上 <span class="hljs-selector-tag">overflow</span>: <span class="hljs-selector-tag">hidden</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-selector-tag">padding</span>  
</div><div class="hljs-line">   内边距
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-selector-tag">float</span>
</div><div class="hljs-line">   解决浮动问题:
</div><div class="hljs-line">       1. 给父级加高度，但是有个弊端就是，子级占的高度不能超出父级高度
</div><div class="hljs-line">       2. 给最后一个浮动元素下添加一个空的元素，并且这个元素的样式为
</div><div class="hljs-line">           <span class="hljs-selector-tag">clear</span>: <span class="hljs-selector-tag">both</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">       3<span class="hljs-selector-class">.overflow</span><span class="hljs-selector-pseudo">:hidden</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">       4.添加伪元素
</div><div class="hljs-line">           <span class="hljs-selector-class">.c</span><span class="hljs-selector-pseudo">::after</span>{
</div><div class="hljs-line">               <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;
</div><div class="hljs-line">               <span class="hljs-attribute">clear</span>: both;
</div><div class="hljs-line">               <span class="hljs-attribute">display</span>: block;
</div><div class="hljs-line">           }
</div><div class="hljs-line"><wbr>
</div></code></pre>



<h3 id="h5标签">h5标签</h3>

<ul><li><p>header  : 头部</p></li>
<li><p>section : 块</p></li>
<li><p>main : 主体部分</p></li>
<li><p>footer : 底部</p></li>
<li><p>nav : 导航；</p></li>
<li><p>figure : 图片</p></li>
<li><p>figurecaption : 图片描述</p></li>
<li><p>article ： 文章</p></li>
<li><p>mark : 高亮；</p></li>
<li><p>canvas : 走显卡，要研究深入，需要算法,位图</p>

<ul>
<li><p>WEBGL ——&gt; three.js</p></li></ul></li>
<li><p><strong>音频：</strong> <br>
<code>&lt;audio src="https://www.runoob.com/try/demo_source/horse.mp3"&gt;</code></p></li>
<li><p>Media.currentTime = value; //当前播放的位置，赋值可改变位置 20    </p></li>
<li><p>Media.startTime; //一般为0，如果为流媒体或者不从0开始的资源，则不为0</p></li>
<li><p>Media.duration; //当前资源长度流返回无限</p></li>
<li><p>Media.paused; //是否暂停</p></li>
<li><p>Media.defaultPlaybackRate = value;//默认的回放速度，可以设置</p></li>
<li><p>Media.playbackRate = value;//当前播放速度，设置后马上改变</p></li>
<li><p>Media.played; //返回已经播放的区域，TimeRanges，关于此对象见下文</p></li>
<li><p>Media.seekable; //返回可以seek的区域 TimeRanges</p></li>
<li><p>Media.ended;    //是否结束</p></li>
<li><p>Media.autoPlay;    //是否自动播放</p></li>
<li><p>Media.loop;    //是否循环播放</p></li>
<li><p>Media.play();    //播放</p></li>
<li><p>Media.pause();    //暂停</p></li>
<li><p><strong>视频：</strong></p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">   &lt;video width=<span class="hljs-string">"320"</span> height=<span class="hljs-string">"240"</span> controls&gt;
</div><div class="hljs-line">       <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"movie.mp4"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"video/mp4"</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"movie.ogg"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"video/ogg"</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml">       您的浏览器不支持Video标签。</span>
</div><div class="hljs-line"><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span>  </span>
</div><div class="hljs-line"><span class="xml">   video这个对象下有play播放，pause暂停; </span>
</div><div class="hljs-line"><span class="xml">       比如:myVideo.play(); </span>
</div><div class="hljs-line"><span class="xml">   controls：显示控制器，播放、暂停、进度条</span>
</div><div class="hljs-line"><span class="xml">   autoplay 自动播放</span>
</div><div class="hljs-line"><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">// 新增input的属性；</span>
</div></code></pre>



<h3 id="重绘">重绘</h3>

<blockquote>
  <p>当改变页面中某个元素的边框、背景(非几何发生变化)，浏览器会重新对该元素进行渲染，会消耗性能</p>
</blockquote>



<h3 id="重排回流">重排(回流)</h3>

<blockquote>
  <p>当修改某个元素的位置或者添加插入、删除某个(些)元素的时候(几何发生变化)，页面会进行重新渲染(局部、整个页面)，所以操作DOM非常影响性能</p>
</blockquote>



<pre class="prettyprint hljs-dark"><code class="hljs livescript"><div class="hljs-line">整个页面呈现，需要<span class="hljs-number">2</span>大部分渲染，DOM渲染，CSS渲染
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">DOM渲染<span class="hljs-function"> -&gt;</span>
</div><div class="hljs-line">   DOM树<span class="hljs-function">  -&gt;</span> 结构
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">CSS渲染
</div><div class="hljs-line">   CSSOM
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">渲染树<span class="hljs-function"><span class="hljs-params">(DOM树 + CSS树)</span> -&gt;</span> 结构应该在哪个位置
</div></code></pre>



<h3 id="渐变">渐变</h3>

<ul><li><p><strong>linear-gradient  直线渐变</strong></p>

<ul>
<li><p>linear-gradient([&lt;起点&gt; || &lt;角度&gt;,]? &lt;点&gt;, &lt;点&gt;…)</p></li>
<li><p>只能用在背景上</p></li>
<li><p>颜色是沿着一条直线轴变化</p></li>
<li><p>参数</p>

<ul>
<li><p>起点：从什么方向开始渐变</p></li>
<li><p>left、top、left top</p></li>
<li><p>角度：从什么角度开始渐变</p></li>
<li><p>xxx deg的形式</p></li>
<li><p>点：渐变点的颜色和位置</p></li>
<li><p>red 50%，位置可选</p></li></ul></li>
<li><p>重复线性渐变</p></li></ul></li>
<li><p><strong>radial-gradient  径向渐变</strong></p>

<ul>
<li><p>radial-gradient([[ || ] [at ]?,| at ,]?[,]+);</p></li>
<li><p>从“一个点”向多方向颜色渐变</p></li>
<li><p>shape形状 ： ellipse、circle  或设置水平半径,垂直半径</p></li>
<li><p>size:渐变的大小，即渐变到哪里停止，有如下关键词:</p>

<ul>
<li><p>closest-side：最近边； farthest-side：最远边；</p></li>
<li><p>closest-corner：最近角； farthest-corner：最远角 (默认值)</p></li></ul></li>
<li><p>position ：关键词|数值|百分比</p></li>
<li><p>重复的径向渐变</p></li></ul></li>
</ul>



<h3 id="背景">背景</h3>

<ul><li><p><strong>background-origin</strong></p>

<ul>
<li><p>padding-box 从padding区域显示（默认）</p></li>
<li><p>border-box 从box 从content区border区域显示</p></li>
<li><p>content-域显示</p></li></ul></li>
<li><p><strong>background-clip</strong></p>

<ul>
<li><p>padding-box  从padding区域向外裁剪</p></li>
<li><p>border-box  从border区域往外裁剪</p></li>
<li><p>content-box  从content区域往外裁剪</p></li></ul></li>
<li><p><strong>background-size</strong></p>

<ul>
<li><p>100% 100%  百分比</p></li>
<li><p>10px 10px 数值</p></li>
<li><p>contain   按原始比例收缩,背景图显示完整,但不一定铺满整个容器</p></li>
<li><p>cover   按原始比例收缩,背景图可能显示不完整,但铺满整个容器</p></li></ul></li>
<li><p><strong>background-attachment</strong> </p>

<ul>
<li><p>背景图片是滚动的还是固定的 fixed(固定的) 默认是滚动的</p></li></ul></li>
</ul>



<h3 id="圆角-border-radius">圆角 border-radius</h3>

<ul><li><p>border-radius: 1-4个数字 / 1-4个数字</p>

<ul>
<li><p>前面是水平半径，后面是垂直半径</p></li>
<li><p>四个数字方向分别是左上  右上  右下  左下</p></li>
<li><p>不给“/”则水平半径和垂直半径一样</p>

<ul>
<li><p>border-radius: 10px/5px;</p></li>
<li><p>border-radius:60px 40px 30px 20px /30px 20px 10px 5</p></li></ul></li>
<li><p>例子 : 圆  椭圆  半圆  扇形</p></li></ul></li>
</ul>



<h3 id="盒子阴影">盒子阴影</h3>

<ul><li><p><strong>box-shadow: h  v  blur spread color inset;</strong></p>

<ul>
<li><p>h :水平方向偏移</p></li>
<li><p>v : 垂直方向偏移</p></li>
<li><p>blur : 模糊半径</p></li>
<li><p>spread : 扩展半径</p></li>
<li><p>color : 颜色</p></li>
<li><p>inset :加上这个表示内阴影 默认是外阴影</p></li></ul></li>
</ul>



<h3 id="文本阴影">文本阴影</h3>

<ul><li><p><strong>text-shadow : x y blur  color</strong></p>

<ul>
<li><p>x轴偏移  y轴偏移  模糊度  颜色</p></li>
<li><p>多层阴影制作文字立体效果 ,设置多种颜色,中间以逗号隔开</p></li></ul></li>
<li><p><strong>text-stroke: 2px blue  文字添加边框</strong></p>

<ul>
<li><p>通过设定1px的透明边框，可以让文字变得平滑</p></li>
<li><p>颜色设成透明能创建镂空字体</p></li></ul></li>
</ul>



<h3 id="css3选择器">CSS3选择器</h3>

<ul><li><p><strong>结构选择器</strong></p>

<ul>
<li><p>:nth-child(n) </p></li>
<li><p>:nth-child(2n) 偶数元素</p></li>
<li><p>:nth-child(2n+1) 奇数元素</p></li>
<li><p>:nth-of-type(n)  </p></li>
<li><p>:first-child</p></li>
<li><p>:last-child</p></li>
<li><p>:only-child</p></li>
<li><p>:only-of-type</p></li>
<li><p>:empty</p></li></ul></li>
<li><p><strong>否定选择器</strong></p>

<ul>
<li><p>:not()</p></li></ul></li>
<li><p><strong>属性选择器</strong></p>

<ul>
<li><p>E[attr=val]</p></li>
<li><p>E[attr|=val]  只能等于val  或只能以val-开头</p></li>
<li><p>E[attr*=val]  包含val字符串</p></li>
<li><p>E[attr~=val]   属性值有多个,其中有一个是val</p></li>
<li><p>E[attr^=val]   以val开头,不管后面是什么</p></li>
<li><p>E[attr$=val]   以val结尾,不管前面是什么</p></li></ul></li>
<li><p><strong>目标伪类选择器</strong></p>

<ul>
<li><p>:target 用来匹配url指向的目标元素</p></li>
<li><p>存在url指向该匹配元素时,样式效果才会生效</p></li></ul></li>
<li><p><strong>伪元素</strong></p>

<ul>
<li><p>: first-line  匹配第一行文本</p></li>
<li><p>: first-letter 匹配第一个首字符</p></li>
<li><p>: before 和 : after  DOM元素前后插入额外的内容</p></li></ul></li>
</ul>



<h2 id="css3动画">CSS3动画</h2>

<ul><li><p><strong>transition  过渡动画  加在运动物体身上</strong></p></li>
<li><p><strong>transition-property  过渡属性  all | [attr]</strong></p></li>
<li><p><strong>transition-duration 过渡时间</strong></p></li>
<li><p><strong>transition-delay 延迟时间</strong></p></li>
<li><p><strong>transition-timing-function 运动类型</strong></p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">    如果transition第一个参数不写，默认为all(所有的方向)
</div><div class="hljs-line">    也可以指定，如果为指定只有指定的属性才能享受到运动
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    连写:
</div><div class="hljs-line">        transition:运动属性 运动时间 运动的延迟
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    小技巧:
</div><div class="hljs-line">        在使用css3动画的时候，有可能会出现运动失效的情况，
</div><div class="hljs-line">        可以通过定时器setTimeout，让运动进行异步运行，可以解决BUG
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        box.style.display = <span class="hljs-string">'block'</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
</div><div class="hljs-line">            box.style.transition = <span class="hljs-string">'1s'</span>;
</div><div class="hljs-line">            box.style.width = <span class="hljs-string">'300px'</span>;
</div><div class="hljs-line">            box.style.height = <span class="hljs-string">'300px'</span>;
</div><div class="hljs-line">            box.style.opacity = <span class="hljs-number">.3</span>;
</div><div class="hljs-line">        });
</div><div class="hljs-line"><wbr>
</div></code></pre>



<h3 id="动画结束触发">动画结束触发</h3>

<blockquote>
  <p>transitionend   webkitTransitionEnd  mozTransitionEnd…. <br>
  ele.addEventListener(‘webkitTransitionEnd’,function(){},false);</p>
  
  <p>注意:如果运动的属性有多个，那么每个运动完成时都会触发一次TransitionEnd，就可能导致在同一时间内执行了多次代码</p>
</blockquote>



<h3 id="2d变换">2d变换</h3>



<pre class="prettyprint hljs-dark"><code class="hljs less"><div class="hljs-line">    <span class="hljs-selector-tag">transform</span>是可以连写的，但是在写的过程当中要注意先后顺序，不然会发生意想不到的惊喜。
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-selector-tag">transform</span>: <span class="hljs-selector-tag">rotate</span>(-<span class="hljs-number">80deg</span>) <span class="hljs-selector-tag">translateX</span>(<span class="hljs-number">300px</span>) ; 先执行角度再执行位移
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-selector-tag">transform</span>: <span class="hljs-selector-tag">translateX</span>(<span class="hljs-number">300px</span>)  <span class="hljs-selector-tag">rotate</span>(-<span class="hljs-number">80deg</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-selector-tag">rotate</span>()  旋转函数
</div><div class="hljs-line">    <span class="hljs-selector-tag">deg</span>  度数
</div><div class="hljs-line">    <span class="hljs-selector-tag">transform-origin</span> 旋转的基点
</div><div class="hljs-line">        默认为<span class="hljs-selector-tag">center</span> <span class="hljs-selector-tag">center</span>
</div><div class="hljs-line">        可以设置<span class="hljs-selector-tag">left</span> <span class="hljs-selector-tag">top</span> <span class="hljs-selector-tag">bottom</span> <span class="hljs-selector-tag">right</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-selector-tag">skew</span>() 倾斜函数  <span class="hljs-selector-tag">deg</span>
</div><div class="hljs-line">    <span class="hljs-selector-tag">skewX</span>()
</div><div class="hljs-line">    <span class="hljs-selector-tag">skewY</span>()
</div><div class="hljs-line">    <span class="hljs-selector-tag">scale</span>() 缩放函数 默认值是<span class="hljs-selector-tag">1</span> 
</div><div class="hljs-line">    <span class="hljs-selector-tag">scaleX</span>()
</div><div class="hljs-line">    <span class="hljs-selector-tag">scaleY</span>()
</div><div class="hljs-line">    <span class="hljs-selector-tag">translate</span>() 位移函数
</div><div class="hljs-line">    <span class="hljs-selector-tag">translateX</span>()  <span class="hljs-selector-tag">left</span>
</div><div class="hljs-line">    <span class="hljs-selector-tag">translateY</span>()  <span class="hljs-selector-tag">top</span>
</div><div class="hljs-line"><wbr>
</div></code></pre>



<h3 id="3d">3D</h3>

<blockquote>
  <p><strong>transform-style : flat | preserve-3d (3D空间展示) 内容为3D</strong>  </p>
  
  <p><strong>transform:perspective(800px) 景深  近大远小</strong></p>
</blockquote>



<h3 id="关键帧运动">关键帧运动</h3>

<blockquote>
  <p><strong>@keyframes 自定义的名字</strong> { <br>
      0%{} <br>
      100%{} <br>
  }</p>
  
  <p><strong>animation: 自定义的名字 1s </strong></p>
</blockquote>



<h2 id="移动端rem布局">移动端rem布局</h2>

<blockquote>
  <p>布局 -&gt; 适配 -&gt; REM适配</p>
  
  <p>响应式布局</p>
  
  <p><strong>苹果 ios  object-c  swift   闭源</strong></p>
  
  <ul><li><p>需要APPstore审批，时间大概在7天左右，如果没有审核过又要等7天左右，当真正上线的时候有可能已经赚不到钱了 </p></li>
  </ul>
  
  <p><strong>安卓 c, 应用就是用java开发的  开源</strong></p>
  
  <p>之前解决跨端的问题，还是比较复杂</p>
  
  <p>前端的移动端</p>
  
  <ul><li><p>套web，用浏览器套写好的html，打包好，用户去下载打包后的应用，打开应用就等同于打开浏览器</p></li>
  </ul>
  
  <p>弊端:使用不了手机系统上自带的功能，摄像头、相册….</p>
</blockquote>

<ul><li><p>专门在原生应用上进行开发，把安卓和苹果的接口封装好暴露出去给js去调用</p></li>
<li><p>微信JSSDK</p></li>
<li><p>react-native</p></li>
<li><p>Hybrid</p></li>
</ul>

<p><strong>REM适配:</strong></p>

<blockquote>
  <p>em 单位  这个单位被自己或者父级的字体大小影响，最小为8px <br>
  rem 单位  root(根,html) em</p>
</blockquote>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">&lt;script&gt;
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> desW = <span class="hljs-number">640</span>; <span class="hljs-comment">//设计图</span>
</div><div class="hljs-line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refreshRem</span>(<span class="hljs-params"></span>) </span>{
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> doc = <span class="hljs-built_in">document</span>.documentElement; <span class="hljs-comment">//html</span>
</div><div class="hljs-line">        <span class="hljs-comment">// alert(doc.nodeName);</span>
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> winW = doc.clientWidth;
</div><div class="hljs-line">        <span class="hljs-comment">//设计图 / 可视区</span>
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> radio = desW / winW;  <span class="hljs-comment">//开发模拟器也要640的位置上</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">if</span> (winW &gt;= desW) {
</div><div class="hljs-line">            <span class="hljs-comment">//100px为了好计算  100px -&gt; 1rem  55px -&gt; 0.55rem</span>
</div><div class="hljs-line">            doc.style.fontSize = <span class="hljs-string">'100px'</span>;
</div><div class="hljs-line">            <span class="hljs-keyword">return</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">        doc.style.fontSize = <span class="hljs-number">100</span> / radio + <span class="hljs-string">'px'</span>;
</div><div class="hljs-line">    }
</div><div class="hljs-line">    refreshRem();
</div><div class="hljs-line">    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, refreshRem);
</div><div class="hljs-line"><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</div></code></pre>



<h2 id="less">LESS</h2>

<blockquote>
  <p>Less 是一门 CSS 预处理语言 <br>
  写css更加方便(效率提高)，好维护，比较规范</p>
</blockquote>

<ul><li><p>属性变量</p>

<ul>
<li><p><code>@w:width;  定义</code></p></li>
<li><p><code>@{w}:100px; 使用</code></p></li></ul></li>
<li><p>传参</p>

<ul>
<li><p>定义:</p>

<ul>
<li><p><code>.变量名(@1:也可以定义默认值,@2){ <br>
border:@x solid @c; <br>
}</code></p></li></ul></li>
<li><p>调用:</p>

<ul>
<li><p><code>.变量名(加实参);</code></p></li></ul></li></ul></li>
</ul>



<h2 id="手机的三大事件">手机的三大事件</h2>

<ul><li><p><strong>ontouchstart  手指按下</strong></p></li>
<li><p><strong>ontouchmove   手指移动</strong></p></li>
<li><p><strong>ontouchend    手指抬起</strong></p>

<blockquote>
  <p>一个目标上按下、移动、抬起是一套事件，按下在哪个元素身上，当抬起的时候就算不在按下的元素身上，触发抬起也是按下的那个元素；所以不用嵌套绑定事件函数。</p>
</blockquote></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">let</span> event = <span class="hljs-built_in">document</span>.createEvent(<span class="hljs-string">'HTMLEvents'</span>);
</div><div class="hljs-line">event.initEvent(<span class="hljs-string">"top"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
</div><div class="hljs-line"><span class="hljs-keyword">let</span> event2 = <span class="hljs-built_in">document</span>.createEvent(<span class="hljs-string">'HTMLEvents'</span>);
</div><div class="hljs-line">event2.initEvent(<span class="hljs-string">"bottom"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'touchstart'</span>,start);
</div><div class="hljs-line"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'touchmove'</span>,move);
</div><div class="hljs-line"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'touchend'</span>,end);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'top'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'上划'</span>)
</div><div class="hljs-line">});
</div><div class="hljs-line"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'bottom'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'下划'</span>)
</div><div class="hljs-line">});
</div></code></pre>

<ul><li><p><strong>1、 touches：当前位于屏幕上的所有手指触摸点的一个列表。</strong></p>

<ul>
<li><p>touches（作用于整个屏幕）:表示当前跟踪的触摸操作的Touch对象的数组–点击触摸时有多少个Touch对象</p></li></ul></li>
<li><p><strong>2.、targetTouches：当前元素对象上所有触摸点的列表。</strong></p>

<ul>
<li><p>targetTouches（作用于一开始start的元素）：特定于事件目标的Touch对象的数组–点击触摸时有多少个Touch对象</p></li></ul></li>
<li><p><strong>3、 changedTouches：涉及当前事件的触摸点的列表。</strong></p>

<ul>
<li><p>√ changedTouches（一上来触摸的元素，并且不会累计手指数量）:表示自上次触摸以来发生了什么改变的Touch对象的数组–发生改变的活着当前是多少touch对象，即相当于touchmove</p></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">let</span> disX = <span class="hljs-number">0</span>;
</div><div class="hljs-line"><span class="hljs-keyword">let</span> disY = <span class="hljs-number">0</span>;
</div><div class="hljs-line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">    disX = ev.changedTouches[<span class="hljs-number">0</span>].pageX;
</div><div class="hljs-line">    disY = ev.changedTouches[<span class="hljs-number">0</span>].pageY;
</div><div class="hljs-line">}
</div><div class="hljs-line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">}
</div><div class="hljs-line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">end</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> endX = ev.changedTouches[<span class="hljs-number">0</span>].pageX;
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> endY = ev.changedTouches[<span class="hljs-number">0</span>].pageY;
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> X = endX - disX;
</div><div class="hljs-line">    <span class="hljs-keyword">let</span> Y = endY - disY;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">Math</span>.abs(X) &gt; <span class="hljs-built_in">Math</span>.abs(Y) &amp;&amp; X &gt; <span class="hljs-number">0</span> ) {
</div><div class="hljs-line">        alert(<span class="hljs-string">"像右滑动"</span>);
</div><div class="hljs-line">    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">Math</span>.abs(X) &gt; <span class="hljs-built_in">Math</span>.abs(Y) &amp;&amp; X &lt; <span class="hljs-number">0</span> ) {
</div><div class="hljs-line">        alert(<span class="hljs-string">"像左滑动"</span>);
</div><div class="hljs-line">    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">Math</span>.abs(Y) &gt; <span class="hljs-built_in">Math</span>.abs(X) &amp;&amp; Y &gt; <span class="hljs-number">0</span>) {
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.dispatchEvent(event2);
</div><div class="hljs-line">    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">Math</span>.abs(Y) &gt; <span class="hljs-built_in">Math</span>.abs(X) &amp;&amp; Y &lt; <span class="hljs-number">0</span> ) {
</div><div class="hljs-line">        <span class="hljs-comment">// alert("上滑动");</span>
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.dispatchEvent(event);
</div><div class="hljs-line">    }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">        alert(<span class="hljs-string">"触摸"</span>);
</div><div class="hljs-line">    }
</div><div class="hljs-line">}
</div></code></pre>

<ul><li><p>在移动端开发的时候尽量少用DOM0，都用DOM2</p>

<ul>
<li><p>因为DOM0在有些浏览器上调试是不正常的，但是真机上是OK的，所以为了方便开发，移动端的事件都用DOM2绑定</p></li></ul></li>
</ul>



<h3 id="移动端点透">移动端点透</h3>

<blockquote>
  <p>在移动端三事件是比PC的事件快大约300ms左右</p>
  
  <p>苹果之前出了一个用户体验非常好的效果，在屏幕某个位置300ms左右连续点击2次就会触发放大缩小的效果。</p>
  
  <p>在移动端中点击某个物体(盒子),如果盒子下方有焦点（input,a..）元素，那么如果在300ms之内，上方的盒子消失或者偏移，那么就会触发下面的焦点元素行为。</p>
</blockquote>



<h4 id="解决">解决:</h4>

<ul><li><p>1.不放焦点元素,如果要跳转，使用js操作。</p>

<ul>
<li><p>弊端：对seo优化有影响</p></li></ul></li>
<li><p>2.使用焦点元素,javascript:void(0);</p></li>
<li><p>3.<strong>通过阻止全局的默认行为，阻止焦点元素的行为，然后单另在焦点元素上绑跳转。</strong></p></li>
<li><p>4.把消失或者偏移的时间放缓些，尽量超过300ms</p></li>
</ul>



<h1 id="ajax">AJAX</h1>

<blockquote>
  <p>Asynchronous(异步) Javascript(js) And(和) XML(可扩展标记语言) <br>
  异步的js和xml</p>
  
  <p>前后端数据交互的技术</p>
</blockquote>



<h3 id="目的从后台拿数据">目的：从后台拿数据</h3>



<h3 id="难点">难点</h3>

<ul><li><p>拿到数据之后做什么，如何处理？</p>

<ul>
<li><p>后端的代码是同步执行的，一句话一句话执行，上面的代码执行完才执行下面的代码， 也就是说上面的代码没有执行完会阻塞下面代码的执行，那么这样会导致页面中因为某块数据没有加载完成而影响整个页面的显示</p></li>
<li><p>全局刷新（用户体验较差）</p></li>
<li><p>js引擎、gui引擎、事件引擎、请求引擎</p></li></ul></li>
</ul>



<h2 id="url">url</h2>



<pre class="prettyprint hljs-dark"><code class="hljs dts"><div class="hljs-line"><span class="hljs-symbol">    url:</span>
</div><div class="hljs-line"><span class="hljs-symbol">        http:</span><span class="hljs-comment">//localhost:80/3_ajax.html?page=1#hash=xy;</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    协议:
</div><div class="hljs-line"><span class="hljs-symbol">        http:</span><span class="hljs-comment">//  超文本传输协议</span>
</div><div class="hljs-line"><span class="hljs-symbol">        file:</span><span class="hljs-comment">//  本地文件传输协议</span>
</div><div class="hljs-line"><span class="hljs-symbol">        https:</span><span class="hljs-comment">// 比http更加安全</span>
</div><div class="hljs-line"><span class="hljs-symbol">        ftp:</span> 文件传输协议
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    域名:ip的别名
</div><div class="hljs-line">        localhost  
</div><div class="hljs-line">        <span class="hljs-number">14.215</span><span class="hljs-number">.177</span><span class="hljs-number">.39</span>  baidu 
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    端口:
</div><div class="hljs-line">        放在域名后面的
</div><div class="hljs-line">        服务器默认端口为<span class="hljs-number">80</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    文件路径:
</div><div class="hljs-line">        <span class="hljs-number">3</span>_ajax.html
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    查询信息:
</div><div class="hljs-line">        ?page=<span class="hljs-number">1</span> &amp; id=<span class="hljs-number">0</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        一个参数与另一个参数用&amp;符分割
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    hash信息:
</div><div class="hljs-line">        <span class="hljs-meta">#hash=xy</span>
</div></code></pre>



<h3 id="输入url回车之后发生了什么事">输入url回车之后发生了什么事?</h3>

<p><code>https://www.cnblogs.com/tisikcci/p/5866753.html</code></p>

<p><code>http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</code></p>

<ul><li><p>DNS去解析url找到对应的服务器</p></li>
<li><p>通过端口访问对应的服务</p></li>
<li><p>http请求</p></li>
<li><p>三次握手和四次挥手,要保证有效请求</p></li>
<li><p>响应 -&gt; http状态码</p></li>
<li><p>gui渲染页面</p></li>
</ul>



<h2 id="传统的交互方式">传统的交互方式</h2>

<ul><li><p>action=”url路径”</p>

<ul>
<li><p>url路径是后台给你的地址</p></li></ul></li>
<li><p>method = “请求方式”</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs xml"><div class="hljs-line"><span class="hljs-comment">&lt;!-- get--&gt;</span>
</div><div class="hljs-line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/get"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"GET"</span>&gt;</span>
</div><div class="hljs-line">    用户名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span>/&gt;</span>
</div><div class="hljs-line">    密 码:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pw"</span>/&gt;</span>
</div><div class="hljs-line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>&gt;</span>
</div><div class="hljs-line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">&lt;!-- post --&gt;</span>
</div><div class="hljs-line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/post"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"POST"</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">"application/x-www-form-urlencoded"</span>&gt;</span>
</div><div class="hljs-line">    用户名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span>/&gt;</span>
</div><div class="hljs-line">    密 码:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pw"</span>/&gt;</span>
</div><div class="hljs-line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>&gt;</span>
</div><div class="hljs-line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>



<h2 id="ajax的交互模型打电话模式">ajax的交互模型(打电话模式)</h2>

<blockquote>
  <p>1.有一部电话 <br>
  2.输入号码 <br>
  3.发送(按绿按钮) <br>
  4.等待 <br>
  5.通话</p>
</blockquote>



<h2 id="fetch请求数据">fetch请求数据</h2>



<pre class="prettyprint hljs-dark"><code class="hljs less"><div class="hljs-line">   <span class="hljs-selector-tag">fetch</span>(<span class="hljs-string">'/post'</span>,{
</div><div class="hljs-line">       <span class="hljs-attribute">method</span>:<span class="hljs-string">'post'</span>,
</div><div class="hljs-line">       <span class="hljs-attribute">body</span>:<span class="hljs-string">''</span>+new URLSearchParams({
</div><div class="hljs-line">           <span class="hljs-attribute">user</span>:this.value <span class="hljs-comment">//'user='+this.value,</span>
</div><div class="hljs-line">       }),
</div><div class="hljs-line">       <span class="hljs-attribute">headers</span>:{
</div><div class="hljs-line">           <span class="hljs-string">'content-type'</span>:<span class="hljs-string">'application/x-www-form-urlencoded'</span>
</div><div class="hljs-line">       }
</div><div class="hljs-line">   })<span class="hljs-selector-class">.then</span>(d=&gt;d.json())
</div><div class="hljs-line">   <span class="hljs-selector-class">.then</span>(d=&gt;{
</div><div class="hljs-line">       <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(d);
</div><div class="hljs-line">   });
</div></code></pre>



<h2 id="get和post">get和post</h2>

<ul><li><p><strong>1.get请求：参数在url上（get一般用于数据展示）</strong>     </p>

<ul>
<li><p>get:(应用场景数据渲染) <br>
<code>url -&gt; 后端给的 '/get?user=yuhaiyang' <br>
xhr.open('get','/s?wd=zhufeng')</code></p></li>
<li><p>缺点:</p>

<ul>
<li><p>会通过浏览器的缓存机制，缓存你的url的访问记录(相对不安全)，url的长度是有限制的，每个浏览器都不一样，不能传输体积较大的文件，中文需要通过encodeURI转码</p></li></ul></li>
<li><p>优势:</p>

<ul>
<li><p>速度快 -&gt; 3步就能请求到数据</p></li></ul></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line"><span class="hljs-comment">//原生js，fetch请求</span>
</div><div class="hljs-line">user.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">        fetch(<span class="hljs-string">'/get?user='</span>+<span class="hljs-keyword">this</span>.value)
</div><div class="hljs-line">        .then(<span class="hljs-function"><span class="hljs-params">d</span>=&gt;</span>d.json())
</div><div class="hljs-line">        .then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>{
</div><div class="hljs-line">            <span class="hljs-comment">// span.innerHTML = data.msg;</span>
</div><div class="hljs-line">            <span class="hljs-comment">// console.log(data);</span>
</div><div class="hljs-line">        });
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">//jquery版请求</span>
</div><div class="hljs-line">$(<span class="hljs-string">'#user'</span>).blur(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">    $.ajax({
</div><div class="hljs-line">        <span class="hljs-attr">url</span>:<span class="hljs-string">'/get?user='</span>+$(<span class="hljs-keyword">this</span>).val(),
</div><div class="hljs-line">        <span class="hljs-attr">dataType</span>:<span class="hljs-string">'json'</span>,
</div><div class="hljs-line">        <span class="hljs-attr">success</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
</div><div class="hljs-line">            <span class="hljs-keyword">if</span>(data.code === <span class="hljs-number">1</span>){
</div><div class="hljs-line">                $(<span class="hljs-string">'#span'</span>).html( data.msg );
</div><div class="hljs-line">            }   
</div><div class="hljs-line">        }
</div><div class="hljs-line">    })
</div><div class="hljs-line">});
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">//get请求</span>
</div><div class="hljs-line">user.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">      <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest;
</div><div class="hljs-line">      xhr.open(<span class="hljs-string">'get'</span>,<span class="hljs-string">'/get?user='</span>+<span class="hljs-built_in">encodeURI</span>(<span class="hljs-keyword">this</span>.value));
</div><div class="hljs-line">      xhr.send();
</div><div class="hljs-line">      xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">          <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.parse(xhr.responseText);
</div><div class="hljs-line">          span.innerHTML = data.msg;
</div><div class="hljs-line">      }
</div><div class="hljs-line">  }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">//get请求，是否异步</span>
</div><div class="hljs-line">un.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">        img.style.display = <span class="hljs-string">'block'</span>;
</div><div class="hljs-line">        <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest;
</div><div class="hljs-line">        xhr.open(<span class="hljs-string">'get'</span>,<span class="hljs-string">'/sleep?name='</span>+<span class="hljs-keyword">this</span>.value,<span class="hljs-literal">true</span>);<span class="hljs-comment">//是否异步</span>
</div><div class="hljs-line">        xhr.timeout = <span class="hljs-number">3000</span>;
</div><div class="hljs-line">        xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'超时'</span>);
</div><div class="hljs-line">        }
</div><div class="hljs-line">        xhr.send();
</div><div class="hljs-line">        xhr.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>{
</div><div class="hljs-line">            <span class="hljs-built_in">console</span>.log(ev);
</div><div class="hljs-line">        }
</div></code></pre>

<ul><li><p><strong>2.post请求：参数在send中（post用户、传输较大数据）</strong></p>

<ul>
<li><p>post：(用户信息，上传视频…)</p>

<ul>
<li><p>优势：</p>

<ul>
<li><p>参数不会被浏览器缓存，相对安全；请求方式是走的服务器，理论上来说体积可以无限大（一般后台人员会限制）；在发送之前需要设置请求头</p></li></ul></li>
<li><p>缺点：</p>

<ul>
<li><p>速度相对get要慢。</p></li></ul></li></ul></li></ul>

<blockquote>
  <p>需要注意的是：</p>
  
  <ul>
  <li><p>在真实开发中，ajax请求基本上都是用第三方库来请求的</p></li>
  <li><p>第三方库已经把ajax封装起来了，看不见send</p></li></ul>
</blockquote></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-java hljs"><div class="hljs-line">用户名:&lt;input type=<span class="hljs-string">"text"</span> id=<span class="hljs-string">"un"</span> name=<span class="hljs-string">"user"</span>/&gt;
</div><div class="hljs-line">        密 码:&lt;input type=<span class="hljs-string">"password"</span> name=<span class="hljs-string">"pw"</span>/&gt;
</div><div class="hljs-line">        &lt;input type=<span class="hljs-string">"button"</span> value=<span class="hljs-string">"提交"</span>&gt;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">&lt;script&gt;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">//post请求</span>
</div><div class="hljs-line">user.onblur = function(){
</div><div class="hljs-line">        var xhr = <span class="hljs-keyword">new</span> XMLHttpRequest;
</div><div class="hljs-line">        xhr.open(<span class="hljs-string">'post'</span>,<span class="hljs-string">'/post'</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        xhr.setRequestHeader(<span class="hljs-string">'Content-Type'</span>,<span class="hljs-string">'application/x-www-form-urlencoded'</span>);
</div><div class="hljs-line">        <span class="hljs-comment">//把传给后端的数据放在send中</span>
</div><div class="hljs-line">        xhr.send(<span class="hljs-string">'user='</span>+<span class="hljs-keyword">this</span>.value);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        xhr.onload = function(){
</div><div class="hljs-line">            var data = JSON.parse(xhr.responseText);
</div><div class="hljs-line">            span.innerHTML = data.msg;
</div><div class="hljs-line">        }
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">//post请求，是否异步</span>
</div><div class="hljs-line">un.onblur = function(){
</div><div class="hljs-line">    let xhr = <span class="hljs-keyword">new</span> XMLHttpRequest;
</div><div class="hljs-line">    xhr.open(<span class="hljs-string">'post'</span>,<span class="hljs-string">'/post'</span>,<span class="hljs-keyword">true</span>);<span class="hljs-comment">//是否异步</span>
</div><div class="hljs-line">    xhr.setRequestHeader(<span class="hljs-string">'Content-Type'</span>,<span class="hljs-string">'application/x-www-form-urlencoded'</span>);
</div><div class="hljs-line">    xhr.send(<span class="hljs-string">'user='</span>+<span class="hljs-keyword">this</span>.value);
</div><div class="hljs-line">    <span class="hljs-comment">// xhr.onerror = function(){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     console.log('失败');//一般是传输的时候有问题</span>
</div><div class="hljs-line">    <span class="hljs-comment">// }</span>
</div><div class="hljs-line">    xhr.onload = function(){
</div><div class="hljs-line">        <span class="hljs-comment">// console.dir(xhr);</span>
</div><div class="hljs-line">        console.log(xhr.responseText);
</div><div class="hljs-line">    }
</div><div class="hljs-line">    <span class="hljs-comment">// xhr.onloadend = function(){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//     console.dir(2);</span>
</div><div class="hljs-line">    <span class="hljs-comment">// }</span>
</div><div class="hljs-line">    console.log(<span class="hljs-number">1</span>);
</div><div class="hljs-line">};
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">&lt;/script&gt;
</div></code></pre>



<h3 id="获取xml的数据">获取XML的数据</h3>



<pre class="prettyprint hljs-dark"><code class="language-java hljs"><div class="hljs-line">&lt;button id=<span class="hljs-string">"btn"</span>&gt;点击生成&lt;/button&gt;
</div><div class="hljs-line">    &lt;ul id=<span class="hljs-string">"ul"</span>&gt;&lt;/ul&gt;
</div><div class="hljs-line">&lt;script&gt;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">//fetch请求</span>
</div><div class="hljs-line">btn.onclick = function(){
</div><div class="hljs-line">    fetch(<span class="hljs-string">'./data.xml'</span>)
</div><div class="hljs-line">    .then(data=&gt;data.text())
</div><div class="hljs-line">    .then(d=&gt;{
</div><div class="hljs-line">        let re = <span class="hljs-keyword">new</span> RegExp(`&lt;person&gt;\\s+&lt;name&gt;([\\u4e00-\\u9fa5]+)&lt;/name&gt;\\s+&lt;age&gt;(\\d+)&lt;/age&gt;\\s+&lt;sex&gt;([\\u4e00-\\u9fa5])&lt;/sex&gt;\\s+&lt;info&gt;([\\u4e00-\\u9fa5。？\.\\d，,]+)&lt;/info&gt;\\s+&lt;/person&gt;\\s+`,<span class="hljs-string">'g'</span>);
</div><div class="hljs-line">        let html = <span class="hljs-string">''</span>;
</div><div class="hljs-line">        <span class="hljs-comment">// console.log(d.match(re))</span>
</div><div class="hljs-line">        <span class="hljs-comment">// console.log(d.match(/^&lt;name&gt;[\u4e00-\u9fa5]+&lt;\/name&gt;$/g));</span>
</div><div class="hljs-line">        <span class="hljs-comment">// d.replace(re,($0,$1,$2,$3,$4)=&gt;{</span>
</div><div class="hljs-line">        <span class="hljs-comment">//     html += `&lt;li&gt;我的名字叫${$1},芳龄:${$2}性别:${$3}---我想说:${$4}&lt;/li&gt;`</span>
</div><div class="hljs-line">        <span class="hljs-comment">//     // console.log($1,$2,$3,$4);</span>
</div><div class="hljs-line">        <span class="hljs-comment">// });</span>
</div><div class="hljs-line">        <span class="hljs-comment">// ul.innerHTML = html;</span>
</div><div class="hljs-line">    });
</div><div class="hljs-line">}
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">//get请求</span>
</div><div class="hljs-line">btn.onclick = function(){
</div><div class="hljs-line">   let html = <span class="hljs-string">''</span>;
</div><div class="hljs-line">   let xhr = <span class="hljs-keyword">new</span> XMLHttpRequest;
</div><div class="hljs-line">   xhr.open(<span class="hljs-string">'get'</span>,<span class="hljs-string">'data.xml'</span>);
</div><div class="hljs-line">   xhr.send();
</div><div class="hljs-line">   xhr.onload = function(){
</div><div class="hljs-line">       let d = xhr.responseXML;
</div><div class="hljs-line">       let person = d.getElementsByTagName(<span class="hljs-string">'person'</span>);
</div><div class="hljs-line">       <span class="hljs-keyword">for</span>(let ele of person){
</div><div class="hljs-line">           let arr = [];
</div><div class="hljs-line">           <span class="hljs-keyword">for</span>(let i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++){
</div><div class="hljs-line">              let {innerHTML} = ele.children[i];
</div><div class="hljs-line">              <span class="hljs-comment">//在XML中的innerHTML不是都兼容的</span>
</div><div class="hljs-line">              arr.push(innerHTML);
</div><div class="hljs-line">           }
</div><div class="hljs-line">           html += `&lt;li&gt;
</div><div class="hljs-line">               我的名字叫${arr[<span class="hljs-number">0</span>]},芳龄:${ele.children[<span class="hljs-number">1</span>].innerHTML}性别:${ele.children[<span class="hljs-number">2</span>].innerHTML}---我想说:${ele.children[<span class="hljs-number">3</span>].innerHTML}    
</div><div class="hljs-line">           &lt;/li&gt;`
</div><div class="hljs-line">       }
</div><div class="hljs-line">       ul.innerHTML = html;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">       <span class="hljs-comment">// console.log(person)</span>
</div><div class="hljs-line">       <span class="hljs-comment">// console.log(xhr.responseXML)</span>
</div><div class="hljs-line">   }
</div><div class="hljs-line">}
</div><div class="hljs-line">&lt;/script&gt;
</div></code></pre>



<h2 id="ajax对象的常用属性和事件">ajax对象的常用属性和事件</h2>

<ul><li><p><strong>onerror  请求失败  比如断网</strong></p></li>
<li><p><strong>onload  请求成功</strong></p></li>
<li><p><strong>onprogress 进度</strong></p></li>
<li><p><strong>upload 上传相关</strong></p></li>
<li><p><strong>onreadystatechange 监听状态的变化  所有浏览器都兼容</strong></p></li>
<li><p><strong>readyState *  状态进行到了哪一步0-4 一共有5步，只是状态值为4的时候说明请求完成，0是监听不到的</strong></p>

<ul>
<li><p>0：请求未初始化</p></li>
<li><p>1：服务器连接已建立</p></li>
<li><p>2：请求已接收</p></li>
<li><p>3：请求处理中</p></li>
<li><p>4：请求已完成，且响应已就绪</p></li></ul></li>
<li><p><strong>responseText   后端返回的数据</strong></p></li>
<li><p><strong>responseXML    XML的document对象</strong></p></li>
<li><p><strong>status        HTTP状态码</strong> （ 比如:200,404）</p>

<ul>
<li><p><strong>1-6开头状态码，如下：</strong></p>

<ul>
<li><p><strong>1 消息</strong></p></li>
<li><p><strong>2 成功  200-207为成功</strong></p></li>
<li><p><strong>3 重定向</strong></p>

<ul>
<li><p>301 永久重定向</p></li>
<li><p>302 请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的</p></li>
<li><p>304 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p></li>
<li><p>305 需要代理</p></li>
<li><p>307 请求的资源临时从不同的URI 响应请求</p></li></ul></li>
<li><p><strong>4 请求错误（前端的锅）</strong></p>

<ul>
<li><p>400 Bad Request</p>

<ul>
<li><p>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</p></li>
<li><p>2、请求参数有误。</p></li></ul></li>
<li><p>401 Unauthorized</p></li>
<li><p>403 Forbidden   服务器已经理解请求，但是拒绝执行它</p></li>
<li><p>404 请求失败</p></li></ul></li>
<li><p><strong>5、6 服务器错误</strong></p>

<ul>
<li><p>只要出现5后端的问题</p></li></ul></li></ul></li></ul></li>
</ul>

<blockquote>
  <p><strong>timeout       超时  设置时间毫秒 比如: xhr.timeout = 3000</strong> <br>
  <strong>ontimeout 超时回调</strong></p>
</blockquote>

<ul><li><p><strong>onreadystatechange 监听状态的变化  所有浏览器都兼容，示例：</strong></p>

<ul>
<li><p><strong>事件绑定在send之前，能够监听建立连接，也就是在异步的情况下，能够多监听一步</strong></p></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line"><span class="hljs-comment">//**onreadystatechange 监听状态的变化  所有浏览器都兼容**</span>
</div><div class="hljs-line">un.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">    <span class="hljs-comment">//虽然IE6以上浏览器支持XMLHttpRequest对象，但是每个版本会有差距</span>
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest;
</div><div class="hljs-line">    xhr.open(<span class="hljs-string">'get'</span>,<span class="hljs-string">'/get1?user='</span>+<span class="hljs-keyword">this</span>.value,<span class="hljs-literal">true</span>);<span class="hljs-comment">//是否异步</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">//事件绑定在send之前，能够监听建立连接，也就是在异步的情况下，能够多监听一步</span>
</div><div class="hljs-line">    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(xhr.readyState === <span class="hljs-number">4</span>){
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-keyword">if</span>(xhr.status&gt;=<span class="hljs-number">200</span> &amp;&amp; xhr.status &lt;= <span class="hljs-number">207</span> || xhr.status == <span class="hljs-number">304</span>){
</div><div class="hljs-line">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功'</span>);
</div><div class="hljs-line">            }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'请求失败'</span>);
</div><div class="hljs-line">            }
</div><div class="hljs-line">            <span class="hljs-comment">// console.log(xhr.readyState);</span>
</div><div class="hljs-line">            <span class="hljs-comment">// console.log(xhr.status);</span>
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-comment">// console.log(xhr.readyState);</span>
</div><div class="hljs-line">    }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    xhr.send();
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">    <span class="hljs-comment">// xhr.onload = function(){</span>
</div><div class="hljs-line">    <span class="hljs-comment">//    console.log(xhr.responseText);</span>
</div><div class="hljs-line">    <span class="hljs-comment">// }</span>
</div><div class="hljs-line">};
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// console.log(Array.prototype.push);</span>
</div></code></pre>



<h1 id="cookie">cookie</h1>

<ul><li><p>一种浏览器缓存，但是它起源又是为了解决后台存储的，cookie是一个后端技术。不过它还可以是前端的技术</p></li>
<li><p>常用的猜你喜欢、刷新登录、7天免登录…</p></li>
<li><p>当用户登录成功之后，再次刷新页面，页面还是会显示让用户再次登录，默认服务器不会保留用户的登录状态</p></li>
<li><p>当用户登录之后，服务器给浏览器设置了一个名为cookie的一种浏览器缓存（切换浏览器之前在另一个浏览器上设置的cookie就无效了），再次刷新的时候浏览器会携带一个cookie码传给服务器，服务器通过这个cookie值进行验证等操作就能判断用户是否登录过。</p></li>
<li><h3 id="cookie读写">cookie读写</h3>

<ul>
<li><p>1.读  document.cookie;  如果有多个值，那么一对存储值和另一对存储值由; (分号+空格)分割</p></li>
<li><p>2.写  document.cookie = ‘key=value’  ** 如果存储值为对象，那么会默认调用toString方法</p></li></ul></li>
<li><h3 id="cookie的小特性">cookie的小特性</h3>

<ul>
<li><p>1.cookie在每个域名中的体积，根据浏览器的规则来定，浏览器的品牌不一样，个数就不一样(对于高版本浏览器据说有5M)</p>

<ul>
<li><p>Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。</p></li>
<li><p>Firefox每个域名cookie限制为50个。</p></li>
<li><p>Opera每个域名cookie限制为30个。</p></li>
<li><p>Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。</p>

<blockquote>
  <p>注：“每个域名cookie限制为20个”将不再正确！</p>
</blockquote></li></ul></li>
<li><p>2.<strong>生命周期（临时、永久或可控）</strong></p>

<ul>
<li><p>(1)默认生命周期为浏览器关闭</p></li>
<li><p>(2)Expires=要设置的时间  这样就可以让cookie在指定时间内死亡</p></li></ul></li></ul></li>
</ul>



<h4 id="能够把对象转成url格式的内置对象">能够把对象转成url格式的内置对象</h4>

<ul><li><p>new URLSearchParams <br>
<code>''+ new URLSearchParams({user:'tony',pass:123})</code></p></li>
</ul>



<h2 id="localstorage本地存储-前端小型的数据库">localStorage(本地存储)-&gt; 前端小型的数据库</h2>

<blockquote>
  <p>体积: 5M左右 ，读写等操作</p>
</blockquote>

<ul><li><h3 id="读写操作">读写操作</h3>

<ul>
<li><p>写: <br>
<code>localStorage.setItem(key,value)</code></p>

<blockquote>
  <p>注意: <br>
  value -&gt; 会自动转成字符串，用数组或者对象的时候要用JSON.stringify(value)</p>
</blockquote></li>
<li><p>读: <br>
<code>localStorage.getItem(key);</code></p></li>
<li><p>清除: <br>
<code>localStorage.clear();</code></p></li></ul></li>
<li><p><strong>生命周期:只要不清除就一直在</strong></p></li>
</ul>



<h3 id="localstorage事件">localStorage事件</h3>

<blockquote>
  <p><strong>window.onstorage</strong> 当localStorage的值发生的变化就触发（是兄弟页面触发，自己不触发）</p>
</blockquote>



<h1 id="跨域">跨域</h1>

<blockquote>
  <p>跨域(源) <br>
  同源策略:是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>
  
  <p>源:域名、端口、协议</p>
  
  <p>同源:同域名、端口、协议 <br>
  跨域:不同域名|不同端口|不同协议，只要有一个不同就跨域</p>
</blockquote>

<p>Access to XMLHttpRequest at ‘<a href="http://localhost:8080/kuayu?user=cc" target="_blank">http://localhost:8080/kuayu?user=cc</a>’ from origin ‘<a href="http://localhost" target="_blank">http://localhost</a>’ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</p>



<pre class="prettyprint hljs-dark"><code class="hljs dts"><div class="hljs-line"><span class="hljs-symbol">    https:</span><span class="hljs-comment">//www.taobao.com:80</span>
</div><div class="hljs-line"><span class="hljs-symbol">    https:</span><span class="hljs-comment">//www.daohao.com:80</span>
</div><div class="hljs-line"><span class="hljs-symbol"></span>
</div><div class="hljs-line"><span class="hljs-symbol"></span>
</div><div class="hljs-line"><span class="hljs-symbol">    https:</span><span class="hljs-comment">//www.taobao.com:80</span>
</div><div class="hljs-line"><span class="hljs-symbol">    https:</span><span class="hljs-comment">//www.taobao.com:81</span>
</div><div class="hljs-line"><span class="hljs-symbol"></span>
</div><div class="hljs-line"><span class="hljs-symbol"></span>
</div><div class="hljs-line"><span class="hljs-symbol">    https:</span><span class="hljs-comment">//www.taobao.com:80</span>
</div><div class="hljs-line"><span class="hljs-symbol">    file:</span><span class="hljs-comment">//www.taobao.com:80</span>
</div><div class="hljs-line"><wbr>
</div></code></pre>



<h2 id="解决跨域问题">解决跨域问题:</h2>

<ul><li><p>常见的解决跨域问题(CORS、服务器代理、jsonp)</p>

<ul>
<li><p><strong>1.CORS进行跨域</strong></p>

<ul>
<li><p>需要高版本浏览器下使用XMLHttpRequest去进行请求</p></li>
<li><p>需要服务器端在响应头上设置一个白名单 <br>
<code>Access-Control-Allow-Origin:'*'</code></p></li>
<li><p><strong>这种解决方案是个趋势，低版本不兼容</strong></p></li></ul></li>
<li><p><strong>2.服务器代理</strong></p>

<ul>
<li><p>A能访问B（同域），但是A不能访问C（跨域），B又能访问C（服务器操作）</p></li>
<li><p>A去访问B，就等同于能够访问C</p></li></ul></li>
<li><p><strong>3.jsonp JSON + Padding  内填充的数据</strong></p>

<ul>
<li><p>兼容低版本</p></li>
<li><p>前后端操作都不复杂</p></li>
<li><p>script标签可以尽量去解析js代码，而且支持跨域 <br>
<code>1.必须在全局暴露一个函数 <br>
function fn(data){ <br>
  console.log(data); <br>
} <br>
2.服务器传输的数据必须是函数名 + 括号 在括号中填充数据的这种格式 <br>
fn([1,2,3,4,5]);</code></p></li></ul></li></ul></li>
</ul>



<h1 id="node含义">NODE含义</h1>

<ul><li><p>基于V8引擎（谷歌浏览器的引擎）渲染JS的工具或者环境</p></li>
</ul>



<h2 id="node安装">NODE安装</h2>

<blockquote>
  <p>安装node网址：<a href="https://nodejs.org/en/" target="_blank">https://nodejs.org/en/</a></p>
</blockquote>

<ul><li><p>1.在服务器下千万不要建中文的文件夹</p></li>
<li><p>2.运行的时候，使用localhost/xx.html运行，千万不要双击或者直接用编辑器打开（<strong>只有把文件放到public目录下才能使用localhost</strong>）</p></li>
<li><p>3.运行文件的时候，一定要开服务器。</p>

<ul>
<li><p>找到当前文件夹按住shift + 鼠标右键  输入node app</p></li>
<li><p>把当前文件夹放到vscode中，然后点击感叹号，找到终端 输入node app <br>
<code>json  -&gt; '{"name":"于海洋"}'  || '[1,2,"3"]' <br>
XML -&gt;  <br>
&lt;person&gt; <br>
&lt;name&gt;于海洋&lt;/name&gt; <br>
&lt;hobby&gt;跟着倪老师学习js&lt;/hobby&gt; <br>
&lt;/person&gt;</code></p></li></ul></li>
</ul>



<h3 id="服务器语言">服务器语言</h3>

<ul><li><p>1、编译性语言</p>

<ul>
<li><p>（1）只须编译一次就可以把源代码编译成机器语言，后面的执行无须重新编译，直接使用之前的编译结果就可以；因此其执行的效率比较高；</p></li>
<li><p>（2）编译性语言代表：C、C++、Pascal/Object Pascal（Delphi）；</p></li>
<li><p>（3）程序执行效率比较高，但比较依赖编译器，因此跨平台性差一些；</p></li></ul></li>
<li><p>2、解释性语言</p>

<ul>
<li><p>（1）源代码不能直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行；</p></li>
<li><p>（2）程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次</p>

<blockquote>
  <p>源代码—&gt;中间代码—&gt;机器语言</p>
</blockquote></li></ul></li>
<li><p>后台管理（vue全家桶、react全家桶） + node + 数据库</p></li>
</ul>



<h3 id="通过node更好的去理解前端做的事情">通过node更好的去理解前端做的事情</h3>

<blockquote>
  <p>Node.js是基于Chrome的V8 JavaScript引擎构建的JavaScript运行环境</p>
</blockquote>



<h3 id="node的优势">node的优势</h3>

<ul><li><p>单线程</p></li>
<li><p>事件驱动</p></li>
<li><p>非阻塞I/O</p></li>
</ul>



<h3 id="npmnode-package-manager">npm(Node Package Manager)</h3>

<ul><li><p>全球最大的包管理平台（下载资源、学习平台）</p></li>
<li><p>一个JS模块（所有封装好可以供其他人调取使用的都可以称之为模块或者包）管理的工具，基于npm可以安装下载JS模块，他会生成一个node执行的命令（可以在DOS窗口或者终端命令中执行）：node xxx.js</p></li>
<li><p>如果不成功，可以找相同电脑配置的人员，把安装成功的NODE文件夹拷贝到自己的电脑上，通过配置环境变量，来实现NODE安装</p></li>
<li><p><strong>node的模块化管理</strong></p>

<ul>
<li><p>通过require(‘http’)引入文件 如果不写路径说明要么node中，要么在node_modules中,否则要加路径如require(‘./3’)</p></li>
<li><p>通过module.exports = {key:value} 去导出</p></li></ul></li>
</ul>

<p><strong>写一个人生中第一个服务器</strong></p>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>); <span class="hljs-comment">//引包</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">//创建服务器</span>
</div><div class="hljs-line"><span class="hljs-comment">/*</span>
</div><div class="hljs-line"><span class="hljs-comment">    request  请求  客户端请求</span>
</div><div class="hljs-line"><span class="hljs-comment">    response 响应  发送给客户端</span>
</div><div class="hljs-line"><span class="hljs-comment">*/</span>
</div><div class="hljs-line"><span class="hljs-comment">//创建服务</span>
</div><div class="hljs-line"><span class="hljs-keyword">const</span> app = http.createServer(<span class="hljs-function">(<span class="hljs-params">request,response</span>)=&gt;</span>{
</div><div class="hljs-line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);
</div><div class="hljs-line">    <span class="hljs-comment">//发送给客户端</span>
</div><div class="hljs-line">    response.write(<span class="hljs-string">"{code:1,msg:'abc'}"</span>);
</div><div class="hljs-line">    <span class="hljs-comment">//结束发送</span>
</div><div class="hljs-line">    response.end();
</div><div class="hljs-line">});
</div><div class="hljs-line"><span class="hljs-comment">//80监听</span>
</div><div class="hljs-line">app.listen(<span class="hljs-number">80</span>);
</div></code></pre>



<h3 id="find-数组方法返回值">find -&gt;数组方法(返回值)</h3>

<ul><li><p><strong>当回调函数中的条件成立的时候返回符合条件的那项；如果找不到，就返回undefined</strong> <br>
<code>Array arr.find(function(item,i,all){})</code></p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
</div><div class="hljs-line"><span class="hljs-keyword">let</span> a=ary.find(<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>e&gt;<span class="hljs-number">1</span>) 
</div><div class="hljs-line"><span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">//=&gt; 2</span>
</div></code></pre>

<p><code>xxx.com?user=abc&amp;pass=123&amp;cb=fn&amp;wd=警察叔叔</code></p>



<h3 id="findindex-数组方法返回索引">findIndex -&gt;数组方法(返回索引)</h3>

<ul><li><p><strong>返回传入一个测试条件（函数）符合条件的数组第一个元素位置</strong></p></li>
<li><p>当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。</p></li>
<li><p>如果没有符合条件的元素返回 -1 <br>
<code>array.findIndex(function(currentValue, index, arr), thisValue)</code></p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>];
</div><div class="hljs-line"><span class="hljs-keyword">let</span> aa = arr.findIndex(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, i, all</span>) </span>{
</div><div class="hljs-line"><span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">10</span>;
</div><div class="hljs-line">})
</div><div class="hljs-line"><span class="hljs-built_in">console</span>.log(aa); <span class="hljs-comment">//=&gt;1</span>
</div></code></pre>



<h3 id="fs-filesystem-文件管理">fs - FileSystem 文件管理</h3>

<blockquote>
  <p>到www目录下找1.txt文件 <br>
  <strong>const fs = require(‘fs’);</strong></p>
</blockquote>

<ul><li><p><strong>读文件操作：fs.readFile / fs.readFileSync</strong></p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// fs.readFile('./www/1.txt', (error, data) =&gt; { </span>
</div><div class="hljs-line"><span class="hljs-comment">//     if (error) {</span>
</div><div class="hljs-line"><span class="hljs-comment">//         console.log(404);</span>
</div><div class="hljs-line"><span class="hljs-comment">//     } else { </span>
</div><div class="hljs-line"><span class="hljs-comment">//         console.log(data.toString());</span>
</div><div class="hljs-line"><span class="hljs-comment">//     }</span>
</div><div class="hljs-line"><span class="hljs-comment">// });</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"> <span class="hljs-keyword">try</span> {
</div><div class="hljs-line">     <span class="hljs-keyword">let</span> data = fs.readFileSync(<span class="hljs-string">'./www/1.txt'</span>);
</div><div class="hljs-line">     <span class="hljs-built_in">console</span>.log(data.toString())
</div><div class="hljs-line"> } <span class="hljs-keyword">catch</span> (error) { 
</div><div class="hljs-line">     <span class="hljs-built_in">console</span>.log(<span class="hljs-number">404</span>);
</div><div class="hljs-line"> }
</div></code></pre>

<ul><li><p><strong>写入文件操作：fs.writeFile / fs.writeFileSync</strong></p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs coffeescript"><div class="hljs-line">const fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-regexp">//</span> fs.writeFile(<span class="hljs-string">'./www/2.txt'</span>, <span class="hljs-string">'wojiaosha'</span>, <span class="hljs-function"><span class="hljs-params">(error)</span> =&gt;</span> { 
</div><div class="hljs-line"><span class="hljs-regexp">//</span>     <span class="hljs-keyword">if</span> (error) {
</div><div class="hljs-line"><span class="hljs-regexp">//</span>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败'</span>);
</div><div class="hljs-line"><span class="hljs-regexp">//</span>     } <span class="hljs-keyword">else</span> { 
</div><div class="hljs-line"><span class="hljs-regexp">//</span>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功'</span>);
</div><div class="hljs-line"><span class="hljs-regexp">//</span>     }
</div><div class="hljs-line"><span class="hljs-regexp">//</span> });
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-keyword">try</span> { 
</div><div class="hljs-line">    fs.writeFileSync(<span class="hljs-string">'./www/3.txt'</span>, <span class="hljs-string">'qwerrtt'</span>)
</div><div class="hljs-line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功'</span>);
</div><div class="hljs-line">}<span class="hljs-keyword">catch</span>(error){ 
</div><div class="hljs-line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败'</span>);
</div><div class="hljs-line">}
</div></code></pre>

<ul><li><p><strong>删除文件操作：fs.unlink / fs.unlinkSync</strong></p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs coffeescript"><div class="hljs-line">const fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-regexp">//</span> fs.unlink(<span class="hljs-string">'./www/3.txt'</span>, <span class="hljs-function"><span class="hljs-params">(error)</span> =&gt;</span> { 
</div><div class="hljs-line"><span class="hljs-regexp">//</span>     <span class="hljs-keyword">if</span> (error) {
</div><div class="hljs-line"><span class="hljs-regexp">//</span>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败'</span>);
</div><div class="hljs-line"><span class="hljs-regexp">//</span>     } <span class="hljs-keyword">else</span> { 
</div><div class="hljs-line"><span class="hljs-regexp">//</span>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功'</span>);
</div><div class="hljs-line"><span class="hljs-regexp">//</span>     }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-regexp">//</span> });
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-keyword">try</span> {
</div><div class="hljs-line">    fs.unlinkSync(<span class="hljs-string">'./www/3.txt'</span>)
</div><div class="hljs-line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功'</span>);
</div><div class="hljs-line">} <span class="hljs-keyword">catch</span> (error) { 
</div><div class="hljs-line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败'</span>);
</div><div class="hljs-line">}
</div></code></pre>



<h2 id="express">express</h2>

<blockquote>
  <p><a href="http://www.expressjs.com.cn/" target="_blank">http://www.expressjs.com.cn/</a> <br>
  Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。</p>
</blockquote>

<p><strong>项目初始化</strong></p>

<ul><li><p><strong>npm init</strong>  如果没有特殊情况无脑回车，走默认配置</p></li>
<li><p><strong>npm init -y</strong></p></li>
</ul>

<p><strong>安装express</strong>：npm install express –save</p>

<ul><li><p><strong>创建一个js文件</strong></p>

<ul>
<li><p>引包 const express = require(‘express’)</p></li>
<li><p>调用express  const app = express()</p></li>
<li><p>监听 app.listen(80)</p></li>
<li><p>如果是get -&gt; app.get(‘路径’,(request,response)=&gt;{})    </p>

<ul>
<li><p>request.query  获取参数对象 </p></li>
<li><p>response.send()  response.json() 发送</p></li></ul></li></ul></li>
<li><p><strong>中间件</strong>：  一堆功能函数，能让使用的对象更加强大（让对象拥有功能函数的功能）</p>

<ul>
<li><p>需要use去关联 比如:app.use(express.static(‘www’)) 管理静态文件</p></li></ul></li>
</ul>



<h3 id="post">post</h3>

<ul><li><p><strong>const bodyParser = require(‘body-parser’);</strong></p></li>
<li><p><strong>app.use(bodyParser.urlencoded({ extended: false }));</strong></p></li>
<li><p><strong>req.body 获取参数</strong></p></li>
</ul>



<h3 id="路由路径切换寻址">路由(路径切换，寻址)</h3>

<blockquote>
  <p><strong>/根</strong> -&gt; /user -&gt; /post -&gt; /get <br>
  <a href="http://www.baidu.com/home" target="_blank">http://www.baidu.com/home</a>  一般默认找home文件夹下的index.html <br>
  <a href="http://www.baidu.com/works" target="_blank">http://www.baidu.com/works</a> 一般默认找works文件夹下的index.html</p>
</blockquote>



<h3 id="express使用路由最多还是写2级就行了">express使用路由最多还是写2级就行了</h3>

<p>app.use(‘/user’,require(‘./routers/users’));</p>

<blockquote>
  <p>users.js的内容如下:</p>
</blockquote>



<pre class="prettyprint hljs-dark"><code class="hljs javascript"><div class="hljs-line"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
</div><div class="hljs-line"><span class="hljs-keyword">const</span> router = express.Router();
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">router.get(<span class="hljs-string">'/'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)</span>{       <span class="hljs-comment">//  /user</span>
</div><div class="hljs-line">    res.send(<span class="hljs-string">'{code:0,msg:"/user"}'</span>);
</div><div class="hljs-line">});
</div><div class="hljs-line">router.get(<span class="hljs-string">'/add'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)</span>{
</div><div class="hljs-line">    res.send(<span class="hljs-string">'{code:0,msg:"/user/add"}'</span>);  <span class="hljs-comment">// /add -&gt; /user/add </span>
</div><div class="hljs-line">});
</div><div class="hljs-line">router.get(<span class="hljs-string">'/rm'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)</span>{
</div><div class="hljs-line">    res.send(<span class="hljs-string">'{code:0,msg:"/user/rm"}'</span>);
</div><div class="hljs-line">});
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-built_in">module</span>.exports = router;
</div></code></pre>



<h3 id="swig">swig</h3>

<ul><li><p>安装 npm i swig -S</p></li>
<li><p>引包 require(‘swig’);</p></li>
<li><p>配置 </p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs less"><div class="hljs-line"><span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.set</span>(<span class="hljs-string">'views'</span>,<span class="hljs-string">'./www'</span>);  <span class="hljs-selector-tag">www</span>就是你模板放置的路径
</div><div class="hljs-line"><span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.set</span>(<span class="hljs-string">'view engine'</span>,<span class="hljs-string">'html'</span>);
</div><div class="hljs-line"><span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.engine</span>(<span class="hljs-string">'html'</span>, swig.renderFile);
</div></code></pre>

<ul><li><p>指定路由模板 <br>
app.use(‘/’,require(‘./routers/index’));</p></li>
<li><p>index文件中</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs less"><div class="hljs-line">    <span class="hljs-selector-tag">router</span><span class="hljs-selector-class">.get</span>(<span class="hljs-string">'/'</span>,(req,res)=&gt;{
</div><div class="hljs-line">        <span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.render</span>(<span class="hljs-string">'index'</span>,{
</div><div class="hljs-line">            <span class="hljs-attribute">title</span>:<span class="hljs-string">'首页'</span>,
</div><div class="hljs-line">            <span class="hljs-attribute">data</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
</div><div class="hljs-line">        })
</div><div class="hljs-line">    });
</div></code></pre>

<ul><li><p>index.html中</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs django"><div class="hljs-line"><span class="xml">    输出数据:</span>
</div><div class="hljs-line"><span class="xml">        </span><span class="hljs-template-variable">{{ 数据的名称 }}</span><span class="xml">  如:</span><span class="hljs-template-variable">{{title}}</span><span class="xml"> -&gt; 首页</span>
</div><div class="hljs-line"><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">    循环数据:</span>
</div><div class="hljs-line"><span class="xml">        </span><span class="hljs-template-tag">{%<span class="hljs-name"><span class="hljs-name">for</span></span> key,val <span class="hljs-keyword">in</span> data%}</span><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">        </span><span class="hljs-template-tag">{%<span class="hljs-name"><span class="hljs-name">endfor</span></span>%}</span><span class="xml"></span>
</div><div class="hljs-line"><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">    判断:</span>
</div><div class="hljs-line"><span class="xml">        </span><span class="hljs-template-tag">{%<span class="hljs-name"><span class="hljs-name">if</span></span> 条件%}</span><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">            执行语句一</span>
</div><div class="hljs-line"><span class="xml">        </span><span class="hljs-template-tag">{%<span class="hljs-name"><span class="hljs-name">else</span></span>%}</span><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">            执行语句二</span>
</div><div class="hljs-line"><span class="xml">        </span><span class="hljs-template-tag">{%<span class="hljs-name"><span class="hljs-name">endif</span></span>%}</span><span class="xml"></span>
</div></code></pre>



<h3 id="express-脚手架一个配好的运行环境不需要自己配置">express 脚手架(一个配好的运行环境,不需要自己配置)</h3>

<ul><li><p>npm install express-generator -g</p></li>
<li><p>express –view=pug myapp</p></li>
<li><p>cd myapp</p></li>
<li><p>npm install</p></li>
<li><p>npm start 启动</p></li>
</ul>



<h3 id="webpack">webpack</h3>

<ul><li><p>懵，不懂，难，恶心，带有人类的逆反心理，难点是英语(报错是英语报错)</p></li>
<li><p>多练，多报错多翻译，弄到报错眼熟你就学会了，见过就会没见过就不会</p></li>
<li><p>安装、安装、安装，翻文档看配置，进行配置</p></li>
<li><p>优化</p></li>
</ul>



<h3 id="自动化构建工具">自动化构建工具</h3>

<ul><li><p>开发依赖主要是为了维护（给程序员看的）</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs dust"><div class="hljs-line"><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.js"</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span>
</div><div class="hljs-line"><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"2.js"</span>&gt;</span><span class="javascript"></span></span>
</div><div class="hljs-line"><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">     CommonJS 用到既加载（规范） </span>
</div><div class="hljs-line"><span class="xml">     模块化开发</span>
</div><div class="hljs-line"><span class="xml">     CMD   seajs</span>
</div><div class="hljs-line"><span class="xml">     AMD   先加载后使用（规范）  <span class="hljs-built_in">require</span></span>
</div><div class="hljs-line"><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">     glup</span>
</div><div class="hljs-line"><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">     引入  -&gt; <span class="hljs-built_in">require</span></span>
</div><div class="hljs-line"><span class="xml">     导出 -&gt; <span class="hljs-built_in">module</span>.exports</span>
</div><div class="hljs-line"><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">     ES6:引入:</span>
</div><div class="hljs-line"><span class="xml">         <span class="hljs-keyword">import</span> </span><span class="hljs-template-variable">{ fn }</span><span class="xml"><span class="javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">'1.js'</span> <span class="hljs-comment">//'模块名称';</span></span></span>
</div><div class="hljs-line"><span class="xml">         <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span></span><span class="hljs-template-variable">{}</span><span class="xml"><span class="actionscript">   <span class="hljs-comment">//1.js </span></span></span>
</div></code></pre>

<ul><li><p>生产依赖主要给用户使用的(体积小)</p></li>
</ul>



<h4 id="dirname-当前路径">__dirname 当前路径</h4>



<h4 id="new-formdata专门处理二进制数据它下面只有一个方法appendkeyvalue">new FormData专门处理二进制数据，它下面只有一个方法，append(key,value)</h4>



<h2 id="webpack-自动化构建工具项目构建打包处理转换让浏览器支持的语法">webpack 自动化构建工具、项目构建、打包处理、转换让浏览器支持的语法</h2>

<p><a href="https://www.webpackjs.com/concepts/" target="_blank">https://www.webpackjs.com/concepts/</a> 官网</p>

<blockquote>
  <p>难点-&gt; 英文 <br>
  目标:当学完之后，希望大家都能够自己手动配置webpack <br>
  一般结果 -&gt; 学完之后，啥东西？干啥的？我是谁？我在哪？</p>
  
  <div id="box"></div> -&gt; <div id="box"></div>
</blockquote>



<h3 id="四个核心概念">四个核心概念</h3>

<ul><li><p><strong>入口(entry)</strong></p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs less"><div class="hljs-line">    <span class="hljs-attribute">entry</span>:<span class="hljs-string">'./2.js'</span>,  字符串，单入口
</div><div class="hljs-line">    <span class="hljs-attribute">entry</span>:[<span class="hljs-string">'./2'</span>,<span class="hljs-string">'./1'</span>], <span class="hljs-comment">//多入口单出口</span>
</div><div class="hljs-line">    <span class="hljs-attribute">output</span>:{
</div><div class="hljs-line">        <span class="hljs-attribute">filename</span>:<span class="hljs-string">'haha.js'</span>
</div><div class="hljs-line">    }
</div><div class="hljs-line">    <span class="hljs-comment">//多入口多出口</span>
</div><div class="hljs-line">    <span class="hljs-attribute">entry</span>:{
</div><div class="hljs-line">        <span class="hljs-attribute">index</span>:<span class="hljs-string">'./2'</span>,
</div><div class="hljs-line">        <span class="hljs-attribute">aa</span>:<span class="hljs-string">'./1'</span>
</div><div class="hljs-line">    },
</div><div class="hljs-line">    <span class="hljs-attribute">output</span>:{
</div><div class="hljs-line">        <span class="hljs-attribute">filename</span>:<span class="hljs-string">'[name].[hash:8].js'</span>  
</div><div class="hljs-line">    }
</div><div class="hljs-line">    <span class="hljs-selector-tag">name</span>就表示<span class="hljs-selector-tag">entry</span>的<span class="hljs-selector-tag">key</span>
</div><div class="hljs-line"><wbr>
</div></code></pre>

<ul><li><p><strong>输出(output)</strong></p></li>
<li><p><strong>loader：模块的源代码进行转换</strong> <br>
<code>module:{ <br>
rules:[ <br>
    { <br>
        test:/\.css$/,  //处理上面文件 <br>
        use:[需要的模块] <br>
    } <br>
] <br>
}</code></p></li>
<li><p><strong>插件(plugins)</strong> <br>
<code>plugins:[new HTML({}),new Xxx()]</code></p></li>
</ul>



<h3 id="安装">安装</h3>

<ul><li><p>npm i webpack webpack-cli –golbal  （第一次安装需要那么做）</p></li>
<li><p>项目目录名称千万不要写webpack</p></li>
<li><p>npm init -y(到你项目的目录中输入)</p></li>
<li><p>npm i webpack webpack-cli –save   （只要安装过，就不用安装上面那句话了）</p></li>
</ul>



<h3 id="配置">配置</h3>

<ul><li><p>自己手动创建一个webpack.config.js的文件</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="hljs ebnf"><div class="hljs-line"><span class="hljs-attribute">const path</span> = require(<span class="hljs-string">'path'</span>);
</div><div class="hljs-line"><span class="hljs-attribute">const obj</span> = {
</div><div class="hljs-line">    entry:<span class="hljs-string">'./2.js'</span>,
</div><div class="hljs-line">    output:{
</div><div class="hljs-line">        filename:<span class="hljs-string">'2.js'</span>,
</div><div class="hljs-line">        path:path.relove(__dirname,<span class="hljs-string">'./build'</span>)
</div><div class="hljs-line">    }
</div><div class="hljs-line">}
</div><div class="hljs-line">module.exports = obj;
</div><div class="hljs-line"><wbr>
</div></code></pre>



<h3 id="设置packagejson-文件">设置package.json 文件</h3>

<blockquote>
  <p>找到scripts 设置值为 “build（自定义名称）”:”webpack” <br>
  到命令行输入npm run build</p>
</blockquote>



<h3 id="mode设置">mode设置</h3>

<blockquote>
  <p>production  生产环境   让用户看的 <br>
  development 开发环境   让程序员看的</p>
</blockquote>



<h4 id="webpack常用的插件安装命令">webpack常用的插件安装命令：</h4>

<ul><li><p>1：npm install html-webpack-plugin –save-dev //自动快速的帮我们生成HTML。</p></li>
<li><p>2：npm install css-loader style-loader –save-dev//样式文件，我们需要两种loader，css-loader 和 style－loader，css-loader会遍历css文件，找到所有的url(…)并且处理。style-loader会把所有的样式插入到你页面的一个style tag中。</p></li>
<li><p>3:npm install babel-loader css-loader style-loader –save-dev// 安装加载器(babel-loader 进行转码</p>

<ul>
<li><p>css-loader 对 css 文件进行打包</p></li>
<li><p>style-loader 将样式添加进 DOM 中)</p></li></ul></li>
<li><p>4：npm install sass-loader node-sass –save-dev//css预编译程序，还需要添加node-sass来解析sass文件</p></li>
<li><p>5：npm install url-loader –save-dev//图片自动转成base64编码的</p></li>
<li><p>6:npm install jquery moment –save-dev//添加第三方库(jquery和moment)</p></li>
<li><p>7:npm install babel-preset-es2015 –save-dev//添加ES6的支持</p></li>
<li><p>8:npm install babel-preset-es2015 babel-preset-react –save-dev//安装转码规则</p></li>
<li><p>9：npm install webpack-dev-middleware –save-dev//服务器端使用的是express框架，你还可以直接安装express的middleware，webpack配合express</p></li>
<li><p>10: npm install react –save-dev//安装并引用 React 模块</p></li>
<li><p>11：npm install react react-dom –save-dev//添加react和react-dom</p></li>
<li><p>12：npm install react-hot-loader –save-dev//react-hot-loader 是一款非常好用的 React 热插拔的加载插件，通过它可以实现修改-运行同步的效果，配合 webpack-dev-server 使用更佳！</p></li>
<li><p>13：npm install –save-dev autoprefixer postcss-loader –save-dev//</p></li>
<li><p>14：npm install babel-loader coffee-loader –save-dev//</p></li>
<li><p>15: npm install autoprefixer-loader –save-dev//</p></li>
<li><p>16: npm install vue –save-dev//</p></li>
<li><p>17: npm install -d //将项目中package.json依赖的包全部下载到该项目中</p></li>
</ul></div></body></html>